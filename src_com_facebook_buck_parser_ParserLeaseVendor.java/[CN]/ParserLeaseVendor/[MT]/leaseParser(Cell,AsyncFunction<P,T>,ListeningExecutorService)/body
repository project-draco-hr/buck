{
  Preconditions.checkState(!closing.get());
  final ListenableFuture<P> obtainedParser=obtainParser(cell);
  final ListenableFuture<T> futureWork=Futures.transformAsync(obtainedParser,new AsyncFunction<P,T>(){
    @Override public ListenableFuture<T> apply(    P input) throws Exception {
      if (closing.get()) {
        return Futures.immediateCancelledFuture();
      }
      return withParser.apply(input);
    }
  }
,executorService);
synchronized (pendingLeases) {
    pendingLeases.add(futureWork);
  }
  futureWork.addListener(new Runnable(){
    @Override public void run(){
      try {
        returnParser(cell,obtainedParser.get(0,TimeUnit.MILLISECONDS));
      }
 catch (      ExecutionException|InterruptedException|TimeoutException e) {
        LOG.error(e);
        Throwables.propagate(e);
      }
 finally {
synchronized (pendingLeases) {
          pendingLeases.remove(futureWork);
        }
      }
    }
  }
,executorService);
  return futureWork;
}
