{
  ImmutableSortedSet.Builder<BuildRule> thinRules=ImmutableSortedSet.naturalOrder();
  for (  BuildTarget thinTarget : fatBinaryInfo.getThinTargets()) {
    Optional<BuildRule> existingThinRule=resolver.getRuleOptional(thinTarget);
    if (existingThinRule.isPresent()) {
      thinRules.add(existingThinRule.get());
      continue;
    }
    BuildRule thinRule=createThinBinary(targetGraph,params.copyWithBuildTarget(thinTarget),resolver,args);
    resolver.addToIndex(thinRule);
    thinRules.add(thinRule);
  }
  ImmutableSortedSet<SourcePath> inputs=FluentIterable.from(resolver.getAllRules(fatBinaryInfo.getThinTargets())).transform(SourcePaths.getToBuildTargetSourcePath()).toSortedSet(Ordering.natural());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  return new FatBinary(params.copyWithDeps(Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()),Suppliers.ofInstance(thinRules.build())),pathResolver,fatBinaryInfo.getRepresentativePlatform().getLipo(),inputs,BuildTargets.getGenPath(params.getBuildTarget(),"%s"));
}
