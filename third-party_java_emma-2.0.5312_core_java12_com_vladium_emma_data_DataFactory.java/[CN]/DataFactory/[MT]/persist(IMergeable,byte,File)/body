{
  final Logger log=Logger.getLogger();
  final boolean trace1=log.atTRACE1();
  final boolean trace2=log.atTRACE2();
  final String method="persist";
  long start=0, end;
  if (trace1)   start=System.currentTimeMillis();
  RandomAccessFile raf=null;
  try {
    boolean overwrite=false;
    boolean truncate=false;
    if (file.exists()) {
      if (!file.isFile())       throw new IOException("can persist in normal files only: " + file.getAbsolutePath());
      raf=new RandomAccessFile(file,"rw");
      final long length=raf.length();
      if (trace1)       log.trace1(method,"[" + file + "]: existing file length = "+ length);
      if (length < 4) {
        overwrite=true;
        truncate=(length > 0);
      }
 else {
        final int magic=raf.readInt();
        if (magic != MAGIC)         throw new IOException("cannot overwrite [" + file.getAbsolutePath() + "]: not created by "+ IAppConstants.APP_NAME);
        if (length < FILE_HEADER_LENGTH) {
          overwrite=true;
          truncate=true;
        }
 else {
{
            final long dataVersion=raf.readLong();
            if (dataVersion != IAppConstants.DATA_FORMAT_VERSION) {
              int major=0, minor=0, build=0;
              boolean gotAppVersion=false;
              try {
                major=raf.readInt();
                minor=raf.readInt();
                build=raf.readInt();
                gotAppVersion=true;
              }
 catch (              Throwable ignore) {
              }
              if (gotAppVersion) {
                throw new IOException("cannot merge new data into [" + file.getAbsolutePath() + "]: created by another "+ IAppConstants.APP_NAME+ " version ["+ makeAppVersion(major,minor,build)+ "]");
              }
 else {
                throw new IOException("cannot merge new data into [" + file.getAbsolutePath() + "]: created by another "+ IAppConstants.APP_NAME+ " version");
              }
            }
 else {
              raf.seek(FILE_HEADER_LENGTH);
              if (length == FILE_HEADER_LENGTH) {
                writeEntry(log,raf,FILE_HEADER_LENGTH,data,type);
              }
 else {
                long position=FILE_HEADER_LENGTH;
                long entryLength;
                while (true) {
                  if (trace2)                   log.trace2(method,"[" + file + "]: position "+ raf.getFilePointer());
                  if (position >= length)                   break;
                  entryLength=raf.readLong();
                  if ((entryLength <= 0) || (position + entryLength + ENTRY_HEADER_LENGTH > length))                   break;
 else {
                    if (trace2)                     log.trace2(method,"[" + file + "]: found valid entry of size "+ entryLength);
                    position+=entryLength + ENTRY_HEADER_LENGTH;
                    raf.seek(position);
                  }
                }
                if (trace2)                 log.trace2(method,"[" + file + "]: adding entry at position "+ position);
                writeEntry(log,raf,position,data,type);
              }
            }
          }
        }
      }
    }
 else {
      if (trace1)       log.trace1(method,"[" + file + "]: creating a new file");
      final File parent=file.getParentFile();
      if (parent != null)       parent.mkdirs();
      raf=new RandomAccessFile(file,"rw");
      overwrite=true;
    }
    if (overwrite) {
      if ($assert.ENABLED)       $assert.ASSERT(raf != null,"raf = null");
      if (truncate)       raf.seek(0);
      writeFileHeader(raf);
      if ($assert.ENABLED)       $assert.ASSERT(raf.getFilePointer() == FILE_HEADER_LENGTH,"invalid header length: " + raf.getFilePointer());
      writeEntry(log,raf,FILE_HEADER_LENGTH,data,type);
    }
  }
  finally {
    if (raf != null)     try {
      raf.close();
    }
 catch (    Throwable ignore) {
    }
    raf=null;
  }
  if (trace1) {
    end=System.currentTimeMillis();
    log.trace1(method,"[" + file + "]: file processed in "+ (end - start)+ " ms");
  }
}
