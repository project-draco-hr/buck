{
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule ruleA=createRule("A",pathResolver);
  BuildRule ruleB=createRule("B",pathResolver);
  BuildRule ruleC=createRule("C",pathResolver);
  BuildRule ruleD=createRule("D",pathResolver);
  BuildRule ruleE=createRule("E",pathResolver);
  BuildRule ruleF=createRule("F",pathResolver,ruleE,ruleD);
  BuildRule ruleG=createRule("G",pathResolver);
  BuildRule ruleH=createRule("H",pathResolver,ruleC,ruleB);
  BuildRule ruleI=createRule("I",pathResolver,ruleA);
  BuildRule initialRule=createRule("J",pathResolver,ruleF,ruleG,ruleH,ruleI);
  final List<BuildRule> buildRuleTraversalOrder=Lists.newArrayList();
  new AbstractDependencyVisitor(initialRule){
    @Override public ImmutableSet<BuildRule> visit(    BuildRule rule){
      buildRuleTraversalOrder.add(rule);
      return rule.getDeps();
    }
  }
.start();
  assertEquals("Dependencies should be explored depth-first, using lexicographic ordering to break ties",ImmutableList.of(initialRule,ruleF,ruleG,ruleH,ruleI,ruleD,ruleE,ruleB,ruleC,ruleA),buildRuleTraversalOrder);
}
