{
  SimpleProcessListener listener=new SimpleProcessListener();
  ListeningProcessExecutor.LaunchedProcess process=executor.launchProcess(ProcessExecutorParams.ofCommand(args),listener);
  long startTimeNanos=clock.nanoTime();
  int exitCode=executor.waitForProcess(process,Math.min(timeoutNanos,POLL_TIME_NANOS),TimeUnit.NANOSECONDS);
  if (exitCode == Integer.MIN_VALUE) {
    long remainingNanos=timeoutNanos - (clock.nanoTime() - startTimeNanos);
    if (remainingNanos > 0) {
      console.getStdErr().getRawStream().format("Waiting for Watchman command [%s]...\n",Joiner.on(" ").join(args));
      exitCode=executor.waitForProcess(process,remainingNanos,TimeUnit.NANOSECONDS);
    }
  }
  LOG.debug("Waited %d ms for Watchman command %s, exit code %d",TimeUnit.NANOSECONDS.toMillis(clock.nanoTime() - startTimeNanos),Joiner.on(" ").join(args),exitCode);
  if (exitCode == Integer.MIN_VALUE) {
    LOG.warn("Watchman did not respond within %d ms, disabling.",TimeUnit.NANOSECONDS.toMillis(TIMEOUT_NANOS));
    console.getStdErr().getRawStream().format("Timed out after %d ms waiting for Watchman command [%s]. Disabling Watchman.\n",TimeUnit.NANOSECONDS.toMillis(TIMEOUT_NANOS),Joiner.on(" ").join(args));
    return Optional.absent();
  }
  if (exitCode != 0) {
    LOG.error("Error %d executing %s",exitCode,Joiner.on(" ").join(args));
    return Optional.absent();
  }
  String stdout=listener.getStdout();
  LOG.debug("stdout of command: " + stdout);
  Map<String,String> output=OBJECT_MAPPER.readValue(stdout,new TypeReference<Map<String,String>>(){
  }
);
  return Optional.fromNullable(output);
}
