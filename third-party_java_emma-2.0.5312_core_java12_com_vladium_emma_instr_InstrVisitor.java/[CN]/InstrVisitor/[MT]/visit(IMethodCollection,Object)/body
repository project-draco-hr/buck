{
  final ClassDef cls=m_cls;
  final boolean trace2=m_log.atTRACE2();
  final int originalMethodCount=methods.size();
  final boolean constructMetadata=m_metadata;
  m_classBlockCounts=new int[originalMethodCount + 1];
  if (constructMetadata) {
    m_classBlockMetadata=new int[originalMethodCount + 1][][];
    m_classMethodDescriptors=new MethodDescriptor[originalMethodCount];
  }
  for (int m=0; m < originalMethodCount; ++m) {
    final Method_info method=methods.get(m);
    m_methodName=method.getName(cls);
    if (trace2)     m_log.trace2("visit",(method.isSynthetic() ? "synthetic " : "") + "method #" + m+ ": ["+ m_methodName+ "]");
    final boolean isClinit=IClassDefConstants.CLINIT_NAME.equals(m_methodName);
    boolean excluded=false;
    if (!isClinit) {
      if (m_excludeSyntheticMethods && method.isSynthetic()) {
        excluded=true;
        if (trace2)         m_log.trace2("visit","skipped synthetic method");
      }
 else       if (m_excludeBridgeMethods && method.isBridge()) {
        excluded=true;
        if (trace2)         m_log.trace2("visit","skipped bridge method");
      }
    }
    if (excluded) {
      if (constructMetadata) {
        m_classMethodDescriptors[m]=new MethodDescriptor(m_methodName,method.getDescriptor(cls),IMetadataConstants.METHOD_EXCLUDED,m_methodBlockSizes,null,0);
      }
    }
 else {
      if ((method.getAccessFlags() & (IAccessFlags.ACC_ABSTRACT | IAccessFlags.ACC_NATIVE)) != 0) {
        if (constructMetadata) {
          m_classMethodDescriptors[m]=new MethodDescriptor(m_methodName,method.getDescriptor(cls),IMetadataConstants.METHOD_ABSTRACT_OR_NATIVE,m_methodBlockSizes,null,0);
        }
        if (trace2)         m_log.trace2("visit","skipped " + (method.isAbstract() ? "abstract" : "native") + " method");
      }
 else {
        m_methodFirstLine=0;
        m_methodID=m;
        if (isClinit) {
          m_clinitID=m;
          if (trace2)           m_log.trace2("visit","<clinit> method delayed");
        }
 else {
          final IAttributeCollection attributes=method.getAttributes();
          final int attributeCount=attributes.size();
          for (int a=0; a < attributeCount; ++a) {
            final Attribute_info attribute=attributes.get(a);
            attribute.accept(this,ctx);
          }
          if (constructMetadata) {
            if ($assert.ENABLED)             $assert.ASSERT(m_classBlockCounts[m_methodID] > 0,"invalid block count for method " + m_methodID + ": "+ m_classBlockCounts[m_methodID]);
            if ($assert.ENABLED)             $assert.ASSERT(m_methodBlockSizes != null && m_methodBlockSizes.length == m_classBlockCounts[m_methodID],"invalid block sizes map for method " + m_methodID);
            final int[][] methodBlockMetadata=m_classBlockMetadata[m_methodID];
            final int status=(methodBlockMetadata == null ? IMetadataConstants.METHOD_NO_LINE_NUMBER_TABLE : 0);
            m_classMethodDescriptors[m]=new MethodDescriptor(m_methodName,method.getDescriptor(cls),status,m_methodBlockSizes,methodBlockMetadata,m_methodFirstLine);
          }
        }
      }
    }
  }
  final boolean instrumentClinit=false;
  final Method_info clinit;
  if (m_clinitID >= 0) {
    clinit=methods.get(m_clinitID);
    m_classInstrMethodCount=originalMethodCount;
  }
 else {
    m_clinitStatus=IMetadataConstants.METHOD_ADDED;
    final int attribute_name_index=cls.addCONSTANT_Utf8(Attribute_info.ATTRIBUTE_CODE,true);
    final int name_index=cls.addCONSTANT_Utf8(IClassDefConstants.CLINIT_NAME,true);
    final int descriptor_index=cls.addCONSTANT_Utf8("()V",true);
    final IAttributeCollection attributes;
    if (MARK_ADDED_ELEMENTS_SYNTHETIC)     attributes=ElementFactory.newAttributeCollection(2);
 else     attributes=ElementFactory.newAttributeCollection(1);
    final CodeAttribute_info code=new CodeAttribute_info(attribute_name_index,0,0,new byte[]{(byte)_return},AttributeElementFactory.newExceptionHandlerTable(0),ElementFactory.newAttributeCollection(0));
    attributes.add(code);
    if (MARK_ADDED_ELEMENTS_SYNTHETIC) {
      attributes.add(new SyntheticAttribute_info(m_syntheticStringIndex));
    }
    clinit=new Method_info(IAccessFlags.ACC_STATIC | IAccessFlags.ACC_PRIVATE,name_index,descriptor_index,attributes);
    m_clinitID=cls.addMethod(clinit);
    if (trace2)     m_log.trace2("visit","added synthetic <clinit> method");
    m_classInstrMethodCount=originalMethodCount + 1;
  }
  if ($assert.ENABLED)   $assert.ASSERT(m_classInstrMethodCount >= 0,"m_classInstrMethodCount not set");
{
    m_methodFirstLine=0;
    m_methodID=m_clinitID;
    if (trace2)     m_log.trace2("visit",(clinit.isSynthetic() ? "synthetic " : "") + "method #" + m_methodID+ ": [<clinit>]");
    final IAttributeCollection attributes=clinit.getAttributes();
    final int attributeCount=attributes.size();
    for (int a=0; a < attributeCount; ++a) {
      final Attribute_info attribute=attributes.get(a);
      attribute.accept(this,ctx);
    }
  }
{
    final int attribute_name_index=cls.addCONSTANT_Utf8(Attribute_info.ATTRIBUTE_CODE,true);
    final int name_index=cls.addCONSTANT_Utf8(PRECLINIT_METHOD_NAME,false);
    final int descriptor_index=cls.addCONSTANT_Utf8("()[[Z",false);
    final IAttributeCollection attributes;
    if (MARK_ADDED_ELEMENTS_SYNTHETIC)     attributes=ElementFactory.newAttributeCollection(2);
 else     attributes=ElementFactory.newAttributeCollection(1);
    final ByteArrayOStream buf=new ByteArrayOStream(PRECLINIT_INIT_CAPACITY);
{
      final int[] blockCounts=m_classBlockCounts;
      final int instrMethodCount=m_classInstrMethodCount;
      if ($assert.ENABLED)       $assert.ASSERT(blockCounts != null && blockCounts.length >= instrMethodCount,"invalid block count map");
      CodeGen.push_int_value(buf,cls,instrMethodCount);
      final int type_index=cls.addClassref("[[Z");
      buf.write4(_multianewarray,type_index >>> 8,type_index,1);
      buf.write4(_dup,_putstatic,m_coverageFieldrefIndex >>> 8,m_coverageFieldrefIndex);
      for (int m=0; m < instrMethodCount; ++m) {
        final int blockCount=blockCounts[m];
        if (blockCount > 0) {
          buf.write(_dup);
          CodeGen.push_int_value(buf,cls,m);
          CodeGen.push_int_value(buf,cls,blockCount);
          buf.write3(_newarray,4,_aastore);
        }
      }
{
        buf.write(_dup);
        CodeGen.push_constant_index(buf,m_classNameConstantIndex);
        buf.write3(_ldc2_w,m_stampIndex >>> 8,m_stampIndex);
        buf.write3(_invokestatic,m_registerMethodrefIndex >>> 8,m_registerMethodrefIndex);
      }
      buf.write(_areturn);
    }
    final CodeAttribute_info code=new CodeAttribute_info(attribute_name_index,5,0,EMPTY_BYTE_ARRAY,AttributeElementFactory.newExceptionHandlerTable(0),ElementFactory.newAttributeCollection(0));
    code.setCode(buf.getByteArray(),buf.size());
    attributes.add(code);
    if (MARK_ADDED_ELEMENTS_SYNTHETIC) {
      attributes.add(new SyntheticAttribute_info(m_syntheticStringIndex));
    }
    final Method_info preclinit=new Method_info(IAccessFlags.ACC_STATIC | IAccessFlags.ACC_PRIVATE,name_index,descriptor_index,attributes);
    cls.addMethod(preclinit);
    if (trace2)     m_log.trace2("visit","added synthetic pre-<clinit> method");
  }
  if (constructMetadata) {
    if ($assert.ENABLED)     $assert.ASSERT(m_classBlockCounts[m_methodID] > 0,"invalid block count for method " + m_methodID + " ("+ IClassDefConstants.CLINIT_NAME+ "): "+ m_classBlockCounts[m_methodID]);
    if ($assert.ENABLED)     $assert.ASSERT(m_methodBlockSizes != null && m_methodBlockSizes.length == m_classBlockCounts[m_methodID],"invalid block sizes map for method " + m_methodID);
    final int[][] methodBlockMetadata=m_classBlockMetadata[m_methodID];
    m_clinitStatus|=(methodBlockMetadata == null ? IMetadataConstants.METHOD_NO_LINE_NUMBER_TABLE : 0);
    if ((m_clinitStatus & IMetadataConstants.METHOD_ADDED) == 0)     m_classMethodDescriptors[m_methodID]=new MethodDescriptor(IClassDefConstants.CLINIT_NAME,clinit.getDescriptor(cls),m_clinitStatus,m_methodBlockSizes,methodBlockMetadata,m_methodFirstLine);
  }
  return ctx;
}
