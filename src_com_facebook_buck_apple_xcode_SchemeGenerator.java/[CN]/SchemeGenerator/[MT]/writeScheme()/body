{
  Iterable<BuildRule> buildRulesIterable=Iterables.concat(AppleBuildRules.getRecursiveRuleDependenciesOfTypes(AppleBuildRules.RecursiveRuleDependenciesMode.BUILDING,this.primaryRule,Optional.<ImmutableSet<BuildRuleType>>absent()),ImmutableSet.of(this.primaryRule));
  List<BuildRule> orderedBuildRules=ImmutableList.copyOf(Iterables.filter(buildRulesIterable,new Predicate<BuildRule>(){
    @Override public boolean apply(    @Nullable BuildRule input){
      if (!AppleBuildRules.isXcodeTargetBuildRuleType(input.getType()) && XcodeNativeDescription.TYPE != input.getType()) {
        return false;
      }
      expectTargetMapContainsRule(input);
      return true;
    }
  }
));
  final ImmutableSet<BuildRule> realTestRules=ImmutableSet.copyOf(Iterables.filter(testRules,new Predicate<BuildRule>(){
    @Override public boolean apply(    @Nullable BuildRule input){
      return AppleBuildRules.isXcodeTargetTestBuildRule(input);
    }
  }
));
  final List<BuildRule> orderedRealTestRules=TopologicalSort.sort(partialGraph.getActionGraph(),new Predicate<BuildRule>(){
    @Override public boolean apply(    @Nullable BuildRule input){
      return realTestRules.contains(input);
    }
  }
);
  ImmutableSet.Builder<BuildRule> recursiveTestRulesBuilder=ImmutableSet.builder();
  for (  BuildRule testRule : realTestRules) {
    Iterable<BuildRule> testRulesIterable=Iterables.concat(AppleBuildRules.getRecursiveRuleDependenciesOfTypes(AppleBuildRules.RecursiveRuleDependenciesMode.BUILDING,testRule,Optional.<ImmutableSet<BuildRuleType>>absent()),ImmutableSet.of(testRule));
    recursiveTestRulesBuilder.addAll(testRulesIterable);
  }
  final ImmutableSet<BuildRule> includedTestRules=ImmutableSet.copyOf(Sets.difference(recursiveTestRulesBuilder.build(),ImmutableSet.copyOf(orderedBuildRules)));
  List<BuildRule> orderedTestRules=TopologicalSort.sort(partialGraph.getActionGraph(),new Predicate<BuildRule>(){
    @Override public boolean apply(    @Nullable BuildRule input){
      if (!includedTestRules.contains(input) || !AppleBuildRules.isXcodeTargetBuildRuleType(input.getType())) {
        return false;
      }
      expectTargetMapContainsRule(input);
      return true;
    }
  }
);
  Map<BuildRule,XCScheme.BuildableReference> buildRuleToBuildableReferenceMap=Maps.newHashMap();
  for (  BuildRule rule : Iterables.concat(orderedBuildRules,orderedTestRules)) {
    PBXTarget target=buildRuleToTargetMap.get(rule);
    String blueprintName=target.getProductName();
    if (blueprintName == null) {
      blueprintName=target.getName();
    }
    XCScheme.BuildableReference buildableReference=new XCScheme.BuildableReference(outputDirectory.getParent().relativize(targetToProjectPathMap.get(target)).toString(),target.getGlobalID(),target.getProductReference().getName(),blueprintName);
    buildRuleToBuildableReferenceMap.put(rule,buildableReference);
  }
  XCScheme.BuildAction buildAction=new XCScheme.BuildAction();
  for (  BuildRule rule : Iterables.concat(orderedBuildRules,orderedTestRules)) {
    EnumSet<XCScheme.BuildActionEntry.BuildFor> buildFor;
    if (testRules.contains(rule)) {
      buildFor=XCScheme.BuildActionEntry.BuildFor.TEST_ONLY;
    }
 else {
      buildFor=XCScheme.BuildActionEntry.BuildFor.DEFAULT;
    }
    XCScheme.BuildableReference buildableReference=buildRuleToBuildableReferenceMap.get(rule);
    XCScheme.BuildActionEntry entry=new XCScheme.BuildActionEntry(buildableReference,buildFor);
    buildAction.addBuildAction(entry);
  }
  XCScheme.TestAction testAction=new XCScheme.TestAction(actionConfigNames.get(SchemeActionType.TEST));
  for (  BuildRule rule : orderedRealTestRules) {
    if (rule.getType().equals(AppleTestDescription.TYPE)) {
      AppleTest test=(AppleTest)rule;
      rule=test.getTestBundle();
    }
    XCScheme.BuildableReference buildableReference=buildRuleToBuildableReferenceMap.get(rule);
    XCScheme.TestableReference testableReference=new XCScheme.TestableReference(buildableReference);
    testAction.addTestableReference(testableReference);
  }
  Optional<XCScheme.LaunchAction> launchAction=Optional.absent();
  Optional<XCScheme.ProfileAction> profileAction=Optional.absent();
  XCScheme.BuildableReference primaryBuildableReference=buildRuleToBuildableReferenceMap.get(primaryRule);
  if (primaryBuildableReference != null) {
    launchAction=Optional.of(new XCScheme.LaunchAction(primaryBuildableReference,actionConfigNames.get(SchemeActionType.LAUNCH)));
    profileAction=Optional.of(new XCScheme.ProfileAction(primaryBuildableReference,actionConfigNames.get(SchemeActionType.PROFILE)));
  }
  XCScheme.AnalyzeAction analyzeAction=new XCScheme.AnalyzeAction(actionConfigNames.get(SchemeActionType.ANALYZE));
  XCScheme.ArchiveAction archiveAction=new XCScheme.ArchiveAction(actionConfigNames.get(SchemeActionType.ARCHIVE));
  XCScheme scheme=new XCScheme(schemeName,Optional.of(buildAction),Optional.of(testAction),launchAction,profileAction,Optional.of(analyzeAction),Optional.of(archiveAction));
  Path schemeDirectory=outputDirectory.resolve("xcshareddata/xcschemes");
  projectFilesystem.mkdirs(schemeDirectory);
  Path schemePath=schemeDirectory.resolve(schemeName + ".xcscheme");
  try (ByteArrayOutputStream outputStream=new ByteArrayOutputStream()){
    serializeScheme(scheme,outputStream);
    String contentsToWrite=outputStream.toString();
    if (MorePaths.fileContentsDiffer(new ByteArrayInputStream(contentsToWrite.getBytes(Charsets.UTF_8)),schemePath,projectFilesystem)) {
      projectFilesystem.writeContentsToPath(outputStream.toString(),schemePath);
    }
  }
   return schemePath;
}
