{
  ExecutionContext executionContext=createMock(ExecutionContext.class);
  expect(executionContext.isDebugEnabled()).andReturn(false);
  FakeTestRule testRule=new FakeTestRule(ImmutableSet.<Label>of(Label.of("windows")),BuildTargetFactory.newInstance("//:lulz"),new SourcePathResolver(new BuildRuleResolver()),ImmutableSortedSet.<BuildRule>of()){
    @Override public boolean hasTestResultFiles(    ExecutionContext context){
      return true;
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=createNiceMock(TestRuleKeyFileHelper.class);
  expect(testRuleKeyFileHelper.isRuleKeyInDir(testRule)).andReturn(false);
  CachingBuildEngine cachingBuildEngine=createMock(CachingBuildEngine.class);
  BuildResult result=new BuildResult(testRule,MATCHING_RULE_KEY,CacheResult.skip());
  expect(cachingBuildEngine.getBuildRuleResult(BuildTargetFactory.newInstance("//:lulz"))).andReturn(result);
  replay(executionContext,cachingBuildEngine,testRuleKeyFileHelper);
  assertTrue("A cached build should run the tests if the test output directory\'s rule key is not " + "present or does not matche the rule key for the test.",TestRunning.isTestRunRequiredForTest(testRule,cachingBuildEngine,executionContext,testRuleKeyFileHelper,true,false));
  verify(executionContext,cachingBuildEngine,testRuleKeyFileHelper);
}
