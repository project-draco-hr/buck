{
  builder.setManifest(params.getRequiredSourcePath("manifest",builder));
  String target=params.getRequiredStringAttribute("target");
  builder.setTarget(target);
  BuildTarget keystore=params.getRequiredBuildTarget("keystore");
  builder.setKeystore(keystore);
  for (  String classpathDep : params.getOptionalListAttribute("classpath_deps")) {
    BuildTarget classpathDepTarget=params.resolveBuildTarget(classpathDep);
    builder.addClasspathDep(classpathDepTarget);
  }
  String packageType=params.getRequiredStringAttribute("package_type");
  builder.setPackageType(packageType);
  for (  String noDx : params.getOptionalListAttribute("no_dx")) {
    BuildTarget buildTarget=params.resolveBuildTarget(noDx);
    builder.addBuildRuleToExcludeFromDex(buildTarget);
  }
  boolean useSplitDex=params.getBooleanAttribute("use_split_dex");
  ZipSplitter.DexSplitStrategy dexSplitStrategy=params.getBooleanAttribute("minimize_primary_dex_size") ? ZipSplitter.DexSplitStrategy.MINIMIZE_PRIMARY_DEX_SIZE : ZipSplitter.DexSplitStrategy.MAXIMIZE_PRIMARY_DEX_SIZE;
  builder.setDisablePreDex(params.getBooleanAttribute("disable_pre_dex"));
  DexStore dexStore="xz".equals(params.getRequiredStringAttribute("dex_compression")) ? DexStore.XZ : DexStore.JAR;
  boolean useLinearAllocSplitDex=params.getBooleanAttribute("use_linear_alloc_split_dex");
  List<String> primaryDexPatterns=params.getOptionalListAttribute("primary_dex_patterns");
  long linearAllocHardLimit=params.getRequiredLongAttribute("linear_alloc_hard_limit");
  Optional<SourcePath> primaryDexClassesFile=params.getOptionalSourcePath("primary_dex_classes_file",builder);
  builder.setDexSplitMode(new DexSplitMode(useSplitDex,dexSplitStrategy,dexStore,useLinearAllocSplitDex,linearAllocHardLimit,primaryDexPatterns,primaryDexClassesFile));
  boolean useAndroidProguardConfigWithOptimizations=params.getBooleanAttribute("use_android_proguard_config_with_optimizations");
  builder.setUseAndroidProguardConfigWithOptimizations(useAndroidProguardConfigWithOptimizations);
  Optional<Integer> optimizationPasses=params.getOptionalIntegerAttribute("optimization_passes");
  builder.setOptimizationPasses(optimizationPasses);
  Optional<SourcePath> proguardConfig=params.getOptionalSourcePath("proguard_config",builder);
  builder.setProguardConfig(proguardConfig);
  Optional<String> resourceCompression=params.getOptionalStringAttribute("resource_compression");
  if (resourceCompression.isPresent()) {
    builder.setResourceCompressionMode(resourceCompression.get());
  }
  List<String> resourceFilter=params.getOptionalListAttribute("resource_filter");
  builder.setResourceFilter(new FilterResourcesStep.ResourceFilter(resourceFilter));
  List<String> cpuFilters=params.getOptionalListAttribute("cpu_filters");
  for (  String filter : cpuFilters) {
    builder.addCpuFilter(filter);
  }
  builder.setBuildStringSourceMap(params.getBooleanAttribute("build_string_source_map"));
  for (  String dep : params.getOptionalListAttribute("preprocess_java_classes_deps")) {
    BuildTarget buildTarget=params.resolveBuildTarget(dep);
    builder.addPreprocessJavaClassesDep(buildTarget);
  }
  builder.setPreprocessJavaClassesBash(params.getOptionalStringAttribute("preprocess_java_classes_bash"));
}
