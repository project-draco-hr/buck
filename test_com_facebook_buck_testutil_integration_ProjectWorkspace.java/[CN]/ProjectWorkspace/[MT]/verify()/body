{
  SimpleFileVisitor<Path> copyDirVisitor=new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      String fileName=file.getFileName().toString();
      if (fileName.endsWith(EXPECTED_SUFFIX)) {
        Path generatedFileWithSuffix=destPath.resolve(templatePath.relativize(file));
        File directory=generatedFileWithSuffix.getParent().toFile();
        File observedFile=new File(directory,Files.getNameWithoutExtension(fileName));
        if (!observedFile.isFile()) {
          fail("Expected file " + observedFile + " could not be found.");
        }
        String extension=Files.getFileExtension(observedFile.getName());
        String cleanPathToObservedFile=MoreStrings.withoutSuffix(templatePath.relativize(file).toString(),EXPECTED_SUFFIX);
switch (extension) {
case "plist":
case "stringsdict":
          NSObject expectedObject;
        try {
          expectedObject=BinaryPropertyListParser.parse(file.toFile());
        }
 catch (        Exception e) {
          expectedObject=null;
        }
      NSObject observedObject;
    try {
      observedObject=BinaryPropertyListParser.parse(observedFile);
    }
 catch (    Exception e) {
      observedObject=null;
    }
  assertTrue(String.format("In %s, expected plist to be of %s type.",cleanPathToObservedFile,(expectedObject != null) ? "binary" : "XML"),!((expectedObject != null) ^ (observedObject != null)));
if (expectedObject != null && observedObject != null) {
  assertEquals(String.format("In %s, expected binary plist contents to match.",cleanPathToObservedFile),expectedObject,observedObject);
  break;
}
 else {
  assertFileContentsEqual(file.toFile(),observedFile);
}
break;
default :
assertFileContentsEqual(file.toFile(),observedFile);
}
}
return FileVisitResult.CONTINUE;
}
}
;
java.nio.file.Files.walkFileTree(templatePath,copyDirVisitor);
}
