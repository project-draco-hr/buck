{
  Verbosity verbosity=VerbosityParser.parse(args);
  Optional<String> color;
  if (context.isPresent() && (context.get().getEnv() != null)) {
    String colorString=context.get().getEnv().getProperty(BUCKD_COLOR_DEFAULT_ENV_VAR);
    color=Optional.fromNullable(colorString);
  }
 else {
    color=Optional.absent();
  }
  BuckCommand command=new BuckCommand();
  AdditionalOptionsCmdLineParser cmdLineParser=new AdditionalOptionsCmdLineParser(command);
  try {
    cmdLineParser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    stdErr.println(e.getLocalizedMessage());
    return 1;
  }
  ImmutableMap<String,ImmutableMap<String,String>> configOverrides=command.getConfigOverrides();
  Path canonicalRootPath=projectRoot.toRealPath().normalize();
  Config rawConfig=Config.createDefaultConfig(canonicalRootPath,configOverrides);
  ProjectFilesystem filesystem=new ProjectFilesystem(canonicalRootPath,rawConfig);
  BuckConfig buckConfig=new BuckConfig(rawConfig,filesystem,architecture,platform,clientEnvironment);
  final Console console=new Console(verbosity,stdOut,stdErr,buckConfig.createAnsi(color));
  boolean commandSemaphoreAcquired=false;
  if (!command.isReadOnly()) {
    commandSemaphoreAcquired=commandSemaphore.tryAcquire();
    if (!commandSemaphoreAcquired) {
      return BUSY_EXIT_CODE;
    }
    Optional<String> currentVersion=filesystem.readFileIfItExists(BuckConstant.CURRENT_VERSION_FILE);
    if (!currentVersion.isPresent() || !currentVersion.get().equals(BuckVersion.getVersion())) {
      filesystem.deleteRecursivelyIfExists(BuckConstant.ANNOTATION_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.GEN_PATH);
      filesystem.deleteRecursivelyIfExists(BuckConstant.SCRATCH_PATH);
      filesystem.mkdirs(BuckConstant.CURRENT_VERSION_FILE.getParent());
      filesystem.writeContentsToPath(BuckVersion.getVersion(),BuckConstant.CURRENT_VERSION_FILE);
    }
  }
  PropertyFinder propertyFinder=new DefaultPropertyFinder(filesystem,clientEnvironment);
  AndroidBuckConfig androidBuckConfig=new AndroidBuckConfig(buckConfig,platform);
  AndroidDirectoryResolver androidDirectoryResolver=new DefaultAndroidDirectoryResolver(filesystem,androidBuckConfig.getNdkVersion(),propertyFinder);
  ProcessExecutor processExecutor=new ProcessExecutor(console);
  Optional<Path> testTempDirOverride=getTestTempDirOverride(buckConfig,clientEnvironment,"buck-" + buildId.toString());
  if (testTempDirOverride.isPresent()) {
    LOG.debug("Using test temp dir override %s",testTempDirOverride.get());
  }
  Clock clock;
  if (BUCKD_LAUNCH_TIME_NANOS.isPresent()) {
    long nanosEpoch=Long.parseLong(BUCKD_LAUNCH_TIME_NANOS.get(),10);
    LOG.verbose("Using nanos epoch: %d",nanosEpoch);
    clock=new NanosAdjustedClock(nanosEpoch);
  }
 else {
    clock=new DefaultClock();
  }
  ParserConfig parserConfig=new ParserConfig(buckConfig);
  Watchman watchman;
  ParserConfig.GlobHandler globHandler;
  if (context.isPresent() || parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN) {
    watchman=Watchman.build(projectRoot,clientEnvironment,console,clock);
    if (parserConfig.getGlobHandler() == ParserConfig.GlobHandler.WATCHMAN && watchman.hasWildmatchGlob()) {
      globHandler=ParserConfig.GlobHandler.WATCHMAN;
    }
 else {
      globHandler=ParserConfig.GlobHandler.PYTHON;
    }
    LOG.debug("Watchman capabilities: %s Watch root: %s Project prefix: %s Glob handler config: %s " + "Final glob handler: %s",watchman.getCapabilities(),watchman.getWatchRoot(),watchman.getProjectPrefix(),parserConfig.getGlobHandler(),globHandler);
  }
 else {
    watchman=Watchman.NULL_WATCHMAN;
    globHandler=ParserConfig.GlobHandler.PYTHON;
  }
  final boolean isDaemon=context.isPresent() && (watchman != Watchman.NULL_WATCHMAN);
  KnownBuildRuleTypesFactory factory=new KnownBuildRuleTypesFactory(processExecutor,androidDirectoryResolver,testTempDirOverride);
  Cell rootCell=new Cell(filesystem,console,watchman,buckConfig,factory,androidDirectoryResolver,clock);
  int exitCode;
  ImmutableList<BuckEventListener> eventListeners=ImmutableList.of();
  ExecutionEnvironment executionEnvironment=new DefaultExecutionEnvironment(processExecutor,clientEnvironment,System.getProperties());
  ParserConfig.AllowSymlinks allowSymlinks=parserConfig.getAllowSymlinks();
  ProjectFileHashCache cellHashCache;
  ProjectFileHashCache buckOutHashCache;
  if (isDaemon) {
    cellHashCache=getFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
    buckOutHashCache=getBuckOutFileHashCacheFromDaemon(rootCell,globHandler,allowSymlinks);
  }
 else {
    cellHashCache=new DefaultFileHashCache(rootCell.getFilesystem());
    buckOutHashCache=new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath(),Optional.of(ImmutableSet.of(BuckConstant.BUCK_OUTPUT_PATH)),ImmutableSet.<Path>of()));
  }
  ImmutableList.Builder<FileHashCache> allCaches=ImmutableList.builder();
  allCaches.add(cellHashCache);
  allCaches.add(buckOutHashCache);
  allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(rootCell.getFilesystem().getRootPath())));
  for (  Path root : FileSystems.getDefault().getRootDirectories()) {
    if (!root.toFile().exists()) {
      continue;
    }
    allCaches.add(new DefaultFileHashCache(new ProjectFilesystem(root)));
  }
  FileHashCache fileHashCache=new StackedFileHashCache(allCaches.build());
  Optional<WebServer> webServer=getWebServerIfDaemon(context,rootCell,globHandler,allowSymlinks);
  TestConfig testConfig=new TestConfig(buckConfig);
  ArtifactCacheBuckConfig cacheBuckConfig=new ArtifactCacheBuckConfig(buckConfig);
  ExecutorService diskIoExecutorService=MoreExecutors.newSingleThreadExecutor("Disk I/O");
  ListeningExecutorService httpWriteExecutorService=getHttpWriteExecutorService(cacheBuckConfig);
  VersionControlStatsGenerator vcStatsGenerator=null;
  try (ConsoleLogLevelOverrider consoleLogLevelOverrider=new ConsoleLogLevelOverrider(buildId.toString(),verbosity);ConsoleHandlerRedirector consoleHandlerRedirector=new ConsoleHandlerRedirector(buildId.toString(),console.getStdErr(),Optional.<OutputStream>of(stdErr));AbstractConsoleEventBusListener consoleListener=createConsoleEventListener(clock,console,testConfig.getResultSummaryVerbosity(),executionEnvironment,webServer);TempDirectoryCreator tempDirectoryCreator=new TempDirectoryCreator(testTempDirOverride);AsyncCloseable asyncCloseable=new AsyncCloseable(diskIoExecutorService);BuckEventBus buildEventBus=new BuckEventBus(clock,buildId)){
    ArtifactCache artifactCache=asyncCloseable.closeAsync(ArtifactCaches.newInstance(cacheBuckConfig,buildEventBus,filesystem,executionEnvironment.getWifiSsid(),httpWriteExecutorService));
    ProgressEstimator progressEstimator=new ProgressEstimator(filesystem.getRootPath(),buildEventBus);
    consoleListener.setProgressEstimator(progressEstimator);
    eventListeners=addEventListeners(buildEventBus,rootCell.getFilesystem(),buildId,rootCell.getBuckConfig(),webServer,clock,executionEnvironment,console,consoleListener,rootCell.getKnownBuildRuleTypes(),clientEnvironment);
    VersionControlBuckConfig vcBuckConfig=new VersionControlBuckConfig(buckConfig);
    if (vcBuckConfig.shouldGenerateStatistics()) {
      vcStatsGenerator=new VersionControlStatsGenerator(diskIoExecutorService,new DefaultVersionControlCmdLineInterfaceFactory(rootCell.getFilesystem().getRootPath(),new PrintStreamProcessExecutorFactory(),vcBuckConfig),buildEventBus);
      vcStatsGenerator.generateStatsAsync();
    }
    ImmutableList<String> remainingArgs=args.length > 1 ? ImmutableList.copyOf(Arrays.copyOfRange(args,1,args.length)) : ImmutableList.<String>of();
    CommandEvent.Started startedEvent=CommandEvent.started(args.length > 0 ? args[0] : "",remainingArgs,isDaemon);
    buildEventBus.post(startedEvent);
    Parser parser=null;
    if (isDaemon && watchman != Watchman.NULL_WATCHMAN) {
      try {
        Daemon daemon=getDaemon(rootCell,globHandler,allowSymlinks,objectMapper);
        WatchmanWatcher watchmanWatcher=new WatchmanWatcher(watchman.getWatchRoot().or(canonicalRootPath.toString()),daemon.getFileEventBus(),clock,objectMapper,processExecutor,filesystem.getIgnorePaths(),DEFAULT_IGNORE_GLOBS,watchman,daemon.getWatchmanQueryUUID());
        parser=getParserFromDaemon(context,rootCell,startedEvent,buildEventBus,watchmanWatcher,globHandler,allowSymlinks);
      }
 catch (      WatchmanWatcherException|IOException e) {
        buildEventBus.post(ConsoleEvent.warning("Watchman threw an exception while parsing file changes.\n%s",e.getMessage()));
      }
    }
    if (parser == null) {
      parser=Parser.createBuildFileParser(rootCell,globHandler == ParserConfig.GlobHandler.WATCHMAN,allowSymlinks);
    }
    JavaUtilsLoggingBuildListener.ensureLogFileIsWritten(rootCell.getFilesystem());
    Optional<ProcessManager> processManager;
    if (platform == Platform.WINDOWS) {
      processManager=Optional.absent();
    }
 else {
      processManager=Optional.<ProcessManager>of(new PkillProcessManager(processExecutor));
    }
    Supplier<AndroidPlatformTarget> androidPlatformTargetSupplier=createAndroidPlatformTargetSupplier(androidDirectoryResolver,androidBuckConfig,buildEventBus);
    if (command.subcommand instanceof AbstractCommand) {
      AbstractCommand subcommand=(AbstractCommand)command.subcommand;
      Optional<Path> eventsOutputPath=subcommand.getEventsOutputPath();
      if (eventsOutputPath.isPresent()) {
        BuckEventListener listener=new FileSerializationEventBusListener(eventsOutputPath.get());
        buildEventBus.register(listener);
      }
    }
    exitCode=command.run(new CommandRunnerParams(console,rootCell,androidPlatformTargetSupplier,artifactCache,buildEventBus,parser,platform,clientEnvironment,rootCell.getBuckConfig().createDefaultJavaPackageFinder(),objectMapper,clock,processManager,webServer,buckConfig,fileHashCache));
    parser.cleanCache();
    closeHttpExecutorService(cacheBuckConfig,Optional.of(buildEventBus),httpWriteExecutorService);
    buildEventBus.post(CommandEvent.finished(startedEvent,exitCode));
  }
 catch (  Throwable t) {
    LOG.debug(t,"Failing build on exception.");
    closeHttpExecutorService(cacheBuckConfig,Optional.<BuckEventBus>absent(),httpWriteExecutorService);
    closeDiskIoExecutorService(diskIoExecutorService);
    flushEventListeners(console,buildId,eventListeners);
    throw t;
  }
 finally {
    if (commandSemaphoreAcquired) {
      commandSemaphore.release();
    }
  }
  if (context.isPresent() && !rootCell.getBuckConfig().getFlushEventsBeforeExit()) {
    context.get().in.close();
    context.get().exit(exitCode);
  }
  closeDiskIoExecutorService(diskIoExecutorService);
  flushEventListeners(console,buildId,eventListeners);
  return exitCode;
}
