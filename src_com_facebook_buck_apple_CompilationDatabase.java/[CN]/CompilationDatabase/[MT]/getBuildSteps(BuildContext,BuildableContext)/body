{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  final AtomicReference<Path> internalHeaderMap=new AtomicReference<>();
  final Path headerMapPath=BuildTargets.getBinPath(getBuildTarget(),"__my_%s__.hmap");
  steps.add(new MkdirStep(headerMapPath.getParent()));
  steps.add(new AbstractExecutionStep("generate_internal_header_map"){
    @Override public int execute(    ExecutionContext context){
      if (targetSources.headerPaths.isEmpty()) {
        return 0;
      }
      HeaderMap.Builder builder=HeaderMap.builder();
      ProjectFilesystem projectFilesystem=context.getProjectFilesystem();
      for (      SourcePath headerPath : targetSources.headerPaths) {
        Path relativePath=getResolver().getPath(headerPath);
        Path absolutePath=projectFilesystem.resolve(relativePath);
        builder.add(relativePath.getFileName().toString(),absolutePath);
      }
      HeaderMap headerMap=builder.build();
      try {
        projectFilesystem.writeBytesToPath(headerMap.getBytes(),headerMapPath);
      }
 catch (      IOException e) {
        context.logError(e,"Failed to write header map: %s.",headerMapPath);
        return 1;
      }
      internalHeaderMap.set(headerMapPath);
      return 0;
    }
  }
);
  steps.add(new MkdirStep(getPathToOutputFile().getParent()));
  steps.add(new GenerateCompilationCommandsJson(internalHeaderMap));
  return steps.build();
}
