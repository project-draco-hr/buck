{
  buildContext=ImmutableBuildContext.builder().setActionGraph(actionGraph).setStepRunner(stepRunner).setProjectFilesystem(executionContext.getProjectFilesystem()).setClock(clock).setArtifactCache(artifactCache).setJavaPackageFinder(javaPackageFinder).setEventBus(executionContext.getBuckEventBus()).setAndroidBootclasspathSupplier(BuildContext.createBootclasspathSupplier(executionContext.getAndroidPlatformTargetSupplier())).setBuildDependencies(buildDependencies).setBuildId(executionContext.getBuildId()).putAllEnvironment(executionContext.getEnvironment()).build();
  ImmutableSet<BuildTarget> targetsToBuild=FluentIterable.from(targetish).transform(HasBuildTarget.TO_TARGET).toSet();
  ImmutableList<BuildRule> rulesToBuild=ImmutableList.copyOf(FluentIterable.from(targetsToBuild).transform(new Function<HasBuildTarget,BuildRule>(){
    @Override public BuildRule apply(    HasBuildTarget hasBuildTarget){
      return Preconditions.checkNotNull(actionGraph.findBuildRuleByTarget(hasBuildTarget.getBuildTarget()));
    }
  }
).toSet());
  int numRules=getNumRulesToBuild(targetsToBuild,actionGraph);
  getExecutionContext().getBuckEventBus().post(BuildEvent.ruleCountCalculated(targetsToBuild,numRules));
  final BuildContext currentBuildContext=buildContext;
  List<ListenableFuture<BuildResult>> futures=FluentIterable.from(rulesToBuild).transform(new Function<BuildRule,ListenableFuture<BuildResult>>(){
    @Override public ListenableFuture<BuildResult> apply(    BuildRule rule){
      return buildEngine.build(currentBuildContext,rule);
    }
  }
).toList();
  ListenableFuture<List<BuildResult>> buildFuture;
  if (isKeepGoing) {
    buildFuture=Futures.successfulAsList(futures);
  }
 else {
    buildFuture=Futures.allAsList(futures);
  }
  List<BuildResult> results;
  try {
    results=buildFuture.get();
  }
 catch (  InterruptedException e) {
    try {
      buildFuture.cancel(true);
    }
 catch (    CancellationException ignored) {
    }
    Thread.currentThread().interrupt();
    throw e;
  }
  LinkedHashMap<BuildRule,Optional<BuildResult>> resultBuilder=new LinkedHashMap<>();
  Preconditions.checkState(rulesToBuild.size() == results.size());
  for (int i=0, len=rulesToBuild.size(); i < len; i++) {
    BuildRule rule=rulesToBuild.get(i);
    resultBuilder.put(rule,Optional.fromNullable(results.get(i)));
  }
  return resultBuilder;
}
