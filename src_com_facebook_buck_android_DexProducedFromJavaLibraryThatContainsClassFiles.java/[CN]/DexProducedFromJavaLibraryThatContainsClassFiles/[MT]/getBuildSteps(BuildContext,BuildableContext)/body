{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  steps.add(new RmStep(getPathToDex().toString(),true));
  steps.add(new MkdirStep(getPathToDex().getParent()));
  final boolean hasClassesToDx=!javaLibrary.getClassNamesToHashes().isEmpty();
  final Supplier<Integer> linearAllocEstimate;
  if (hasClassesToDx) {
    Path pathToOutputFile=Paths.get(javaLibrary.getPathToOutputFile());
    EstimateLinearAllocStep estimate=new EstimateLinearAllocStep(pathToOutputFile);
    steps.add(estimate);
    linearAllocEstimate=estimate;
    DxStep dx=new DxStep(getPathToDex().toString(),Collections.singleton(pathToOutputFile),EnumSet.of(DxStep.Option.NO_OPTIMIZE,DxStep.Option.FORCE_JUMBO));
    steps.add(dx);
  }
 else {
    linearAllocEstimate=Suppliers.ofInstance(0);
  }
  String stepName=hasClassesToDx ? "record_dx_success" : "record_empty_dx";
  AbstractExecutionStep recordArtifactAndMetadataStep=new AbstractExecutionStep(stepName){
    @Override public int execute(    ExecutionContext context){
      if (hasClassesToDx) {
        buildableContext.recordArtifact(getPathToDex());
      }
      String abiKeyHash=getAbiKeyForDeps().getHash();
      buildableContext.addMetadata(AbiRule.ABI_KEY_FOR_DEPS_ON_DISK_METADATA,abiKeyHash);
      buildableContext.addMetadata(AbiRule.ABI_KEY_ON_DISK_METADATA,abiKeyHash);
      buildableContext.addMetadata(LINEAR_ALLOC_KEY_ON_DISK_METADATA,String.valueOf(linearAllocEstimate.get()));
      return 0;
    }
  }
;
  steps.add(recordArtifactAndMetadataStep);
  return steps.build();
}
