{
  int nodesBuilt=0;
  int targetsThatUsedTheFallbackTimeMillis=0;
  FakeThreadPool threadPool=new FakeThreadPool(numberOfThreads);
  while (nodesBuilt < reverseDependencies.size()) {
    for (    SimulationNode node : threadPool.popFinishedNodes(currentMillis)) {
      SimulateEvent.Finished finished=new SimulateEvent.Finished(node,currentMillis);
      eventBus.post(finished);
      ++nodesBuilt;
      NodeState nodeState=Preconditions.checkNotNull(reverseDependencies.get(node.getTarget()));
      for (      BuildTarget dependant : nodeState.getDependantNodes()) {
        NodeState dependantState=Preconditions.checkNotNull(reverseDependencies.get(dependant));
        dependantState.decrementRefCount();
        if (dependantState.canBuildNow()) {
          buildableNodes.add(dependant);
        }
      }
    }
    while (threadPool.hasAvailableThreads() && buildableNodes.size() > 0) {
      BuildTarget target=buildableNodes.remove();
      long expectedFinishMillis=currentMillis + times.getMillisForTarget(target.toString(),timeAggregate);
      SimulationNode node=threadPool.runTarget(expectedFinishMillis,target);
      SimulateEvent.Started started=new SimulateEvent.Started(node,currentMillis);
      eventBus.post(started);
      if (!times.hasMillisForTarget(target.toString(),timeAggregate)) {
        ++targetsThatUsedTheFallbackTimeMillis;
      }
    }
    if (threadPool.hasTargetsRunning()) {
      currentMillis=threadPool.getNextFinishingTargetMillis();
    }
  }
  report.setUsedActionGraphNodes(nodesBuilt).setBuildDurationMillis(currentMillis).setActionGraphNodesWithoutSimulateTime(targetsThatUsedTheFallbackTimeMillis);
  return report.build();
}
