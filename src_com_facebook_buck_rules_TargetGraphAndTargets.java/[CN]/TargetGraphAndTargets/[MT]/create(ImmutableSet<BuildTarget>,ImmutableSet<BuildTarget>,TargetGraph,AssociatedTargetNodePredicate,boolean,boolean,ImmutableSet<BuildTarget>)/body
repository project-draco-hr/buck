{
  ImmutableSet<TargetNode<?>> projectRoots=checkAndGetTargetNodes(graphRoots,projectGraph);
  ImmutableSet<TargetNode<?>> associatedTests=ImmutableSet.of();
  if (isWithTests) {
    AssociatedTargetNodePredicate associatedTestsPredicate=new AssociatedTargetNodePredicate(){
      @Override public boolean apply(      TargetNode<?> targetNode,      TargetGraph targetGraph){
        if (!targetNode.getType().isTestRule()) {
          return false;
        }
        ImmutableSortedSet<BuildTarget> sourceUnderTest;
        if (targetNode.getConstructorArg() instanceof HasSourceUnderTest) {
          HasSourceUnderTest argWithSourceUnderTest=(HasSourceUnderTest)targetNode.getConstructorArg();
          sourceUnderTest=argWithSourceUnderTest.getSourceUnderTest();
        }
 else {
          return false;
        }
        for (        BuildTarget buildTargetUnderTest : sourceUnderTest) {
          if (targetGraph.getOptional(buildTargetUnderTest).isPresent()) {
            return isWithDependenciesTests || graphRootsWithoutWorkspaces.contains(buildTargetUnderTest);
          }
        }
        return false;
      }
    }
;
    associatedTests=ImmutableSet.copyOf(Sets.union(ImmutableSet.copyOf(projectGraph.getAll(explicitTests)),getAssociatedTargetNodes(projectGraph,projectRoots,associatedTestsPredicate)));
  }
  ImmutableSet<TargetNode<?>> associatedProjects=getAssociatedTargetNodes(projectGraph,Iterables.concat(projectRoots,associatedTests),associatedProjectPredicate);
  TargetGraph targetGraph=projectGraph.getSubgraph(Iterables.concat(projectRoots,associatedTests,associatedProjects));
  return new TargetGraphAndTargets(targetGraph,projectRoots,associatedTests);
}
