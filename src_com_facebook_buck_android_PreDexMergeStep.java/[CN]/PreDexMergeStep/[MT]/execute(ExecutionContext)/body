{
  int primaryDexSize=0;
  List<DexWithClasses> primaryDexContents=Lists.newArrayList();
  if (dexWithClassesForRDotJava.isPresent()) {
    primaryDexSize+=dexWithClassesForRDotJava.get().getSizeEstimate();
    primaryDexContents.add(dexWithClassesForRDotJava.get());
  }
  List<List<DexWithClasses>> secondaryDexesContents=Lists.newArrayList();
  List<DexWithClasses> currentSecondaryDexContents=null;
  int currentSecondaryDexSize=0;
  for (  DexWithClasses dexWithClasses : dexFilesToMerge) {
    if (mustBeInPrimaryDex(dexWithClasses)) {
      primaryDexSize+=dexWithClasses.getSizeEstimate();
      if (primaryDexSize > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe("DexWithClasses %s with cost %s puts the linear alloc estimate for the primary dex " + "at %s, exceeding the maximum of %s.",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),primaryDexSize,linearAllocHardLimit));
        return 1;
      }
      primaryDexContents.add(dexWithClasses);
    }
 else {
      if (dexWithClasses.getSizeEstimate() > linearAllocHardLimit) {
        context.postEvent(LogEvent.severe("DexWithClasses %s with cost %s exceeds the max cost %s for a secondary dex file.",dexWithClasses.getPathToDexFile(),dexWithClasses.getSizeEstimate(),linearAllocHardLimit));
        return 1;
      }
      if (currentSecondaryDexContents == null || dexWithClasses.getSizeEstimate() + currentSecondaryDexSize > linearAllocHardLimit) {
        DexWithClasses canary;
        try {
          canary=createCanary(secondaryDexesContents.size() + 1,context);
        }
 catch (        IOException e) {
          context.logError(e,"Failed to create canary for secondary dex.");
          return 1;
        }
        currentSecondaryDexContents=Lists.newArrayList(canary);
        currentSecondaryDexSize=canary.getSizeEstimate();
        secondaryDexesContents.add(currentSecondaryDexContents);
      }
      currentSecondaryDexContents.add(dexWithClasses);
      currentSecondaryDexSize+=dexWithClasses.getSizeEstimate();
    }
  }
  List<Step> dxSteps=Lists.newArrayList();
  dxSteps.add(createDxStep(primaryDexPath,primaryDexContents));
  String pattern="secondary-%d" + dexStore.getExtension();
  Map<Integer,Path> indexToPathToSecondaryDex=Maps.newHashMap();
  for (int index=0; index < secondaryDexesContents.size(); index++) {
    String name=String.format(pattern,index + 1);
    Path pathToSecondaryDex=secondaryDexJarFilesDir.resolve(name);
    indexToPathToSecondaryDex.put(index,pathToSecondaryDex);
    List<DexWithClasses> secondaryDex=secondaryDexesContents.get(index);
    dxSteps.add(SmartDexingStep.createDxStepForDxPseudoRule(Iterables.transform(secondaryDex,TO_PATH),pathToSecondaryDex,DX_MERGE_OPTIONS));
  }
  StepRunner stepRunner=createStepRunner(context);
  try {
    stepRunner.runStepsInParallelAndWait(dxSteps);
  }
 catch (  StepFailedException e) {
    context.logError(e,"Failed when dx-merging for multi-dex.");
    return 1;
  }
 finally {
    stepRunner.getListeningExecutorService().shutdownNow();
  }
  try {
    ProjectFilesystem projectFilesystem=context.getProjectFilesystem();
    List<String> lines=Lists.newArrayListWithCapacity(secondaryDexesContents.size());
    for (int index=0; index < secondaryDexesContents.size(); index++) {
      Path pathToSecondaryDex=indexToPathToSecondaryDex.get(index);
      DexWithClasses dexWithClasses=Iterables.get(secondaryDexesContents.get(index),0);
      String containedClass=Iterables.get(dexWithClasses.getClassNames(),0);
      containedClass=containedClass.replace('/','.');
      String hash=projectFilesystem.computeSha1(pathToSecondaryDex);
      lines.add(String.format("%s %s %s",pathToSecondaryDex.getFileName(),hash,containedClass));
    }
    projectFilesystem.writeLinesToPath(lines,secondaryDexMetadataTxt);
  }
 catch (  IOException e) {
    context.logError(e,"Failed when writing metadata.txt multi-dex.");
    return 1;
  }
  return 0;
}
