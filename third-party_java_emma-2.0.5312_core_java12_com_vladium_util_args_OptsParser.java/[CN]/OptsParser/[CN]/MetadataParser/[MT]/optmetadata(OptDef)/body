{
switch (m_token.getID()) {
case Token.REQUIRED_ID:
{
      accept();
      optdef.setRequired(true);
    }
  break;
case Token.OPTIONAL_ID:
{
  accept();
  optdef.setRequired(false);
}
break;
default :
throw new IllegalArgumentException("parse error: invalid token " + m_token + ", expected "+ Token.REQUIRED+ " or "+ Token.OPTIONAL);
}
accept(Token.COMMA_ID);
if (m_token.getID() == Token.MERGEABLE_ID) {
accept();
optdef.setMergeable(true);
accept(Token.COMMA_ID);
}
if (m_token.getID() == Token.DETAILEDONLY_ID) {
accept();
optdef.setDetailedOnly(true);
accept(Token.COMMA_ID);
}
if (m_token.getID() == Token.PATTERN_ID) {
accept();
optdef.setPattern(true);
accept(Token.COMMA_ID);
}
accept(Token.VALUES_ID);
accept(Token.COLON_ID);
optdef.setValueCardinality(cardinality());
accept(Token.COMMA_ID);
if (m_token.getID() == Token.STRING_ID) {
optdef.setValueMnemonic(m_token.getValue());
accept();
accept(Token.COMMA_ID);
}
if (m_token.getID() == Token.REQUIRES_ID) {
accept();
accept(Token.LBRACKET_ID);
optdef.setRequiresSet(namelist());
accept(Token.RBRACKET_ID);
accept(Token.COMMA_ID);
}
if (m_token.getID() == Token.EXCLUDES_ID) {
accept();
accept(Token.LBRACKET_ID);
optdef.setExcludesSet(namelist());
accept(Token.RBRACKET_ID);
accept(Token.COMMA_ID);
}
optdef.setDescription(accept(Token.TEXT_ID).getValue());
}
