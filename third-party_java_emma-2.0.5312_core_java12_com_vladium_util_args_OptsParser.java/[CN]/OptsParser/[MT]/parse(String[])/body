{
  if (args == null)   throw new IllegalArgumentException("null input: args");
  final Opts opts=new Opts();
{
    final String[] nv=new String[2];
    final String[] pp=new String[1];
    int state=STATE_OPT;
    OptDef optdef=null;
    Opt opt=null;
    String value=null;
    int valueCount=0;
    int a;
    scan:     for (a=0; a < args.length; ) {
      final String av=args[a];
      if (av == null)       throw new IllegalArgumentException("null input: args[" + a + "]");
switch (state) {
case STATE_OPT:
{
          if (isOpt(av,valueCount,optdef)) {
            valueCount=0;
            getOptNameAndValue(av,nv);
            final String optName=nv[0];
            optdef=m_metadata.getOptDef(optName,pp);
            if (optdef == null) {
              opts.addError(formatMessage("unknown option \'" + optName + "\'"));
              state=STATE_ERROR;
            }
 else {
              final String canonicalName=getOptCanonicalName(optName,optdef);
              final String patternPrefix=pp[0];
              opt=opts.getOpt(canonicalName);
              if (optdef.isMergeable()) {
                if (opt == null) {
                  opt=new Opt(optName,canonicalName,patternPrefix);
                  opts.addOpt(opt,optdef,optName);
                }
              }
 else {
                if (opt == null) {
                  opt=new Opt(optName,canonicalName,patternPrefix);
                  opts.addOpt(opt,optdef,optName);
                }
 else {
                  opts.addError(formatMessage("option \'" + optName + "\' cannot be specified more than once"));
                  state=STATE_ERROR;
                }
              }
              value=nv[1];
              if (value == null)               ++a;
              state=STATE_OPT_VALUE;
            }
          }
 else {
            state=STATE_FREE_ARGS;
          }
        }
      break;
case STATE_OPT_VALUE:
{
      if (value != null) {
        valueCount=1;
        final int[] cardinality=optdef.getValueCardinality();
        if (cardinality[1] < 1) {
          opts.addError(formatMessage("option \'" + opt.getName() + "\' does not accept values: \'"+ value+ "\'"));
          state=STATE_ERROR;
        }
 else {
          ++a;
          opt.addValue(value);
        }
      }
 else {
        value=args[a];
        final int[] cardinality=optdef.getValueCardinality();
        if (isOpt(value,valueCount,optdef)) {
          if (valueCount < cardinality[0]) {
            opts.addError(formatMessage("option \'" + opt.getName() + "\' does not accept fewer than "+ cardinality[0]+ " value(s)"));
            state=STATE_ERROR;
          }
 else           state=STATE_OPT;
        }
 else {
          if (valueCount < cardinality[1]) {
            ++valueCount;
            ++a;
            opt.addValue(value);
          }
 else {
            state=STATE_FREE_ARGS;
          }
        }
      }
      value=null;
    }
  break;
case STATE_FREE_ARGS:
{
  if (isOpt(args[a],valueCount,optdef)) {
    state=STATE_OPT;
  }
 else {
    opts.setFreeArgs(args,a);
    break scan;
  }
}
break;
case STATE_ERROR:
{
break scan;
}
}
}
if (a == args.length) {
if (opt != null) {
final int[] cardinality=optdef.getValueCardinality();
if (valueCount < cardinality[0]) {
opts.addError(formatMessage("option \'" + opt.getName() + "\' does not accept fewer than "+ cardinality[0]+ " value(s)"));
}
}
 else {
opts.setFreeArgs(args,a);
}
}
}
final IOpt[] specified=opts.getOpts();
if (specified != null) {
final Set required=new HashSet();
required.addAll(m_metadata.getRequiredOpts());
for (int s=0; s < specified.length; ++s) {
required.remove(specified[s].getCanonicalName());
}
if (!required.isEmpty()) {
for (Iterator i=required.iterator(); i.hasNext(); ) {
opts.addError(formatMessage("missing required option \'" + (String)i.next() + "\'"));
}
}
for (int s=0; s < specified.length; ++s) {
final IOpt opt=specified[s];
final OptDef optdef=m_metadata.getOptDef(opt.getCanonicalName(),null);
final String[] requires=optdef.getRequiresSet();
if (requires != null) {
for (int r=0; r < requires.length; ++r) {
if (opts.getOpt(requires[r]) == null) opts.addError(formatMessage("option \'" + opt.getName() + "\' requires option \'"+ requires[r]+ "\'"));
}
}
final String[] excludes=optdef.getExcludesSet();
if (excludes != null) {
for (int x=0; x < excludes.length; ++x) {
final Opt xopt=opts.getOpt(excludes[x]);
if (xopt != null) opts.addError(formatMessage("option \'" + opt.getName() + "\' cannot be used with option \'"+ xopt.getName()+ "\'"));
}
}
if (optdef.isUsage()) {
opts.setUsageRequested(opt.getName().equals(opt.getCanonicalName()) ? SHORT_USAGE : DETAILED_USAGE);
}
}
}
return opts;
}
