{
  if (context.getBuildDependencies() != BuildDependencies.WARN_ON_TRANSITIVE) {
    return Optional.absent();
  }
  final Set<JavaLibrary> transitiveNotDeclaredDeps=Sets.difference(transitiveClasspathEntries.keySet(),Sets.union(ImmutableSet.of(this),declaredClasspathEntries.keySet()));
  TraversableGraph<BuildRule> graph=context.getActionGraph();
  final ImmutableList<JavaLibrary> sortedTransitiveNotDeclaredDeps=FluentIterable.from(TopologicalSort.sort(graph,Predicates.<BuildRule>alwaysTrue())).filter(JavaLibrary.class).filter(Predicates.in(transitiveNotDeclaredDeps)).toList().reverse();
  JavacInMemoryStep.SuggestBuildRules suggestBuildRuleFn=new JavacInMemoryStep.SuggestBuildRules(){
    @Override public ImmutableSet<String> suggest(    ProjectFilesystem filesystem,    ImmutableSet<String> failedImports){
      ImmutableSet.Builder<String> suggestedDeps=ImmutableSet.builder();
      Set<String> remainingImports=Sets.newHashSet(failedImports);
      for (      JavaLibrary transitiveNotDeclaredDep : sortedTransitiveNotDeclaredDeps) {
        if (isMissingBuildRule(filesystem,transitiveNotDeclaredDep,remainingImports,jarResolver)) {
          suggestedDeps.add(transitiveNotDeclaredDep.getFullyQualifiedName());
        }
        if (remainingImports.isEmpty()) {
          break;
        }
      }
      return suggestedDeps.build();
    }
  }
;
  return Optional.of(suggestBuildRuleFn);
}
