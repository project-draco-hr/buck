{
  float count=0;
  long initialMillis=nowMillis - timeRangeMillis;
synchronized (errors) {
    ListIterator<Long> iterator=errors.listIterator(errors.size());
    while (iterator.hasPrevious()) {
      long errorMillis=iterator.previous();
      if (errorMillis >= initialMillis && errorMillis <= nowMillis) {
        ++count;
      }
    }
  }
  return count / timeRangeMillis;
}
