{
  ImmutableSet.Builder<DexProducedFromJavaLibrary> preDexDeps=ImmutableSet.builder();
  preDexDeps.addAll(preDexRulesNotInThePackageableCollection);
  for (  BuildTarget buildTarget : packageableCollection.getJavaLibrariesToDex()) {
    Preconditions.checkState(!buildTargetsToExcludeFromDex.contains(buildTarget),"JavaLibrary should have been excluded from target to dex: %s",buildTarget);
    BuildRule libraryRule=ruleResolver.getRule(buildTarget);
    if (libraryRule.equals(aaptPackageResources)) {
      continue;
    }
    Preconditions.checkState(libraryRule instanceof JavaLibrary);
    JavaLibrary javaLibrary=(JavaLibrary)libraryRule;
    if (javaLibrary.getPathToOutputFile() == null) {
      continue;
    }
    BuildTarget originalTarget=javaLibrary.getBuildTarget();
    BuildTarget preDexTarget=BuildTarget.builder(originalTarget).addFlavors(DEX_FLAVOR).build();
    Optional<BuildRule> preDexRule=ruleResolver.getRuleOptional(preDexTarget);
    if (preDexRule.isPresent()) {
      preDexDeps.add((DexProducedFromJavaLibrary)preDexRule.get());
      continue;
    }
    BuildRuleParams paramsForPreDex=buildRuleParams.copyWithChanges(BuildRuleType.PRE_DEX,preDexTarget,ImmutableSortedSet.of(ruleResolver.getRule(javaLibrary.getBuildTarget())),ImmutableSortedSet.<BuildRule>of());
    DexProducedFromJavaLibrary preDex=new DexProducedFromJavaLibrary(paramsForPreDex,pathResolver,javaLibrary);
    ruleResolver.addToIndex(preDex);
    preDexDeps.add(preDex);
  }
  ImmutableSet<DexProducedFromJavaLibrary> allPreDexDeps=preDexDeps.build();
  BuildRuleParams paramsForPreDexMerge=buildRuleParams.copyWithChanges(BuildRuleType.DEX_MERGE,createBuildTargetWithFlavor(DEX_MERGE_FLAVOR),getDexMergeDeps(aaptPackageResources,allPreDexDeps),ImmutableSortedSet.<BuildRule>of());
  PreDexMerge preDexMerge=new PreDexMerge(paramsForPreDexMerge,pathResolver,primaryDexPath,dexSplitMode,allPreDexDeps,aaptPackageResources);
  ruleResolver.addToIndex(preDexMerge);
  return preDexMerge;
}
