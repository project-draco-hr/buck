{
  ClasspathTraverser classpathTraverser=new DefaultClasspathTraverser();
  primaryOut=newZipOutput(outPrimary);
  secondaryDexWriter.reset();
  final ImmutableMap.Builder<String,FileLike> entriesBuilder=ImmutableMap.builder();
  classpathTraverser.traverse(new ClasspathTraversal(inFiles,filesystem){
    @Override public void visit(    FileLike entry) throws IOException {
      String relativePath=entry.getRelativePath();
      Preconditions.checkNotNull(primaryOut);
      if (requiredInPrimaryZip.apply(relativePath)) {
        primaryOut.putEntry(entry);
      }
 else       if (wantedInPrimaryZip.contains(relativePath)) {
        entriesBuilder.put(relativePath,new BufferedFileLike(entry));
      }
    }
  }
);
  ImmutableMap<String,FileLike> entries=entriesBuilder.build();
  for (  String wanted : wantedInPrimaryZip) {
    FileLike entry=entries.get(wanted);
    if ((entry != null) && !primaryOut.containsEntry(entry) && primaryOut.canPutEntry(entry)) {
      primaryOut.putEntry(entry);
    }
  }
  classpathTraverser.traverse(new ClasspathTraversal(inFiles,filesystem){
    @Override public void visit(    FileLike entry) throws IOException {
      Preconditions.checkNotNull(primaryOut);
      if (primaryOut.containsEntry(entry)) {
        return;
      }
      if (dexSplitStrategy == DexSplitStrategy.MAXIMIZE_PRIMARY_DEX_SIZE && primaryOut.canPutEntry(entry)) {
        primaryOut.putEntry(entry);
      }
 else {
        secondaryDexWriter.getOutputToWriteTo(entry).putEntry(entry);
      }
    }
  }
);
  primaryOut.close();
  secondaryDexWriter.close();
  return secondaryDexWriter.getFiles();
}
