{
  final Set<BuildTarget> rulesWithAutodeps=new HashSet<>();
  final HashMultimap<BuildTarget,String> ruleToRequiredSymbols=HashMultimap.create();
  final HashMultimap<BuildTarget,String> ruleToExportedSymbols=HashMultimap.create();
  final HashMultimap<String,BuildTarget> symbolToProviders=HashMultimap.create();
  final HashMultimap<BuildTarget,BuildTarget> rulesWithAutodepsToProvidedDeps=HashMultimap.create();
  final HashMultimap<BuildTarget,BuildTarget> ruleToRulesThatExportIt=HashMultimap.create();
  new AbstractBottomUpTraversal<TargetNode<?>,Void>(graph){
    @Override public void visit(    TargetNode<?> node){
      BuildRuleType buildRuleType=node.getDescription().getBuildRuleType();
      if (!RULES_TO_VISIT.contains(buildRuleType)) {
        return;
      }
      boolean autodeps;
      ImmutableSortedSet<BuildTarget> providedDeps;
      ImmutableSortedSet<BuildTarget> exportedDeps;
      if (node.getConstructorArg() instanceof JavaLibraryDescription.Arg) {
        JavaLibraryDescription.Arg arg=(JavaLibraryDescription.Arg)node.getConstructorArg();
        autodeps=arg.autodeps.or(false);
        providedDeps=arg.providedDeps.or(ImmutableSortedSet.<BuildTarget>of());
        exportedDeps=arg.exportedDeps.or(ImmutableSortedSet.<BuildTarget>of());
      }
 else       if (node.getConstructorArg() instanceof PrebuiltJarDescription.Arg) {
        autodeps=false;
        providedDeps=ImmutableSortedSet.of();
        exportedDeps=ImmutableSortedSet.of();
      }
 else {
        throw new IllegalStateException("This rule is not supported by autodeps: " + node);
      }
      BuildTarget buildTarget=node.getBuildTarget();
      if (autodeps) {
        rulesWithAutodeps.add(buildTarget);
        rulesWithAutodepsToProvidedDeps.putAll(buildTarget,providedDeps);
      }
      for (      BuildTarget exportedDep : exportedDeps) {
        ruleToRulesThatExportIt.put(exportedDep,buildTarget);
      }
      Symbols symbols=getJavaFileFeatures(node,autodeps);
      if (autodeps) {
        ruleToRequiredSymbols.putAll(buildTarget,symbols.required);
        ruleToExportedSymbols.putAll(buildTarget,symbols.exported);
      }
      for (      String providedEntity : symbols.provided) {
        symbolToProviders.put(providedEntity,buildTarget);
      }
    }
  }
.traverse();
  DepsForBuildFiles depsForBuildFiles=new DepsForBuildFiles();
  for (  final BuildTarget buildTarget : rulesWithAutodeps) {
    final Set<BuildTarget> providedDeps=rulesWithAutodepsToProvidedDeps.get(buildTarget);
    final Predicate<BuildTarget> isVisibleDepNotAlreadyInProvidedDeps=new Predicate<BuildTarget>(){
      @Override public boolean apply(      BuildTarget provider){
        TargetNode<?> node=graph.get(provider);
        return node.isVisibleTo(buildTarget) && !providedDeps.contains(provider);
      }
    }
;
    final boolean isJavaTestRule=graph.get(buildTarget).getType() == JavaTestDescription.TYPE;
    for (    DependencyType type : DependencyType.values()) {
      HashMultimap<BuildTarget,String> ruleToSymbolsMap;
switch (type) {
case DEPS:
        ruleToSymbolsMap=ruleToRequiredSymbols;
      break;
case EXPORTED_DEPS:
    ruleToSymbolsMap=ruleToExportedSymbols;
  break;
default :
throw new IllegalStateException("Unrecognized type: " + type);
}
final DependencyType typeOfDepToAdd;
if (isJavaTestRule) {
typeOfDepToAdd=DependencyType.DEPS;
}
 else {
typeOfDepToAdd=type;
}
for (String requiredSymbol : ruleToSymbolsMap.get(buildTarget)) {
BuildTarget provider=findProviderForSymbolFromBuckConfig(requiredSymbol);
if (provider != null) {
depsForBuildFiles.addDep(buildTarget,provider,typeOfDepToAdd);
continue;
}
Set<BuildTarget> providers=symbolToProviders.get(requiredSymbol);
SortedSet<BuildTarget> candidateProviders=FluentIterable.from(providers).filter(isVisibleDepNotAlreadyInProvidedDeps).toSortedSet(Ordering.<BuildTarget>natural());
int numCandidates=candidateProviders.size();
if (numCandidates == 1) {
depsForBuildFiles.addDep(buildTarget,Iterables.getOnlyElement(candidateProviders),typeOfDepToAdd);
}
 else if (numCandidates > 1) {
console.printErrorText(String.format("WARNING: Multiple providers for %s: %s. " + "Consider adding entry to .buckconfig to eliminate ambiguity:\n" + "[autodeps]\n"+ "java-package-mappings = %s => %s",requiredSymbol,Joiner.on(", ").join(candidateProviders),requiredSymbol,Iterables.getFirst(candidateProviders,null)));
}
 else {
SortedSet<BuildTarget> newCandidates=new TreeSet<>();
for (BuildTarget candidate : providers) {
  Set<BuildTarget> rulesThatExportCandidate=ruleToRulesThatExportIt.get(candidate);
  for (  BuildTarget ruleThatExportsCandidate : rulesThatExportCandidate) {
    TargetNode<?> node=graph.get(ruleThatExportsCandidate);
    if (node.isVisibleTo(buildTarget)) {
      newCandidates.add(ruleThatExportsCandidate);
    }
  }
}
int numNewCandidates=newCandidates.size();
if (numNewCandidates == 1) {
  depsForBuildFiles.addDep(buildTarget,Iterables.getOnlyElement(newCandidates),typeOfDepToAdd);
}
 else if (numNewCandidates > 1) {
  console.printErrorText(String.format("WARNING: No providers found for '%s' for build rule %s, " + "but there are multiple rules that export a rule to provide %s: %s",requiredSymbol,buildTarget,requiredSymbol,Joiner.on(", ").join(newCandidates)));
}
}
}
}
}
return depsForBuildFiles;
}
