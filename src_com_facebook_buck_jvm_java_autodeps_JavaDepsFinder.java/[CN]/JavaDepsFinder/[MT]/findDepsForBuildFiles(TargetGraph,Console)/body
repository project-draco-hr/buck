{
  final Set<TargetNode<?>> rulesWithAutodeps=new HashSet<>();
  final HashMultimap<TargetNode<?>,String> ruleToRequiredSymbols=HashMultimap.create();
  final HashMultimap<TargetNode<?>,String> ruleToExportedSymbols=HashMultimap.create();
  final HashMultimap<String,TargetNode<?>> symbolToProviders=HashMultimap.create();
  final HashMultimap<TargetNode<?>,BuildTarget> rulesWithAutodepsToProvidedDeps=HashMultimap.create();
  final HashMultimap<TargetNode<?>,TargetNode<?>> ruleToRulesThatExportIt=HashMultimap.create();
  new AbstractBottomUpTraversal<TargetNode<?>,Void>(graph){
    @Override public void visit(    TargetNode<?> node){
      BuildRuleType buildRuleType=node.getDescription().getBuildRuleType();
      if (!RULES_TO_VISIT.contains(buildRuleType)) {
        return;
      }
      boolean autodeps;
      ImmutableSortedSet<BuildTarget> providedDeps;
      ImmutableSortedSet<BuildTarget> exportedDeps;
      if (node.getConstructorArg() instanceof JavaLibraryDescription.Arg) {
        JavaLibraryDescription.Arg arg=(JavaLibraryDescription.Arg)node.getConstructorArg();
        autodeps=arg.autodeps.or(false);
        providedDeps=arg.providedDeps.or(ImmutableSortedSet.<BuildTarget>of());
        exportedDeps=arg.exportedDeps.or(ImmutableSortedSet.<BuildTarget>of());
      }
 else       if (node.getConstructorArg() instanceof PrebuiltJarDescription.Arg) {
        autodeps=false;
        providedDeps=ImmutableSortedSet.of();
        exportedDeps=ImmutableSortedSet.of();
      }
 else {
        throw new IllegalStateException("This rule is not supported by autodeps: " + node);
      }
      if (autodeps) {
        rulesWithAutodeps.add(node);
        rulesWithAutodepsToProvidedDeps.putAll(node,providedDeps);
      }
      for (      BuildTarget exportedDep : exportedDeps) {
        ruleToRulesThatExportIt.put(graph.get(exportedDep),node);
      }
      Symbols symbols=getJavaFileFeatures(node,autodeps);
      if (autodeps) {
        ruleToRequiredSymbols.putAll(node,symbols.required);
        ruleToExportedSymbols.putAll(node,symbols.exported);
      }
      for (      String providedEntity : symbols.provided) {
        symbolToProviders.put(providedEntity,node);
      }
    }
  }
.traverse();
  DepsForBuildFiles depsForBuildFiles=new DepsForBuildFiles();
  for (  final TargetNode<?> rule : rulesWithAutodeps) {
    final Set<BuildTarget> providedDeps=rulesWithAutodepsToProvidedDeps.get(rule);
    final Predicate<TargetNode<?>> isVisibleDepNotAlreadyInProvidedDeps=new Predicate<TargetNode<?>>(){
      @Override public boolean apply(      TargetNode<?> provider){
        return provider.isVisibleTo(rule.getBuildTarget()) && !providedDeps.contains(provider.getBuildTarget());
      }
    }
;
    final boolean isJavaTestRule=rule.getType() == JavaTestDescription.TYPE;
    for (    DependencyType type : DependencyType.values()) {
      HashMultimap<TargetNode<?>,String> ruleToSymbolsMap;
switch (type) {
case DEPS:
        ruleToSymbolsMap=ruleToRequiredSymbols;
      break;
case EXPORTED_DEPS:
    ruleToSymbolsMap=ruleToExportedSymbols;
  break;
default :
throw new IllegalStateException("Unrecognized type: " + type);
}
final DependencyType typeOfDepToAdd;
if (isJavaTestRule) {
typeOfDepToAdd=DependencyType.DEPS;
}
 else {
typeOfDepToAdd=type;
}
for (String requiredSymbol : ruleToSymbolsMap.get(rule)) {
BuildTarget provider=findProviderForSymbolFromBuckConfig(requiredSymbol);
if (provider != null) {
depsForBuildFiles.addDep(rule.getBuildTarget(),provider,typeOfDepToAdd);
continue;
}
Set<TargetNode<?>> providers=symbolToProviders.get(requiredSymbol);
SortedSet<TargetNode<?>> candidateProviders=FluentIterable.from(providers).filter(isVisibleDepNotAlreadyInProvidedDeps).toSortedSet(Ordering.<TargetNode<?>>natural());
int numCandidates=candidateProviders.size();
if (numCandidates == 1) {
depsForBuildFiles.addDep(rule.getBuildTarget(),Iterables.getOnlyElement(candidateProviders).getBuildTarget(),typeOfDepToAdd);
}
 else if (numCandidates > 1) {
console.printErrorText(String.format("WARNING: Multiple providers for %s: %s. " + "Consider adding entry to .buckconfig to eliminate ambiguity:\n" + "[autodeps]\n"+ "java-package-mappings = %s => %s",requiredSymbol,Joiner.on(", ").join(candidateProviders),requiredSymbol,Iterables.getFirst(candidateProviders,null)));
}
 else {
SortedSet<TargetNode<?>> newCandidates=new TreeSet<>();
for (TargetNode<?> candidate : providers) {
  Set<TargetNode<?>> rulesThatExportCandidate=ruleToRulesThatExportIt.get(candidate);
  for (  TargetNode<?> ruleThatExportsCandidate : rulesThatExportCandidate) {
    if (ruleThatExportsCandidate.isVisibleTo(rule.getBuildTarget())) {
      newCandidates.add(ruleThatExportsCandidate);
    }
  }
}
int numNewCandidates=newCandidates.size();
if (numNewCandidates == 1) {
  depsForBuildFiles.addDep(rule.getBuildTarget(),Iterables.getOnlyElement(newCandidates).getBuildTarget(),typeOfDepToAdd);
}
 else if (numNewCandidates > 1) {
  console.printErrorText(String.format("WARNING: No providers found for '%s' for build rule %s, " + "but there are multiple rules that export a rule to provide %s: %s",requiredSymbol,rule.getBuildTarget(),requiredSymbol,Joiner.on(", ").join(newCandidates)));
}
}
}
}
}
return depsForBuildFiles;
}
