{
  CxxPreprocessorInput cxxPreprocessorInputFromDeps;
  try {
    cxxPreprocessorInputFromDeps=CxxPreprocessables.getTransitiveCxxPreprocessorInput(ocamlBuckConfig.getCxxPlatform(),FluentIterable.from(params.getDeps()).filter(Predicates.instanceOf(CxxPreprocessorDep.class)));
  }
 catch (  CxxPreprocessorInput.ConflictingHeadersException e) {
    throw e.getHumanReadableExceptionForBuildTarget(params.getBuildTarget());
  }
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  ImmutableList<String> includes=FluentIterable.from(params.getDeps()).transformAndConcat(getLibInclude(false)).toList();
  ImmutableList<String> bytecodeIncludes=FluentIterable.from(params.getDeps()).transformAndConcat(getLibInclude(true)).toList();
  final FluentIterable<SourcePath> srcSourcePaths=FluentIterable.from(srcs).transform(OCamlSource.TO_SOURCE_PATH);
  final FluentIterable<Path> srcPaths=srcSourcePaths.transform(pathResolver.getPathFunction());
  NativeLinkableInput linkableInput=NativeLinkables.getTransitiveNativeLinkableInput(ocamlBuckConfig.getCxxPlatform(),params.getDeps(),Linker.LinkableDepType.STATIC,false);
  ImmutableList<OCamlLibrary> ocamlInput=OCamlUtil.getTransitiveOCamlInput(params.getDeps());
  ImmutableList<SourcePath> allInputs=ImmutableList.<SourcePath>builder().addAll(getInput(srcs)).addAll(linkableInput.getInputs()).build();
  BuildTarget buildTarget=isLibrary ? createStaticLibraryBuildTarget(params.getBuildTarget()) : createOCamlLinkTarget(params.getBuildTarget());
  final BuildRuleParams compileParams=params.copyWithChanges(NativeLinkable.NATIVE_LINKABLE_TYPE,buildTarget,Suppliers.ofInstance(ImmutableSortedSet.copyOf(pathResolver.filterBuildRuleInputs(allInputs))),Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of()));
  ImmutableList.Builder<String> flagsBuilder=ImmutableList.builder();
  flagsBuilder.addAll(argFlags);
  final OCamlBuildContext ocamlContext=OCamlBuildContext.builder(ocamlBuckConfig).setFlags(flagsBuilder.build()).setIncludes(includes).setBytecodeIncludes(bytecodeIncludes).setOCamlInput(ocamlInput).setLinkableInput(linkableInput).setBuildTarget(buildTarget).setLibrary(isLibrary).setCxxPreprocessorInput(cxxPreprocessorInputFromDeps).setInput(pathResolver.getAllPaths(getInput(srcs))).build();
  File baseDir=params.getProjectFilesystem().getRootPath().toAbsolutePath().toFile();
  ImmutableMap<Path,ImmutableList<Path>> mlInput=getMLInputWithDeps(baseDir,ocamlContext);
  ImmutableList<SourcePath> cInput=getCInput(pathResolver,getInput(srcs));
  OCamlBuildRulesGenerator generator=new OCamlBuildRulesGenerator(compileParams,pathResolver,resolver,ocamlContext,mlInput,cInput,ocamlBuckConfig.getCCompiler(),ocamlBuckConfig.getCxxCompiler());
  ImmutableList<BuildRule> ocamlLibraryBuild=generator.generate();
  if (isLibrary) {
    return new OCamlStaticLibrary(params.copyWithDeps(Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>naturalOrder().addAll(params.getDeclaredDeps()).addAll(ocamlLibraryBuild).build()),Suppliers.ofInstance(params.getExtraDeps())),pathResolver,compileParams,linkerFlags,srcPaths,ocamlContext,ocamlLibraryBuild.get(0));
  }
 else {
    return new OCamlBinary(params.copyWithDeps(Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>naturalOrder().addAll(params.getDeclaredDeps()).addAll(ocamlLibraryBuild).build()),Suppliers.ofInstance(params.getExtraDeps())),pathResolver,Preconditions.checkNotNull(ocamlLibraryBuild.get(0).getPathToOutputFile()));
  }
}
