{
  if (!doStore) {
    return Futures.immediateFuture(null);
  }
  try {
    for (    RuleKey ruleKey : ruleKeys) {
      Path artifactPath=getPathForRuleKey(ruleKey,Optional.<String>absent());
      Path metadataPath=getPathForRuleKey(ruleKey,Optional.of(".metadata"));
      if (filesystem.exists(artifactPath) && filesystem.exists(metadataPath)) {
        continue;
      }
      filesystem.mkdirs(getParentDirForRuleKey(ruleKey));
      Path tmp=filesystem.createTempFile(cacheDir,"artifact",".tmp");
      try {
        filesystem.copyFile(output,tmp);
        filesystem.move(tmp,artifactPath,StandardCopyOption.REPLACE_EXISTING);
        bytesSinceLastDeleteOldFiles+=filesystem.getFileSize(artifactPath);
      }
  finally {
        filesystem.deleteFileAtPathIfExists(tmp);
      }
      tmp=filesystem.createTempFile(cacheDir,"metadata",".tmp");
      try {
        try (DataOutputStream out=new DataOutputStream(filesystem.newFileOutputStream(tmp))){
          out.writeInt(metadata.size());
          for (          Map.Entry<String,String> ent : metadata.entrySet()) {
            out.writeUTF(ent.getKey());
            byte[] val=ent.getValue().getBytes(Charsets.UTF_8);
            out.writeInt(val.length);
            out.write(val);
          }
        }
         filesystem.move(tmp,metadataPath,StandardCopyOption.REPLACE_EXISTING);
        bytesSinceLastDeleteOldFiles+=filesystem.getFileSize(metadataPath);
      }
  finally {
        filesystem.deleteFileAtPathIfExists(tmp);
      }
    }
  }
 catch (  IOException e) {
    LOG.warn(e,"Artifact store(%s, %s) error",ruleKeys,output);
  }
  if (maxCacheSizeBytes.isPresent() && bytesSinceLastDeleteOldFiles > (maxCacheSizeBytes.get() * STORED_TO_MAX_BYTES_RATIO_TRIM_TRIGGER)) {
    bytesSinceLastDeleteOldFiles=0L;
    deleteOldFiles();
  }
  return Futures.immediateFuture(null);
}
