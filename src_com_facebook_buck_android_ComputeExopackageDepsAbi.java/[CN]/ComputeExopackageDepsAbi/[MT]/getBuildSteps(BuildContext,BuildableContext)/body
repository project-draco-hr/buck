{
  return ImmutableList.<Step>of(new AbstractExecutionStep("compute_android_binary_deps_abi"){
    @Override public int execute(    ExecutionContext context){
      try {
        final Hasher hasher=Hashing.sha1().newHasher();
        String resourceApkHash=aaptPackageResources.getResourcePackageHash().toString();
        LOG.verbose("resource apk = %s",resourceApkHash);
        hasher.putUnencodedChars(resourceApkHash);
        String primaryDexHash=Preconditions.checkNotNull(preDexMerge.get().getPrimaryDexHash()).toString();
        LOG.verbose("primary dex = %s",primaryDexHash);
        hasher.putUnencodedChars(primaryDexHash);
        if (packageStringAssets.isPresent()) {
          String stringAssetsHash=packageStringAssets.get().getStringAssetsZipHash().toString();
          LOG.verbose("string assets = %s",stringAssetsHash);
          hasher.putUnencodedChars(stringAssetsHash);
        }
        ImmutableSortedMap.Builder<Path,String> filesToHash=ImmutableSortedMap.naturalOrder();
        if (!ExopackageMode.enabledForSecondaryDexes(exopackageModes) && preDexMerge.isPresent()) {
          filesToHash.put(preDexMerge.get().getMetadataTxtPath(),"secondary_dexes");
        }
        if (!ExopackageMode.enabledForNativeLibraries(exopackageModes) && copyNativeLibraries.isPresent()) {
          filesToHash.put(copyNativeLibraries.get().getPathToMetadataTxt(),"native_libs");
        }
        if (ExopackageMode.enabledForNativeLibraries(exopackageModes)) {
          String fakeNativeLibraryBundle=System.getProperty("buck.native_exopackage_fake_path");
          Preconditions.checkNotNull(fakeNativeLibraryBundle,"fake native bundle not specified in properties.");
          filesToHash.put(Paths.get(fakeNativeLibraryBundle),"fake_native_libs");
        }
        for (        SourcePath libDir : packageableCollection.getNativeLibAssetsDirectories()) {
          for (          Path nativeFile : getProjectFilesystem().getFilesUnderPath(getResolver().getPath(libDir))) {
            filesToHash.put(nativeFile,"native_lib_as_asset");
          }
        }
        for (        SourcePath jar : packageableCollection.getPathsToThirdPartyJars()) {
          filesToHash.put(getResolver().getPath(jar),"third-party jar");
        }
        filesToHash.put(keystore.getPathToStore(),"keystore");
        filesToHash.put(keystore.getPathToPropertiesFile(),"keystore properties");
        for (        Map.Entry<Path,String> entry : filesToHash.build().entrySet()) {
          Path path=entry.getKey();
          hasher.putUnencodedChars(path.toString());
          hasher.putByte((byte)0);
          String fileSha1=getProjectFilesystem().computeSha1(path);
          hasher.putUnencodedChars(fileSha1);
          hasher.putByte((byte)0);
          hasher.putUnencodedChars(entry.getValue());
          hasher.putByte((byte)0);
          LOG.verbose("file %s(%s) = %s",path,entry.getValue(),fileSha1);
        }
        String abiHash=hasher.hash().toString();
        LOG.verbose("ABI hash = %s",abiHash);
        buildableContext.addMetadata(METADATA_KEY,abiHash);
        return 0;
      }
 catch (      IOException e) {
        context.logError(e,"Error computing ABI hash.");
        return 1;
      }
    }
  }
);
}
