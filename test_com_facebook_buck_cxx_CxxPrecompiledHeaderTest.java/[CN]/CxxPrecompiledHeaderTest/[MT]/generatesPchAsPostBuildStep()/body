{
  BuildTarget target=BuildTargetFactory.newInstance("//foo:bar");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).build();
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new DefaultTargetNodeToBuildRuleTransformer());
  Preprocessor preprocessorSupportingPch=new DefaultPreprocessor(CxxPlatformUtils.DEFAULT_PLATFORM.getCpp().resolve(resolver)){
    @Override public boolean supportsPrecompiledHeaders(){
      return true;
    }
  }
;
  SourcePathResolver sourcePathResolver=new SourcePathResolver(resolver);
  CxxPrecompiledHeader precompiledHeader=new CxxPrecompiledHeader(params,sourcePathResolver,Paths.get("foo.pch"),new PreprocessorDelegate(sourcePathResolver,CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER,Paths.get("./"),preprocessorSupportingPch,PreprocessorFlags.builder().build(),CxxDescriptionEnhancer.frameworkPathToSearchPath(CxxPlatformUtils.DEFAULT_PLATFORM,sourcePathResolver),ImmutableList.<CxxHeaders>of()),new FakeSourcePath("foo.h"),CxxSource.Type.C,CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);
  ImmutableList<Step> steps=precompiledHeader.getBuildSteps(FakeBuildContext.NOOP_CONTEXT,new FakeBuildableContext());
  assertThat("Nothing should be done for cachable steps",steps,empty());
  ImmutableList<Step> postBuildSteps=precompiledHeader.getPostBuildSteps(FakeBuildContext.NOOP_CONTEXT,new FakeBuildableContext());
  CxxPreprocessAndCompileStep step=Iterables.getOnlyElement(Iterables.filter(postBuildSteps,CxxPreprocessAndCompileStep.class));
  assertThat("step that generates pch should have correct flags",step.getCommand(),hasItem(CxxSource.Type.C.getPrecompiledHeaderLanguage().get()));
}
