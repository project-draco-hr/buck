{
  ListenableFuture<Optional<String>> contentHash=Futures.transformAsync(Futures.<Void>immediateFuture(null),new AsyncFunction<Void,Optional<String>>(){
    @Override public ListenableFuture<Optional<String>> apply(    Void input) throws Exception {
      long fileSize=projectFilesystem.getFileSize(output);
      if (fileSize < twoLevelStoreThreshold) {
        return Futures.immediateFuture(Optional.<String>absent());
      }
      String hashCode="2c00" + projectFilesystem.computeSha1(output);
      return Futures.transform(delegate.store(ImmutableSet.of(new RuleKey(hashCode)),metadata,output),Functions.constant(Optional.of(hashCode)));
    }
  }
,listeningExecutorService);
  return Futures.transformAsync(contentHash,new AsyncFunction<Optional<String>,Boolean>(){
    @Override public ListenableFuture<Boolean> apply(    Optional<String> input) throws Exception {
      if (!input.isPresent()) {
        return Futures.immediateFuture(false);
      }
      return Futures.transform(delegate.store(ruleKeys,ImmutableMap.of(METADATA_KEY,input.get()),emptyFilePath),Functions.constant(true));
    }
  }
,listeningExecutorService);
}
