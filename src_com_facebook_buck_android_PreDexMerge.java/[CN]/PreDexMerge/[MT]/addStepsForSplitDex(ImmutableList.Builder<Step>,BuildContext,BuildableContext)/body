{
  ImmutableList<DexWithClasses> dexFilesToMerge=FluentIterable.from(preDexDeps).transform(DexWithClasses.TO_DEX_WITH_CLASSES).filter(Predicates.notNull()).toList();
  final SplitDexPaths paths=new SplitDexPaths();
  final ImmutableSet<Path> secondaryDexDirectories;
  if (dexSplitMode.getDexStore() == DexStore.RAW) {
    secondaryDexDirectories=ImmutableSet.of(paths.jarfilesSubdir);
  }
 else {
    secondaryDexDirectories=ImmutableSet.of(paths.metadataDir,paths.jarfilesDir);
  }
  steps.add(new MkdirStep(getProjectFilesystem(),paths.jarfilesSubdir));
  steps.add(new MkdirStep(getProjectFilesystem(),paths.successDir));
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),paths.metadataSubdir));
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),paths.scratchDir));
  buildableContext.addMetadata(SECONDARY_DEX_DIRECTORIES_KEY,FluentIterable.from(secondaryDexDirectories).transform(Functions.toStringFunction()).toList());
  buildableContext.recordArtifact(primaryDexPath);
  buildableContext.recordArtifact(paths.jarfilesSubdir);
  buildableContext.recordArtifact(paths.metadataSubdir);
  buildableContext.recordArtifact(paths.successDir);
  PreDexedFilesSorter preDexedFilesSorter=new PreDexedFilesSorter(aaptPackageResources.getRDotJavaDexWithClasses(),dexFilesToMerge,dexSplitMode.getPrimaryDexPatterns(),paths.scratchDir,dexSplitMode.getLinearAllocHardLimit(),dexSplitMode.getDexStore(),paths.jarfilesSubdir);
  final PreDexedFilesSorter.Result sortResult=preDexedFilesSorter.sortIntoPrimaryAndSecondaryDexes(context,getProjectFilesystem(),steps);
  steps.add(new SmartDexingStep(getProjectFilesystem(),primaryDexPath,Suppliers.ofInstance(sortResult.primaryDexInputs),Optional.of(paths.jarfilesSubdir),Optional.of(Suppliers.ofInstance(sortResult.secondaryOutputToInputs)),sortResult.dexInputHashesProvider,paths.successDir,DX_MERGE_OPTIONS,dxExecutorService,xzCompressionLevel));
  steps.add(new RecordFileSha1Step(getProjectFilesystem(),primaryDexPath,PRIMARY_DEX_HASH_KEY,buildableContext));
  steps.add(new AbstractExecutionStep("write_metadata_txt"){
    @Override public StepExecutionResult execute(    ExecutionContext executionContext){
      Map<Path,DexWithClasses> metadataTxtEntries=sortResult.metadataTxtDexEntries;
      List<String> lines=Lists.newArrayListWithCapacity(metadataTxtEntries.size());
      if (dexSplitMode.getDexStore() == DexStore.RAW) {
        lines.add(".root_relative");
      }
      try {
        for (        Map.Entry<Path,DexWithClasses> entry : metadataTxtEntries.entrySet()) {
          Path pathToSecondaryDex=entry.getKey();
          String containedClass=Iterables.get(entry.getValue().getClassNames(),0);
          containedClass=containedClass.replace('/','.');
          String hash=getProjectFilesystem().computeSha1(pathToSecondaryDex);
          lines.add(String.format("%s %s %s",pathToSecondaryDex.getFileName(),hash,containedClass));
        }
        getProjectFilesystem().writeLinesToPath(lines,paths.metadataFile);
      }
 catch (      IOException e) {
        executionContext.logError(e,"Failed when writing metadata.txt multi-dex.");
        return StepExecutionResult.ERROR;
      }
      return StepExecutionResult.SUCCESS;
    }
  }
);
}
