{
  Step step=new AbstractExecutionStep("exploding step"){
    @Override public int execute(    ExecutionContext context){
      throw new UnsupportedOperationException("build step should not be executed");
    }
  }
;
  String pathToOutputFile="foo/bar/baz";
  BuildableAbstractCachingBuildRule cachingRule=createRule(ImmutableSet.<BuildRule>of(),ImmutableList.<InputRule>of(),ImmutableList.of(step),Optional.<RuleKey>absent(),pathToOutputFile);
  StepRunner stepRunner=createMock(StepRunner.class);
  expect(stepRunner.getListeningExecutorService()).andReturn(MoreExecutors.sameThreadExecutor());
  File initialOutputFile=createMock(File.class);
  ProjectFilesystem projectFilesystem=createMock(ProjectFilesystem.class);
  expect(projectFilesystem.getFileForRelativePath(pathToOutputFile)).andReturn(initialOutputFile);
  Capture<Iterable<String>> lines;
  if (isSuccessScenario) {
    String pathToSuccessFile=cachingRule.getPathToSuccessFile();
    projectFilesystem.createParentDirs(pathToSuccessFile);
    lines=new Capture<Iterable<String>>();
    projectFilesystem.writeLinesToPath(capture(lines),eq(pathToSuccessFile));
  }
 else {
    lines=null;
  }
  ArtifactCache artifactCache=createMock(ArtifactCache.class);
  expect(artifactCache.fetch(cachingRule.getRuleKey(),initialOutputFile)).andReturn(true);
  BuildContext buildContext=BuildContext.builder().setProjectRoot(createMock(File.class)).setDependencyGraph(RuleMap.createGraphFromSingleRule(cachingRule)).setStepRunner(stepRunner).setProjectFilesystem(projectFilesystem).setArtifactCache(artifactCache).setJavaPackageFinder(createMock(JavaPackageFinder.class)).setEventBus(new BuckEventBus()).build();
  replayAll();
  ArtifactFetchedFromCacheScenario scenario=new ArtifactFetchedFromCacheScenario();
  scenario.cachingRule=cachingRule;
  scenario.buildContext=buildContext;
  scenario.lines=lines;
  return scenario;
}
