{
  ProjectFilesystem projectFilesystem=createService(true);
  BuildContext context=BuildContext.builder().setProjectRoot(createMock(File.class)).setDependencyGraph(createMock(DependencyGraph.class)).setCommandRunner(createMock(StepRunner.class)).setProjectFilesystem(projectFilesystem).setJavaPackageFinder(createMock(JavaPackageFinder.class)).build();
  BuildRule dep1=createMock(BuildRule.class);
  expect(dep1.isVisibleTo(buildTarget)).andReturn(true);
  expect(dep1.hasUncachedDescendants(context)).andReturn(false);
  BuildRule dep2=createMock(BuildRule.class);
  expect(dep2.isVisibleTo(buildTarget)).andReturn(true);
  expect(dep2.hasUncachedDescendants(context)).andReturn(false);
  BuildRule dep3=createMock(BuildRule.class);
  expect(dep3.isVisibleTo(buildTarget)).andReturn(true);
  expect(dep3.hasUncachedDescendants(context)).andReturn(false);
  Logger logger=createMock(Logger.class);
  @SuppressWarnings("unchecked") ImmutableSet<BuildTargetPattern> visibilityPatterns=createMock(ImmutableSet.class);
  replay(projectFilesystem,dep1,dep2,dep3,logger,visibilityPatterns);
  AbstractCachingBuildRule cachingRule=createRule(ImmutableSet.of(dep1,dep2,dep3),visibilityPatterns);
  boolean isCached=cachingRule.checkIsCached(context,logger);
  assertTrue("The rule should be cached",isCached);
  verify(projectFilesystem,dep1,dep2,dep3,logger,visibilityPatterns);
}
