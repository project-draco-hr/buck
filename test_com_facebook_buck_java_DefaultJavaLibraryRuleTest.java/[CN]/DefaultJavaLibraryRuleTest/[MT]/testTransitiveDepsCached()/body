{
  BuildContext context=EasyMock.createMock(BuildContext.class);
  EasyMock.expect(context.getBuildDependencies()).andReturn(BuildDependencies.WARN_ON_TRANSITIVE);
  EasyMock.replay(context);
  Map<String,BuildRule> buildRuleIndex=Maps.newHashMap();
  BuildTarget grandChildTarget=BuildTargetFactory.newInstance("//:grandChild");
  JavaLibraryRule grandChild=FakeDefaultJavaLibraryRule.newFakeJavaLibraryRuleBuilder().setHasUncachedDescendants(true).setBuildTarget(grandChildTarget).addSrc("java/src/com/grandchild/bar.java").setArtifactCache(artifactCache).build(buildRuleIndex);
  buildRuleIndex.put(grandChild.getFullyQualifiedName(),grandChild);
  BuildTarget childTarget=BuildTargetFactory.newInstance("//:child");
  JavaLibraryRule child=FakeDefaultJavaLibraryRule.newFakeJavaLibraryRuleBuilder().setHasUncachedDescendants(true).setBuildTarget(childTarget).addSrc("java/src/com/child/foo.java").addDep("//:grandChild").setArtifactCache(artifactCache).build(buildRuleIndex);
  buildRuleIndex.put(child.getFullyQualifiedName(),child);
  BuildTarget parentTarget=BuildTargetFactory.newInstance("//:parent");
  DefaultJavaLibraryRule parent=FakeDefaultJavaLibraryRule.newFakeJavaLibraryRuleBuilder().setHasUncachedDescendants(true).setBuildTarget(parentTarget).addSrc("java/src/com/parent/foo.java").addDep("//:child").setArtifactCache(artifactCache).build(buildRuleIndex);
  buildRuleIndex.put(parent.getFullyQualifiedName(),parent);
  Logger logger=EasyMock.createMock(Logger.class);
  logger.info("//:parent not cached because //:child has an uncached descendant");
  EasyMock.replay(logger);
  assertFalse(parent.depsCached(context,logger));
  EasyMock.verify(context,logger);
}
