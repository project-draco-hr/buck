{
  BuildTarget tinyLibraryTarget=BuildTargetFactory.newInstance("//:tinylib");
  final String tinyLibAbiKeyHash=Strings.repeat("a",40);
  BuildRuleParams params=new BuildRuleParams(tinyLibraryTarget,ImmutableSortedSet.<BuildRule>of(),ImmutableSet.<BuildTargetPattern>of(),Functions.<String>identity());
  JavaLibraryRule tinyLibrary=new DefaultJavaLibraryRule(params,ImmutableSet.of("foo/Bar.java"),ImmutableSet.<SourcePath>of(),Optional.<String>absent(),false,JavacOptions.builder().build()){
    @Override public Optional<Sha1HashCode> getAbiKey(){
      return Optional.of(new Sha1HashCode(tinyLibAbiKeyHash));
    }
  }
;
  Map<BuildTarget,BuildRule> buildRuleIndex=Maps.newHashMap();
  buildRuleIndex.put(tinyLibraryTarget,tinyLibrary);
  BuildRuleResolver oneTimeRuleResolver=new BuildRuleResolver(buildRuleIndex);
  DefaultJavaLibraryRule.Builder commonLibBuilder=DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).addDep(tinyLibraryTarget);
  BuildTarget commonWithExportTarget=BuildTargetFactory.newInstance("//:common_with_export");
  DefaultJavaLibraryRule realCommonWithExport=commonLibBuilder.setBuildTarget(commonWithExportTarget).setExportDeps(true).build(oneTimeRuleResolver);
  final String commonWithExportAbiKeyHash=Strings.repeat("b",40);
  JavaLibraryDelegate commonWithExport=new JavaLibraryDelegate(realCommonWithExport){
    @Override public Optional<Sha1HashCode> getAbiKey(){
      return Optional.of(new Sha1HashCode(commonWithExportAbiKeyHash));
    }
  }
;
  buildRuleIndex.put(commonWithExportTarget,commonWithExport);
  BuildRuleResolver ruleResolver=new BuildRuleResolver(buildRuleIndex);
  DefaultJavaLibraryRule commonNoExport=ruleResolver.buildAndAddToIndex(commonLibBuilder.setBuildTarget(BuildTargetFactory.newInstance("//:common_no_export")).setExportDeps(false));
  assertEquals("getAbiKeyForDeps() should be the same for both rules because they have the same deps.",commonNoExport.getAbiKeyForDeps(),commonWithExport.getAbiKeyForDeps());
  String expectedAbiKeyNoDepsHash=Hashing.sha1().newHasher().putString(tinyLibAbiKeyHash).hash().toString();
  String observedAbiKeyNoDepsHash=commonNoExport.getAbiKeyForDeps().get().getHash();
  assertEquals(expectedAbiKeyNoDepsHash,observedAbiKeyNoDepsHash);
  DefaultJavaLibraryRule consumerNoExport=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(BuildTargetFactory.newInstance("//:consumer_no_export")).addDep(BuildTargetFactory.newInstance("//:common_no_export")));
  DefaultJavaLibraryRule consumerWithExport=ruleResolver.buildAndAddToIndex(DefaultJavaLibraryRule.newJavaLibraryRuleBuilder(new FakeAbstractBuildRuleBuilderParams()).setBuildTarget(BuildTargetFactory.newInstance("//:consumer_with_export")).addDep(BuildTargetFactory.newInstance("//:common_with_export")));
  assertEquals("The ABI of the deps of //:consumer_no_export should be the empty ABI.",consumerNoExport.getAbiKeyForDeps(),Optional.of(new Sha1HashCode(AbiWriterProtocol.EMPTY_ABI_KEY)));
  assertThat("Although //:consumer_no_export and //:consumer_with_export have the same deps, " + "the ABIs of their deps will differ because of the use of export_deps=True.",consumerNoExport.getAbiKeyForDeps(),not(equalTo(consumerWithExport.getAbiKeyForDeps())));
  String expectedAbiKeyNoDepsHashForConsumerWithExport=Hashing.sha1().newHasher().putString(commonWithExportAbiKeyHash).putString(tinyLibAbiKeyHash).hash().toString();
  String observedAbiKeyNoDepsHashForConsumerWithExport=consumerWithExport.getAbiKeyForDeps().get().getHash();
  assertEquals("By hardcoding the ABI keys for the deps, we made getAbiKeyForDeps() a predictable value.",expectedAbiKeyNoDepsHashForConsumerWithExport,observedAbiKeyNoDepsHashForConsumerWithExport);
}
