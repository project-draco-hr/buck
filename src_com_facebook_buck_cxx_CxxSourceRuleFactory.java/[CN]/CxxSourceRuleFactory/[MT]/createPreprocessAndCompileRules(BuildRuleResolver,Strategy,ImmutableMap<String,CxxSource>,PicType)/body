{
  ImmutableList.Builder<CxxPreprocessAndCompile> objects=ImmutableList.builder();
  for (  Map.Entry<String,CxxSource> entry : sources.entrySet()) {
    String name=entry.getKey();
    CxxSource source=entry.getValue();
    Preconditions.checkState(CxxSourceTypes.isPreprocessableType(source.getType()) || CxxSourceTypes.isCompilableType(source.getType()));
switch (strategy) {
case COMBINED_PREPROCESS_AND_COMPILE:
{
        CxxPreprocessAndCompile rule;
        if (CxxSourceTypes.isPreprocessableType(source.getType())) {
          rule=createPreprocessAndCompileBuildRule(name,source,pic);
        }
 else {
          rule=createCompileBuildRule(name,source,pic);
        }
        resolver.addToIndex(rule);
        objects.add(rule);
        break;
      }
case SEPARATE_PREPROCESS_AND_COMPILE:
{
      if (CxxSourceTypes.isPreprocessableType(source.getType())) {
        CxxPreprocessAndCompile rule=createPreprocessBuildRule(name,source,pic);
        resolver.addToIndex(rule);
        source=CxxSource.copyOf(source).withType(CxxSourceTypes.getPreprocessorOutputType(source.getType())).withPath(new BuildTargetSourcePath(params.getProjectFilesystem(),rule.getBuildTarget()));
      }
      CxxPreprocessAndCompile rule=createCompileBuildRule(name,source,pic);
      resolver.addToIndex(rule);
      objects.add(rule);
      break;
    }
default :
  throw new IllegalStateException();
}
}
final ProjectFilesystem projectFilesystem=params.getProjectFilesystem();
return FluentIterable.from(objects.build()).toMap(new Function<CxxPreprocessAndCompile,SourcePath>(){
@Override public SourcePath apply(CxxPreprocessAndCompile input){
return new BuildTargetSourcePath(projectFilesystem,input.getBuildTarget());
}
}
);
}
