{
  ImmutableList.Builder<Path> toolSearchPathsBuilder=ImmutableList.builder();
  toolSearchPathsBuilder.add(sdkPaths.getSdkPath().resolve(USR_BIN)).add(sdkPaths.getSdkPath().resolve("Developer").resolve(USR_BIN)).add(sdkPaths.getPlatformPath().resolve("Developer").resolve(USR_BIN));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    toolSearchPathsBuilder.add(toolchainPath.resolve(USR_BIN));
  }
  if (sdkPaths.getDeveloperPath().isPresent()) {
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve(USR_BIN));
    toolSearchPathsBuilder.add(sdkPaths.getDeveloperPath().get().resolve("Tools"));
  }
  ImmutableList<Path> toolSearchPaths=toolSearchPathsBuilder.build();
  ImmutableList.Builder<String> cflagsBuilder=ImmutableList.builder();
  cflagsBuilder.add("-isysroot",sdkPaths.getSdkPath().toString());
  cflagsBuilder.add("-arch",targetArchitecture);
  cflagsBuilder.add(targetSdk.getApplePlatform().getMinVersionFlagPrefix() + minVersion);
  ImmutableList<String> asflags=cflagsBuilder.build();
  ImmutableList<String> ldflags=ImmutableList.copyOf(Linkers.iXlinker("-sdk_version",targetSdk.getVersion(),"-ObjC"));
  ImmutableList.Builder<String> versionsBuilder=ImmutableList.builder();
  versionsBuilder.add(targetSdk.getVersion());
  for (  AppleToolchain toolchain : targetSdk.getToolchains()) {
    versionsBuilder.add(toolchain.getVersion());
  }
  String version=Joiner.on(':').join(versionsBuilder.build());
  Tool clangPath=new VersionedTool(getToolPath("clang",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-clang",version);
  Tool clangXxPath=new VersionedTool(getToolPath("clang++",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-clang++",version);
  Tool ar=new VersionedTool(getToolPath("ar",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-ar",version);
  Tool ranlib=new VersionedTool(getToolPath("ranlib",toolSearchPaths,executableFinder),ImmutableList.of("-s"),"apple-ranlib",version);
  Tool strip=new VersionedTool(getToolPath("strip",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-strip",version);
  Tool nm=new VersionedTool(getToolPath("nm",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-nm",version);
  Tool actool=new VersionedTool(getToolPath("actool",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-actool",version);
  Tool ibtool=new VersionedTool(getToolPath("ibtool",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-ibtool",version);
  Tool xctest=new VersionedTool(getToolPath("xctest",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-xctest",version);
  Optional<Tool> otest=getOptionalTool("otest",toolSearchPaths,executableFinder,version);
  Tool dsymutil=new VersionedTool(getToolPath("dsymutil",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-dsymutil",version);
  Tool lipo=new VersionedTool(getToolPath("lipo",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"apple-lipo",version);
  Tool lldb=new VersionedTool(getToolPath("lldb",toolSearchPaths,executableFinder),ImmutableList.<String>of(),"lldb",version);
  Optional<Path> stubBinaryPath=targetSdk.getApplePlatform().getStubBinaryPath().transform(new Function<Path,Path>(){
    @Override public Path apply(    Path input){
      return sdkPaths.getSdkPath().resolve(input);
    }
  }
);
  CxxBuckConfig config=new CxxBuckConfig(buckConfig);
  ImmutableFlavor targetFlavor=ImmutableFlavor.of(ImmutableFlavor.replaceInvalidCharacters(targetSdk.getName() + "-" + targetArchitecture));
  ImmutableBiMap.Builder<Path,Path> sanitizerPaths=ImmutableBiMap.builder();
  sanitizerPaths.put(sdkPaths.getSdkPath(),Paths.get("APPLE_SDKROOT"));
  sanitizerPaths.put(sdkPaths.getPlatformPath(),Paths.get("APPLE_PLATFORM_DIR"));
  if (sdkPaths.getDeveloperPath().isPresent()) {
    sanitizerPaths.put(sdkPaths.getDeveloperPath().get(),Paths.get("APPLE_DEVELOPER_DIR"));
  }
  DebugPathSanitizer debugPathSanitizer=new DebugPathSanitizer(250,File.separatorChar,Paths.get("."),sanitizerPaths.build());
  ImmutableList<String> cflags=cflagsBuilder.build();
  ImmutableMap.Builder<String,String> macrosBuilder=ImmutableMap.builder();
  macrosBuilder.put("SDKROOT",sdkPaths.getSdkPath().toString());
  macrosBuilder.put("PLATFORM_DIR",sdkPaths.getPlatformPath().toString());
  if (sdkPaths.getDeveloperPath().isPresent()) {
    macrosBuilder.put("DEVELOPER_DIR",sdkPaths.getDeveloperPath().get().toString());
  }
  ImmutableMap<String,String> macros=macrosBuilder.build();
  Optional<String> buildVersion;
  Path platformVersionPlistPath=sdkPaths.getPlatformPath().resolve("version.plist");
  try (InputStream versionPlist=Files.newInputStream(platformVersionPlistPath)){
    NSDictionary versionInfo=(NSDictionary)PropertyListParser.parse(versionPlist);
    try {
      buildVersion=Optional.of(versionInfo.objectForKey("ProductBuildVersion").toString());
    }
 catch (    NullPointerException e) {
      LOG.warn("In %s, missing ProductBuildVersion. Build version will be unset for this platform.",platformVersionPlistPath);
      buildVersion=Optional.absent();
    }
  }
 catch (  NoSuchFileException e) {
    LOG.warn("%s does not exist. Build version will be unset for this platform.",platformVersionPlistPath);
    buildVersion=Optional.absent();
  }
catch (  PropertyListFormatException|SAXException|ParserConfigurationException|ParseException|IOException e) {
    LOG.warn(e,"Failed to parse %s. Build version will be unset for this platform.",platformVersionPlistPath);
    buildVersion=Optional.absent();
  }
  PreprocessorProvider aspp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.DEFAULT);
  CompilerProvider as=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.DEFAULT);
  PreprocessorProvider cpp=new PreprocessorProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cc=new CompilerProvider(new ConstantToolProvider(clangPath),CxxToolProvider.Type.CLANG);
  PreprocessorProvider cxxpp=new PreprocessorProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CompilerProvider cxx=new CompilerProvider(new ConstantToolProvider(clangXxPath),CxxToolProvider.Type.CLANG);
  CxxPlatform cxxPlatform=CxxPlatforms.build(targetFlavor,config,as,aspp,cc,cxx,cpp,cxxpp,new DefaultLinkerProvider(LinkerProvider.Type.DARWIN,new ConstantToolProvider(clangXxPath)),ImmutableList.<String>builder().addAll(cflags).addAll(ldflags).build(),strip,new BsdArchiver(ar),ranlib,nm,asflags,ImmutableList.<String>of(),cflags,ImmutableList.<String>of(),"dylib","%s.dylib",Optional.of(debugPathSanitizer),macros);
  ApplePlatform platform=targetSdk.getApplePlatform();
  ImmutableList<String> swiftParams=ImmutableList.of("-frontend","-sdk",sdkPaths.getSdkPath().toString(),"-target",targetArchitecture + "-apple-" + platform.getSwiftName().or(platform.getName())+ targetSdk.getVersion());
  ImmutableList<String> swiftStdlibToolParams=ImmutableList.of("--copy","--verbose","--strip-bitcode","--platform",platform.getName());
  AppleCxxPlatform.Builder platformBuilder=AppleCxxPlatform.builder().setCxxPlatform(cxxPlatform).setAppleSdk(targetSdk).setAppleSdkPaths(sdkPaths).setMinVersion(minVersion).setBuildVersion(buildVersion).setActool(actool).setIbtool(ibtool).setXctest(xctest).setOtest(otest).setDsymutil(dsymutil).setLipo(lipo).setStubBinary(stubBinaryPath).setLldb(lldb).setCodesignAllocate(getOptionalTool("codesign_allocate",toolSearchPaths,executableFinder,version)).setSwift(getOptionalToolWithParams("swift",toolSearchPaths,executableFinder,version,swiftParams)).setSwiftStdlibTool(getOptionalToolWithParams("swift-stdlib-tool",toolSearchPaths,executableFinder,version,swiftStdlibToolParams));
  for (  Path toolchainPath : sdkPaths.getToolchainPaths()) {
    Path swiftRuntimePath=toolchainPath.resolve("usr/lib/swift").resolve(platform.getName());
    if (Files.isDirectory(swiftRuntimePath)) {
      platformBuilder.addSwiftRuntimePaths(swiftRuntimePath);
    }
    Path swiftStaticRuntimePath=toolchainPath.resolve("usr/lib/swift_static").resolve(platform.getName());
    if (Files.isDirectory(swiftStaticRuntimePath)) {
      platformBuilder.addSwiftStaticRuntimePaths(swiftStaticRuntimePath);
    }
  }
  Optional<Path> developerPath=sdkPaths.getDeveloperPath();
  if (developerPath.isPresent()) {
    Path xcodeBundlePath=developerPath.get().getParent();
    if (xcodeBundlePath != null) {
      File xcodeInfoPlistPath=xcodeBundlePath.resolve("Info.plist").toFile();
      try {
        NSDictionary parsedXcodeInfoPlist=(NSDictionary)PropertyListParser.parse(xcodeInfoPlistPath);
        NSObject xcodeVersionObject=parsedXcodeInfoPlist.objectForKey("DTXcode");
        if (xcodeVersionObject != null) {
          platformBuilder.setXcodeVersion(Optional.of(xcodeVersionObject.toString()));
        }
      }
 catch (      IOException e) {
        LOG.debug("Error reading Xcode's info plist %s; ignoring Xcode versions",xcodeInfoPlistPath);
      }
catch (      PropertyListFormatException|ParseException|ParserConfigurationException|SAXException e) {
        LOG.debug("Error in parsing %s; ignoring Xcode versions",xcodeInfoPlistPath);
      }
    }
    if (processExecutor.isPresent()) {
      try {
        Optional<String> xcodeBuildVersion=appleConfig.getXcodeBuildVersionSupplier(developerPath.get(),processExecutor.get()).get();
        platformBuilder.setXcodeBuildVersion(xcodeBuildVersion);
        LOG.debug("Xcode build version is: " + xcodeBuildVersion.or("<absent>"));
      }
 catch (      IOException e) {
        LOG.debug("Error in getting Xcode build version");
      }
    }
  }
  return platformBuilder.build();
}
