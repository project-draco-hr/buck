{
  final BuildRuleResolver ruleResolver=new BuildRuleResolver();
  final MutableDirectedGraph<BuildRule> graph=new MutableDirectedGraph<BuildRule>();
  AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildTarget>(){
    @Override protected Iterator<BuildTarget> findChildren(    BuildTarget buildTarget){
      ParseContext parseContext=ParseContext.forBaseName(buildTarget.getBaseName());
      if (!knownBuildTargets.containsKey(buildTarget)) {
        throw new HumanReadableException(NoSuchBuildTargetException.createForMissingBuildRule(buildTarget,parseContext));
      }
      BuildRuleBuilder<?> buildRuleBuilder=knownBuildTargets.get(buildTarget);
      Set<BuildTarget> deps=Sets.newHashSet();
      for (      BuildTarget buildTargetForDep : buildRuleBuilder.getDeps()) {
        try {
          if (!knownBuildTargets.containsKey(buildTargetForDep)) {
            parseBuildFileContainingTarget(buildTargetForDep,defaultIncludes,buildFileParser);
          }
          deps.add(buildTargetForDep);
        }
 catch (        NoSuchBuildTargetException e) {
          throw new HumanReadableException(e);
        }
catch (        IOException e) {
          Throwables.propagate(e);
        }
      }
      return deps.iterator();
    }
    @Override protected void onNodeExplored(    BuildTarget buildTarget){
      BuildRuleBuilder<?> builderForTarget=knownBuildTargets.get(buildTarget);
      BuildRule buildRule=ruleResolver.buildAndAddToIndex(builderForTarget);
      if (buildRule.getDeps().isEmpty()) {
        graph.addNode(buildRule);
      }
 else {
        for (        BuildRule dep : buildRule.getDeps()) {
          graph.addEdge(buildRule,dep);
        }
      }
    }
    @Override protected void onTraversalComplete(    Iterable<BuildTarget> nodesInExplorationOrder){
    }
  }
;
  try {
    traversal.traverse(toExplore);
  }
 catch (  AbstractAcyclicDepthFirstPostOrderTraversal.CycleException e) {
    throw new HumanReadableException(e.getMessage());
  }
  return new DependencyGraph(graph);
}
