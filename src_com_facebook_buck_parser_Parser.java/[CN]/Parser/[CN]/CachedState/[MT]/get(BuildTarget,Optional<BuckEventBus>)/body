{
  TargetNode<?> toReturn=memoizedTargetNodes.get(buildTarget);
  if (toReturn != null) {
    return toReturn;
  }
  if (buildTarget.getRepository().isPresent()) {
    throw new HumanReadableException("Buck does not currently support multiple repos: %d",buildTarget);
  }
  Repository targetRepo=repository;
  Path buildFilePath;
  try {
    buildFilePath=targetRepo.getAbsolutePathToBuildFile(buildTarget);
  }
 catch (  Repository.MissingBuildFileException e) {
    throw new HumanReadableException(e);
  }
  UnflavoredBuildTarget unflavored=buildTarget.getUnflavoredBuildTarget();
  List<Map<String,Object>> rules=state.getRawRules(buildFilePath);
  for (  Map<String,Object> map : rules) {
    if (!buildTarget.getShortName().equals(map.get("name"))) {
      continue;
    }
    BuildRuleType buildRuleType=parseBuildRuleTypeFromRawRule(map);
    targetsToFile.put(BuildTarget.of(unflavored),normalize(Paths.get((String)map.get("buck.base_path"))).resolve(buildFile).toAbsolutePath());
    Description<?> description=repository.getDescription(buildRuleType);
    if (description == null) {
      throw new HumanReadableException("Unrecognized rule %s while parsing %s%s.",buildRuleType,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,MorePaths.pathWithUnixSeparators(unflavored.getBasePath().resolve(buildFile)));
    }
    if (buildTarget.isFlavored()) {
      if (description instanceof Flavored) {
        if (!((Flavored)description).hasFlavors(ImmutableSet.copyOf(buildTarget.getFlavors()))) {
          throw new HumanReadableException("Unrecognized flavor in target %s while parsing %s%s.",buildTarget,UnflavoredBuildTarget.BUILD_TARGET_PREFIX,MorePaths.pathWithUnixSeparators(buildTarget.getBasePath().resolve(buildFile)));
        }
      }
 else {
        LOG.warn("Target %s (type %s) must implement the Flavored interface " + "before we can check if it supports flavors: %s",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
        throw new HumanReadableException("Target %s (type %s) does not currently support flavors (tried %s)",buildTarget.getUnflavoredBuildTarget(),buildRuleType,buildTarget.getFlavors());
      }
    }
    this.pathsToBuildTargets.put(buildFilePath,buildTarget);
    BuildRuleFactoryParams factoryParams=new BuildRuleFactoryParams(targetRepo.getFilesystem(),buildTarget,buildFileTreeCache.get(),enforceBuckPackageBoundary);
    Object constructorArg=description.createUnpopulatedConstructorArg();
    TargetNode<?> targetNode;
    try {
      ImmutableSet.Builder<BuildTarget> declaredDeps=ImmutableSet.builder();
      ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns=ImmutableSet.builder();
      MarshalConstructorArgsEvent.Started marshalConstructorArgsEvent=null;
      if (eventBus.isPresent()) {
        marshalConstructorArgsEvent=MarshalConstructorArgsEvent.started(buildTarget);
        eventBus.get().post(marshalConstructorArgsEvent);
      }
      marshaller.populate(targetRepo.getFilesystem(),factoryParams,constructorArg,declaredDeps,visibilityPatterns,map);
      if (eventBus.isPresent()) {
        eventBus.get().post(MarshalConstructorArgsEvent.finished(Preconditions.checkNotNull(marshalConstructorArgsEvent)));
      }
      CreateTargetNodeEvent.Started createTargetNodeEvent=null;
      if (eventBus.isPresent()) {
        createTargetNodeEvent=CreateTargetNodeEvent.started(buildTarget);
        eventBus.get().post(createTargetNodeEvent);
      }
      targetNode=new TargetNode(description,constructorArg,factoryParams,declaredDeps.build(),visibilityPatterns.build());
      if (eventBus.isPresent()) {
        eventBus.get().post(CreateTargetNodeEvent.finished(Preconditions.checkNotNull(createTargetNodeEvent)));
      }
    }
 catch (    NoSuchBuildTargetException|TargetNode.InvalidSourcePathInputException e) {
      throw new HumanReadableException(e);
    }
catch (    ConstructorArgMarshalException e) {
      throw new HumanReadableException("%s: %s",buildTarget,e.getMessage());
    }
    Map<Path,Path> newSymlinksEncountered=Maps.newHashMap();
    if (inputFilesUnderSymlink(targetNode.getInputs(),targetRepo.getFilesystem(),symlinkExistenceCache,newSymlinksEncountered)) {
      LOG.warn("Disabling caching for target %s, because one or more input files are under a " + "symbolic link (%s). This will severely impact performance! To resolve this, use " + "separate rules and declare dependencies instead of using symbolic links.",targetNode.getBuildTarget(),newSymlinksEncountered);
      buildInputPathsUnderSymlink.add(buildFilePath);
    }
    TargetNode<?> existingTargetNode=memoizedTargetNodes.put(buildTarget,targetNode);
    if (existingTargetNode != null) {
      throw new HumanReadableException("Duplicate definition for " + unflavored);
    }
  }
  return memoizedTargetNodes.get(buildTarget);
}
