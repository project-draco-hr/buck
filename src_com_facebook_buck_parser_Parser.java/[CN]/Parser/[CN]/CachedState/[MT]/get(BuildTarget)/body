{
  TargetNode<?> toReturn=memoizedTargetNodes.get(buildTarget);
  if (toReturn != null) {
    return toReturn;
  }
  Repository targetRepo=repositoryFactory.getRepositoryByCanonicalName(buildTarget.getRepository());
  Path buildFilePath;
  try {
    buildFilePath=targetRepo.getAbsolutePathToBuildFile(buildTarget);
  }
 catch (  Repository.MissingBuildFileException e) {
    throw new HumanReadableException(e);
  }
  BuildTarget unflavored=buildTarget.getUnflavoredTarget();
  List<Map<String,Object>> rules=state.getRawRules(buildFilePath);
  for (  Map<String,Object> map : rules) {
    if (!buildTarget.getShortName().equals(map.get("name"))) {
      continue;
    }
    BuildRuleType buildRuleType=parseBuildRuleTypeFromRawRule(map);
    targetsToFile.put(unflavored,normalize(Paths.get((String)map.get("buck.base_path"))).resolve("BUCK").toAbsolutePath());
    Description<?> description=repository.getDescription(buildRuleType);
    if (description == null) {
      throw new HumanReadableException("Unrecognized rule %s while parsing %s%s.",buildRuleType,BuildTarget.BUILD_TARGET_PREFIX,unflavored.getBuildFilePath());
    }
    if (buildTarget.isFlavored() && (!(description instanceof Flavored) || !((Flavored)description).hasFlavors(buildTarget.getFlavors()))) {
      throw new HumanReadableException("Unrecognized flavor in target %s while parsing %s%s.",buildTarget,BuildTarget.BUILD_TARGET_PREFIX,buildTarget.getBuildFilePath());
    }
    this.pathsToBuildTargets.put(buildFilePath,buildTarget);
    BuildRuleFactoryParams factoryParams=new BuildRuleFactoryParams(targetRepo.getFilesystem(),targetRepo.getBuildTargetParser(),buildTarget,ruleKeyBuilderFactory,buildFileTreeCache.get(),enforceBuckPackageBoundary);
    Object constructorArg=description.createUnpopulatedConstructorArg();
    TargetNode<?> targetNode;
    try {
      ImmutableSet.Builder<BuildTarget> declaredDeps=ImmutableSet.builder();
      ImmutableSet.Builder<BuildTargetPattern> visibilityPatterns=ImmutableSet.builder();
      marshaller.populate(targetRepo.getFilesystem(),factoryParams,constructorArg,declaredDeps,visibilityPatterns,map);
      targetNode=new TargetNode(description,constructorArg,factoryParams,declaredDeps.build(),visibilityPatterns.build());
    }
 catch (    NoSuchBuildTargetException|TargetNode.InvalidSourcePathInputException e) {
      throw new HumanReadableException(e);
    }
catch (    ConstructorArgMarshalException e) {
      throw new HumanReadableException("%s: %s",buildTarget,e.getMessage());
    }
    Map<Path,Path> newSymlinksEncountered=Maps.newHashMap();
    if (inputFilesUnderSymlink(targetNode.getInputs(),targetRepo.getFilesystem(),symlinkExistenceCache,newSymlinksEncountered)) {
      LOG.warn("Disabling caching for target %s, because one or more input files are under a " + "symbolic link (%s). This will severely impact performance! To resolve this, use " + "separate rules and declare dependencies instead of using symbolic links.",targetNode.getBuildTarget(),newSymlinksEncountered);
      buildInputPathsUnderSymlink.add(buildFilePath);
    }
    TargetNode<?> existingTargetNode=memoizedTargetNodes.put(buildTarget,targetNode);
    if (existingTargetNode != null) {
      throw new HumanReadableException("Duplicate definition for " + unflavored);
    }
  }
  return memoizedTargetNodes.get(buildTarget);
}
