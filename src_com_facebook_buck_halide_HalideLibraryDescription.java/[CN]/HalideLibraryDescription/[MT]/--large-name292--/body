{
  BuildTarget target=createHalideCompilerBuildTarget(params.getBuildTarget());
  Optional<BuildRule> rule=ruleResolver.getRuleOptional(target);
  if (rule.isPresent()) {
    CxxBinary compilerRule=(CxxBinary)rule.get();
    return compilerRule;
  }
  ImmutableMap<String,CxxSource> srcs=CxxDescriptionEnhancer.parseCxxSources(params,ruleResolver,cxxPlatform,halideSources,PatternMatchedCollection.<ImmutableSortedSet<SourceWithFlags>>of());
  Optional<ImmutableList<String>> preprocessorFlags=Optional.absent();
  Optional<PatternMatchedCollection<ImmutableList<String>>> platformPreprocessorFlags=Optional.absent();
  Optional<ImmutableMap<CxxSource.Type,ImmutableList<String>>> langPreprocessorFlags=Optional.absent();
  Optional<ImmutableSortedSet<FrameworkPath>> frameworks=Optional.of(ImmutableSortedSet.<FrameworkPath>of());
  Optional<SourcePath> prefixHeader=Optional.absent();
  CxxLinkAndCompileRules cxxLinkAndCompileRules=CxxDescriptionEnhancer.createBuildRulesForCxxBinary(targetGraph,params.copyWithBuildTarget(target),ruleResolver,cxxPlatform,srcs,ImmutableMap.<Path,SourcePath>of(),preprocessMode,Linker.LinkableDepType.STATIC,preprocessorFlags,platformPreprocessorFlags,langPreprocessorFlags,frameworks,compilerFlags,platformCompilerFlags,prefixHeader,linkerFlags,platformLinkerFlags);
  BuildRuleParams binParams=params.copyWithBuildTarget(target);
  binParams.appendExtraDeps(cxxLinkAndCompileRules.executable.getDeps(pathResolver));
  CxxBinary cxxBinary=new CxxBinary(binParams,ruleResolver,pathResolver,cxxLinkAndCompileRules.cxxLink.getOutput(),cxxLinkAndCompileRules.cxxLink,cxxLinkAndCompileRules.executable,ImmutableSortedSet.<FrameworkPath>of(),ImmutableSortedSet.<BuildTarget>of());
  ruleResolver.addToIndex(cxxBinary);
  return cxxBinary;
}
