{
  final Logger log=m_log;
  final boolean verbose=log.atVERBOSE();
  if (verbose) {
    log.verbose(IAppConstants.APP_VERBOSE_BUILD_ID);
    log.verbose("coverage path:");
    log.verbose("{");
    for (int p=0; p < m_coveragePath.length; ++p) {
      final File f=m_coveragePath[p];
      final String nonexistent=f.exists() ? "" : "{nonexistent} ";
      log.verbose("  " + nonexistent + f.getAbsolutePath());
    }
    log.verbose("}");
    if ((m_sourcePath == null) || (m_sourcePath.length == 0)) {
      log.verbose("source path not set");
    }
 else {
      log.verbose("source path:");
      log.verbose("{");
      for (int p=0; p < m_sourcePath.length; ++p) {
        final File f=m_sourcePath[p];
        final String nonexistent=f.exists() ? "" : "{nonexistent} ";
        log.verbose("  " + nonexistent + f.getAbsolutePath());
      }
      log.verbose("}");
    }
  }
  File sdataOutFile=m_sdataOutFile;
  Boolean sdataOutMerge=m_sdataOutMerge;
{
    if (sdataOutFile == null)     sdataOutFile=new File(toolProperties.getProperty(EMMAProperties.PROPERTY_SESSION_DATA_OUT_FILE,EMMAProperties.DEFAULT_SESSION_DATA_OUT_FILE));
    if (sdataOutMerge == null) {
      final String _dataOutMerge=toolProperties.getProperty(EMMAProperties.PROPERTY_SESSION_DATA_OUT_MERGE,EMMAProperties.DEFAULT_SESSION_DATA_OUT_MERGE.toString());
      sdataOutMerge=Property.toBoolean(_dataOutMerge) ? Boolean.TRUE : Boolean.FALSE;
    }
  }
  if (verbose && m_dumpSessionData) {
    log.verbose("session data output file: " + sdataOutFile.getAbsolutePath());
    log.verbose("session data output merge mode: " + sdataOutMerge);
  }
  final IInclExclFilter forcedDelegationFilter=IInclExclFilter.Factory.create(toolProperties.getProperty(InstrClassLoader.PROPERTY_FORCED_DELEGATION_FILTER),COMMA_DELIMITERS,FORCED_DELEGATION_FILTER_SPECS);
  final IInclExclFilter throughDelegationFilter=IInclExclFilter.Factory.create(toolProperties.getProperty(InstrClassLoader.PROPERTY_THROUGH_DELEGATION_FILTER),COMMA_DELIMITERS,null);
  ExitHookManager runnerExitHookManager=null;
  try {
    runnerExitHookManager=ExitHookManager.getSingleton();
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
  }
  AppRunnerExitHook runnerExitHook=null;
  RuntimeException failure=null;
  try {
    SourcePathCache srcpathCache=null;
    if (m_sourcePath != null)     srcpathCache=new SourcePathCache(m_sourcePath,true);
    ICoverageData cdata=RT.getCoverageData();
    if ($assert.ENABLED)     $assert.ASSERT(cdata != null,"cdata is null");
    IMetaData mdata=DataFactory.newMetaData(CoverageOptionsFactory.create(toolProperties));
    runnerExitHook=new AppRunnerExitHook(log,m_dumpSessionData,sdataOutFile,sdataOutMerge.booleanValue(),mdata,cdata,m_reportGenerators,srcpathCache,toolProperties);
    if (runnerExitHookManager != null)     runnerExitHookManager.addExitHook(runnerExitHook);
    Map classIOCache=null;
    if (m_scanCoveragePath) {
      if (USE_SOFT_CACHE)       classIOCache=new SoftValueMap(INIT_CACHE_CAPACITY,0.75F,SOFT_CACHE_READ_CHK_FREQUENCY,SOFT_CACHE_WRITE_CHK_FREQUENCY);
 else       classIOCache=new HashMap(INIT_CACHE_CAPACITY,0.75F);
      final ClassPathProcessorST processor=new ClassPathProcessorST(m_coveragePath,m_canonical,mdata,m_coverageFilter,classIOCache);
      processor.run();
      if (log.atTRACE1()) {
        log.trace1("run","class cache size after cp scan: " + classIOCache.size());
        log.trace1("run","metadata size after cp scan: " + mdata.size());
      }
    }
    srcpathCache=null;
    cdata=null;
    final ClassLoader appLoader;
{
      final IClassLoadHook loadHook=new InstrClassLoadHook(m_coverageFilter,mdata);
      try {
        appLoader=new InstrClassLoader(m_delegate,m_coveragePath,forcedDelegationFilter,throughDelegationFilter,loadHook,classIOCache);
      }
 catch (      SecurityException se) {
        throw new EMMARuntimeException(SECURITY_RESTRICTION,new String[]{IAppConstants.APP_NAME},se);
      }
catch (      MalformedURLException mue) {
        throw new EMMARuntimeException(mue);
      }
    }
    mdata=null;
    classIOCache=null;
    final ClassLoader contextLoader;
    boolean contextLoaderSet=false;
    if (SET_CURRENT_CONTEXT_LOADER) {
      try {
        final Thread currentThread=Thread.currentThread();
        contextLoader=currentThread.getContextClassLoader();
        currentThread.setContextClassLoader(appLoader);
        contextLoaderSet=true;
      }
 catch (      SecurityException se) {
        throw new EMMARuntimeException(SECURITY_RESTRICTION,new String[]{IAppConstants.APP_NAME},se);
      }
    }
    ThreadGroup appThreadGroup=null;
    try {
      final Class appClass;
      try {
        appClass=Class.forName(m_appClassName,INIT_AT_LOAD_TIME,appLoader);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new EMMARuntimeException(MAIN_CLASS_NOT_FOUND,new String[]{m_appClassName},cnfe);
      }
catch (      ExceptionInInitializerError eiie) {
        final Throwable cause=eiie.getException();
        throw new EMMARuntimeException(MAIN_CLASS_LOAD_FAILURE,new String[]{m_appClassName,cause.toString()},cause);
      }
catch (      Throwable t) {
        throw new EMMARuntimeException(MAIN_CLASS_NOT_FOUND,new String[]{m_appClassName},t);
      }
{
        final ClassLoader actualLoader=appClass.getClassLoader();
        if (actualLoader != appLoader) {
          final String loaderName=actualLoader != null ? actualLoader.getClass().getName() : "<PRIMORDIAL>";
          throw new EMMARuntimeException(MAIN_CLASS_BAD_DELEGATION,new String[]{IAppConstants.APP_NAME,m_appClassName,loaderName});
        }
      }
      final Method appMain;
      try {
        appMain=appClass.getMethod("main",MAIN_TYPE);
      }
 catch (      Throwable t) {
        throw new EMMARuntimeException(MAIN_METHOD_NOT_FOUND,new String[]{m_appClassName},t);
      }
      Invoker invoker=new Invoker(appMain,null,new Object[]{m_appArgs});
      appThreadGroup=new ThreadGroup(IAppConstants.APP_NAME + " thread group [" + m_appClassName+ "]");
      appThreadGroup.setDaemon(true);
      Thread appThread=new Thread(appThreadGroup,invoker,IAppConstants.APP_NAME + " main() thread");
      appThread.setContextClassLoader(appLoader);
      appThread.start();
      try {
        appThread.join();
      }
 catch (      InterruptedException ignore) {
      }
      appThread=null;
      joinNonDeamonThreads(appThreadGroup);
      if (log.atTRACE1()) {
        if (appLoader instanceof InstrClassLoader)         ((InstrClassLoader)appLoader).debugDump(log.getWriter());
      }
      final Throwable mainFailure=invoker.getFailure();
      invoker=null;
      if (mainFailure != null) {
        if (mainFailure instanceof InvocationTargetException) {
          final Throwable cause=((InvocationTargetException)mainFailure).getTargetException();
          throw new EMMARuntimeException(MAIN_METHOD_FAILURE,new String[]{m_appClassName,cause.toString()},cause);
        }
 else         if (mainFailure instanceof ExceptionInInitializerError) {
          final Throwable cause=((ExceptionInInitializerError)mainFailure).getException();
          throw new EMMARuntimeException(MAIN_METHOD_FAILURE,new String[]{m_appClassName,cause.toString()},cause);
        }
 else         if ((mainFailure instanceof IllegalAccessException) || (mainFailure instanceof IllegalArgumentException) || (mainFailure instanceof NullPointerException)) {
          throw new EMMARuntimeException(MAIN_METHOD_NOT_FOUND,new String[]{m_appClassName},mainFailure);
        }
 else {
          throw new EMMARuntimeException(MAIN_METHOD_FAILURE,new String[]{m_appClassName,mainFailure.toString()},mainFailure);
        }
      }
    }
 catch (    SecurityException se) {
      throw new EMMARuntimeException(SECURITY_RESTRICTION,new String[]{IAppConstants.APP_NAME},se);
    }
 finally {
      if (SET_CURRENT_CONTEXT_LOADER && contextLoaderSet) {
        try {
          Thread.currentThread().setContextClassLoader(contextLoader);
        }
 catch (        Throwable ignore) {
        }
      }
      if ((appThreadGroup != null) && !appThreadGroup.isDestroyed())       try {
        appThreadGroup.destroy();
        appThreadGroup=null;
      }
 catch (      Throwable ignore) {
      }
    }
  }
 catch (  RuntimeException re) {
    failure=re;
  }
 finally {
    RT.reset(false,false);
  }
  if ($assert.ENABLED)   $assert.ASSERT(runnerExitHook != null,"reportExitHook = null");
  runnerExitHook.run();
  if (runnerExitHookManager != null) {
    runnerExitHookManager.removeExitHook(runnerExitHook);
    runnerExitHookManager=null;
  }
  final Throwable exitHookDataDumpFailure=runnerExitHook.getDataDumpFailure();
  final List exitHookReportFailures=runnerExitHook.getReportFailures();
  runnerExitHook=null;
  if (failure != null) {
    throw wrapFailure(failure);
  }
 else   if ((exitHookDataDumpFailure != null) || (exitHookReportFailures != null)) {
    if (exitHookDataDumpFailure != null)     log.log(Logger.SEVERE,"exception while persisting raw session data:",exitHookDataDumpFailure);
    Throwable firstReportFailure=null;
    if (exitHookReportFailures != null) {
      for (Iterator i=exitHookReportFailures.iterator(); i.hasNext(); ) {
        final Throwable reportFailure=(Throwable)i.next();
        if (firstReportFailure == null)         firstReportFailure=reportFailure;
        log.log(Logger.SEVERE,"exception while creating a report:",reportFailure);
      }
    }
    if (exitHookDataDumpFailure != null)     throw wrapFailure(exitHookDataDumpFailure);
 else     if (firstReportFailure != null)     throw wrapFailure(firstReportFailure);
  }
}
