{
  String tinyLibAbiKeyHash=Strings.repeat("a",40);
  BuildRule tinyLibrary=createDefaultJavaLibaryRuleWithAbiKey(tinyLibAbiKeyHash,BuildTargetFactory.newInstance("//:tinylib"),ImmutableSet.of("foo/Bar.java"),ImmutableSortedSet.<BuildRule>of(),ImmutableSortedSet.<BuildRule>of());
  String commonWithExportAbiKeyHash=Strings.repeat("b",40);
  BuildRule commonWithExport=createDefaultJavaLibaryRuleWithAbiKey(commonWithExportAbiKeyHash,BuildTargetFactory.newInstance("//:common_with_export"),ImmutableSet.<String>of(),ImmutableSortedSet.of(tinyLibrary),ImmutableSortedSet.of(tinyLibrary));
  BuildRule commonNoExport=createDefaultJavaLibaryRuleWithAbiKey(null,BuildTargetFactory.newInstance("//:common_no_export"),ImmutableSet.<String>of(),ImmutableSortedSet.of(tinyLibrary),ImmutableSortedSet.<BuildRule>of());
  assertEquals("getAbiKeyForDeps() should be the same for both rules because they have the same deps.",((AbiRule)commonNoExport).getAbiKeyForDeps(),((AbiRule)commonWithExport).getAbiKeyForDeps());
  String expectedAbiKeyForDepsHash=Hashing.sha1().newHasher().putUnencodedChars(tinyLibAbiKeyHash).hash().toString();
  String observedAbiKeyForDepsHash=((AbiRule)commonNoExport).getAbiKeyForDeps().getHash();
  assertEquals(expectedAbiKeyForDepsHash,observedAbiKeyForDepsHash);
  Map<BuildTarget,BuildRule> buildRuleIndex=Maps.newHashMap();
  buildRuleIndex.put(tinyLibrary.getBuildTarget(),tinyLibrary);
  buildRuleIndex.put(commonWithExport.getBuildTarget(),commonWithExport);
  buildRuleIndex.put(commonNoExport.getBuildTarget(),commonNoExport);
  BuildRuleResolver ruleResolver=new BuildRuleResolver(buildRuleIndex);
  BuildRule consumerNoExport=JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance("//:consumer_no_export")).addDep(commonNoExport.getBuildTarget()).build(ruleResolver);
  BuildRule consumerWithExport=JavaLibraryBuilder.createBuilder(BuildTargetFactory.newInstance("//:consumer_with_export")).addDep(commonWithExport.getBuildTarget()).build(ruleResolver);
  Sha1HashCode noAbiDeps=ImmutableSha1HashCode.of(Hashing.sha1().newHasher().hash().toString());
  assertEquals("The ABI of the deps of //:consumer_no_export should be the empty ABI.",noAbiDeps,((AbiRule)consumerNoExport).getAbiKeyForDeps());
  assertThat("Although //:consumer_no_export and //:consumer_with_export have the same deps, " + "the ABIs of their deps will differ because of the use of exported_deps is non-empty",((AbiRule)consumerNoExport).getAbiKeyForDeps(),not(equalTo(((AbiRule)consumerWithExport).getAbiKeyForDeps())));
  String expectedAbiKeyNoDepsHashForConsumerWithExport=Hashing.sha1().newHasher().putUnencodedChars(((HasJavaAbi)commonWithExport).getAbiKey().getHash()).putUnencodedChars(tinyLibAbiKeyHash).hash().toString();
  String observedAbiKeyNoDepsHashForConsumerWithExport=((AbiRule)consumerWithExport).getAbiKeyForDeps().getHash();
  assertEquals("By hardcoding the ABI keys for the deps, we made getAbiKeyForDeps() a predictable value.",expectedAbiKeyNoDepsHashForConsumerWithExport,observedAbiKeyNoDepsHashForConsumerWithExport);
}
