{
  if (options.isResolveAlias()) {
    return doResolveAlias(options);
  }
  if (options.isShowOutput() || options.isShowRuleKey()) {
    return doShowRules(options);
  }
  ImmutableSet<String> types=options.getTypes();
  ImmutableSet.Builder<BuildRuleType> buildRuleTypesBuilder=ImmutableSet.builder();
  for (  String name : types) {
    try {
      buildRuleTypesBuilder.add(getRepository().getBuildRuleType(name));
    }
 catch (    IllegalArgumentException e) {
      console.printBuildFailure("Invalid build rule type: " + name);
      return 1;
    }
  }
  ImmutableSet<BuildTarget> matchingBuildTargets=ImmutableSet.copyOf(getBuildTargets(options.getArgumentsFormattedAsBuildTargets()));
  TargetGraph graph;
  try {
    if (matchingBuildTargets.isEmpty()) {
      graph=getParser().buildTargetGraphForTargetNodeSpecs(ImmutableList.of(new TargetNodePredicateSpec(Predicates.<TargetNode<?>>alwaysTrue(),getProjectFilesystem().getIgnorePaths())),options.getDefaultIncludes(),getBuckEventBus(),console,environment,options.getEnableProfiling());
    }
 else {
      graph=getParser().buildTargetGraphForBuildTargets(matchingBuildTargets,options.getDefaultIncludes(),getBuckEventBus(),console,environment,options.getEnableProfiling());
    }
  }
 catch (  BuildTargetException|BuildFileParseException e) {
    console.printBuildFailureWithoutStacktrace(e);
    return 1;
  }
  PathArguments.ReferencedFiles referencedFiles=options.getReferencedFiles(getProjectFilesystem().getRootPath());
  SortedMap<String,TargetNode<?>> matchingNodes;
  if (!referencedFiles.absolutePathsOutsideProjectRootOrNonExistingPaths.isEmpty() && referencedFiles.relativePathsUnderProjectRoot.isEmpty()) {
    matchingNodes=ImmutableSortedMap.of();
  }
 else {
    ImmutableSet<BuildRuleType> buildRuleTypes=buildRuleTypesBuilder.build();
    matchingNodes=getMatchingNodes(graph,referencedFiles.relativePathsUnderProjectRoot.isEmpty() ? Optional.<ImmutableSet<Path>>absent() : Optional.of(referencedFiles.relativePathsUnderProjectRoot),matchingBuildTargets.isEmpty() ? Optional.<ImmutableSet<BuildTarget>>absent() : Optional.of(matchingBuildTargets),buildRuleTypes.isEmpty() ? Optional.<ImmutableSet<BuildRuleType>>absent() : Optional.of(buildRuleTypes));
  }
  if (options.getPrintJson()) {
    try {
      printJsonForTargets(matchingNodes,options.getDefaultIncludes());
    }
 catch (    BuildFileParseException e) {
      console.printBuildFailureWithoutStacktrace(e);
      return 1;
    }
  }
 else {
    for (    String target : matchingNodes.keySet()) {
      getStdOut().println(target);
    }
  }
  return 0;
}
