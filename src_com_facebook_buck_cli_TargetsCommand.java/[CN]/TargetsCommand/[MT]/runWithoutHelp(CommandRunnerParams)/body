{
  if (isResolveAlias()) {
    return doResolveAlias(params);
  }
  if (isShowRuleKey() && isShowTargetHash()) {
    throw new HumanReadableException("Cannot show rule key and target hash at the same time.");
  }
  if (isShowOutput() || isShowRuleKey() || isShowTargetHash()) {
    return doShowRules(params);
  }
  ImmutableSet<String> types=getTypes();
  ImmutableSet.Builder<BuildRuleType> buildRuleTypesBuilder=ImmutableSet.builder();
  for (  String name : types) {
    try {
      buildRuleTypesBuilder.add(params.getCell().getBuildRuleType(name));
    }
 catch (    IllegalArgumentException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe("Invalid build rule type: " + name));
      return 1;
    }
  }
  ParserConfig parserConfig=new ParserConfig(params.getBuckConfig());
  ImmutableSet<BuildTarget> matchingBuildTargets;
  TargetGraph graph;
  try {
    if (getArguments().isEmpty() || isDetectTestChanges()) {
      matchingBuildTargets=ImmutableSet.of();
      graph=params.getParser().buildTargetGraphForTargetNodeSpecs(ImmutableList.of(TargetNodePredicateSpec.of(Predicates.<TargetNode<?>>alwaysTrue(),BuildFileSpec.fromRecursivePath(Paths.get(""),params.getCell().getFilesystem().getIgnorePaths()))),parserConfig,params.getBuckEventBus(),params.getConsole(),params.getEnvironment(),getEnableProfiling()).getSecond();
    }
 else {
      Pair<ImmutableSet<BuildTarget>,TargetGraph> results=params.getParser().buildTargetGraphForTargetNodeSpecs(parseArgumentsAsTargetNodeSpecs(params.getBuckConfig(),params.getCell().getFilesystem().getIgnorePaths(),getArguments()),parserConfig,params.getBuckEventBus(),params.getConsole(),params.getEnvironment(),getEnableProfiling());
      matchingBuildTargets=results.getFirst();
      graph=results.getSecond();
    }
  }
 catch (  BuildTargetException|BuildFileParseException e) {
    params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
    return 1;
  }
  PathArguments.ReferencedFiles referencedFiles=getReferencedFiles(params.getCell().getFilesystem().getRootPath());
  SortedMap<String,TargetNode<?>> matchingNodes;
  if (!referencedFiles.absolutePathsOutsideProjectRootOrNonExistingPaths.isEmpty() && referencedFiles.relativePathsUnderProjectRoot.isEmpty()) {
    matchingNodes=ImmutableSortedMap.of();
  }
 else {
    ImmutableSet<BuildRuleType> buildRuleTypes=buildRuleTypesBuilder.build();
    matchingNodes=getMatchingNodes(graph,referencedFiles.relativePathsUnderProjectRoot.isEmpty() ? Optional.<ImmutableSet<Path>>absent() : Optional.of(referencedFiles.relativePathsUnderProjectRoot),matchingBuildTargets.isEmpty() ? Optional.<ImmutableSet<BuildTarget>>absent() : Optional.of(matchingBuildTargets),buildRuleTypes.isEmpty() ? Optional.<ImmutableSet<BuildRuleType>>absent() : Optional.of(buildRuleTypes),isDetectTestChanges(),parserConfig.getBuildFileName());
  }
  if (getPrintJson()) {
    try {
      printJsonForTargets(params,matchingNodes,new ParserConfig(params.getBuckConfig()));
    }
 catch (    BuildFileParseException e) {
      params.getBuckEventBus().post(ConsoleEvent.severe(MoreExceptions.getHumanReadableOrLocalizedMessage(e)));
      return 1;
    }
  }
 else   if (isPrint0()) {
    printNullDelimitedTargets(matchingNodes.keySet(),params.getConsole().getStdOut());
  }
 else {
    for (    String target : matchingNodes.keySet()) {
      params.getConsole().getStdOut().println(target);
    }
  }
  return 0;
}
