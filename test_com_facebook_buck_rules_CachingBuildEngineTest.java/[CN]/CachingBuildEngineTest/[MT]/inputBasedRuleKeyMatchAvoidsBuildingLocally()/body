{
  ProjectFilesystem filesystem=new FakeProjectFilesystem(tmp.getRoot());
  DefaultFileHashCache fileHashCache=new DefaultFileHashCache(filesystem);
  InMemoryArtifactCache cache=new InMemoryArtifactCache();
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new BuildTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  final RuleKeyBuilderFactory ruleKeyBuilderFactory=new DefaultRuleKeyBuilderFactory(fileHashCache,pathResolver);
  BuildContext buildContext=FakeBuildContext.newBuilder().setArtifactCache(cache).setJavaPackageFinder(new FakeJavaPackageFinder()).setActionGraph(new ActionGraph(ImmutableList.<BuildRule>of())).build();
  BuildTarget target=BuildTargetFactory.newInstance("//:rule");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final RuleKey inputRuleKey=new RuleKey("aaaa");
  final Path output=Paths.get("output");
  final BuildRule rule=new InputRuleKeyBuildRule(params,pathResolver){
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.<Step>of(new AbstractExecutionStep("false"){
        @Override public int execute(        ExecutionContext context){
          return 1;
        }
      }
);
    }
    @Override public Path getPathToOutput(){
      return output;
    }
  }
;
  filesystem.writeContentsToPath("stuff",output);
  filesystem.writeContentsToPath(MAPPER.writeValueAsString(ImmutableList.of(output.toString())),BuildInfo.getPathToMetadataDirectory(target).resolve(BuildInfo.METADATA_KEY_FOR_RECORDED_PATHS));
  filesystem.writeContentsToPath(inputRuleKey.toString(),BuildInfo.getPathToMetadataDirectory(target).resolve(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY));
  CachingBuildEngine cachingBuildEngine=new CachingBuildEngine(MoreExecutors.newDirectExecutorService(),fileHashCache,CachingBuildEngine.BuildMode.SHALLOW,CachingBuildEngine.DependencySchedulingOrder.RANDOM,CachingBuildEngine.DepFiles.ENABLED,256L,pathResolver,Functions.constant(new CachingBuildEngine.RuleKeyFactories(ruleKeyBuilderFactory,new FakeRuleKeyBuilderFactory(ImmutableMap.of(rule.getBuildTarget(),inputRuleKey)),NOOP_RULE_KEY_FACTORY,NOOP_DEP_FILE_RULE_KEY_FACTORY)));
  BuildResult result=cachingBuildEngine.build(buildContext,rule).get();
  assertEquals(BuildRuleSuccessType.MATCHING_INPUT_BASED_RULE_KEY,result.getSuccess());
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem);
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY),equalTo(Optional.of(ruleKeyBuilderFactory.build(rule))));
  LazyPath fetchedArtifact=LazyPath.ofInstance(tmp.newFile("fetched_artifact.zip").toPath());
  assertThat(cache.fetch(ruleKeyBuilderFactory.build(rule),fetchedArtifact).getType(),equalTo(CacheResultType.MISS));
}
