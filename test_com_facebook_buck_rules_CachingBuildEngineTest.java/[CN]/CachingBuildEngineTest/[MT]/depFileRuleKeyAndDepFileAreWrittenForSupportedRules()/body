{
  final ProjectFilesystem filesystem=new FakeProjectFilesystem(tmp.getRoot());
  final DefaultFileHashCache fileHashCache=new DefaultFileHashCache(filesystem);
  InMemoryArtifactCache cache=new InMemoryArtifactCache();
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new BuildTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  BuildContext buildContext=FakeBuildContext.newBuilder().setArtifactCache(cache).setJavaPackageFinder(new FakeJavaPackageFinder()).setActionGraph(new ActionGraph(ImmutableList.<BuildRule>of())).build();
  RuleKeyBuilderFactory factory=new DefaultRuleKeyBuilderFactory(fileHashCache,pathResolver);
  DefaultDependencyFileRuleKeyBuilderFactory depFilefactory=new DefaultDependencyFileRuleKeyBuilderFactory(fileHashCache,pathResolver,factory);
  final Genrule genrule=(Genrule)GenruleBuilder.newGenruleBuilder(BuildTargetFactory.newInstance("//:dep")).setOut("input").build(resolver,filesystem);
  final Path input=Preconditions.checkNotNull(genrule.getPathToOutput());
  filesystem.writeContentsToPath("contents",input);
  BuildTarget target=BuildTargetFactory.newInstance("//:rule");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setProjectFilesystem(filesystem).build();
  final Path output=Paths.get("output");
  final BuildRule rule=new DepFileBuildRule(params,pathResolver){
    @AddToRuleKey private final SourcePath path=new BuildTargetSourcePath(genrule.getBuildTarget());
    @Override public ImmutableList<Step> getBuildSteps(    BuildContext context,    BuildableContext buildableContext){
      return ImmutableList.<Step>of(new WriteFileStep(filesystem,"",output,false));
    }
    @Override public ImmutableList<SourcePath> getInputsAfterBuildingLocally(){
      return ImmutableList.<SourcePath>of(new PathSourcePath(filesystem,input));
    }
    @Override public Path getPathToOutput(){
      return output;
    }
  }
;
  CachingBuildEngine cachingBuildEngine=new CachingBuildEngine(MoreExecutors.newDirectExecutorService(),fileHashCache,CachingBuildEngine.BuildMode.SHALLOW,CachingBuildEngine.DependencySchedulingOrder.RANDOM,CachingBuildEngine.DepFiles.ENABLED,256L,pathResolver,Functions.constant(new CachingBuildEngine.RuleKeyFactories(factory,factory,factory,depFilefactory)));
  RuleKey depFileRuleKey=depFilefactory.build(rule,ImmutableList.of(input));
  BuildResult result=cachingBuildEngine.build(buildContext,rule).get();
  assertEquals(BuildRuleSuccessType.BUILT_LOCALLY,getSuccess(result));
  OnDiskBuildInfo onDiskBuildInfo=buildContext.createOnDiskBuildInfoFor(target,filesystem);
  assertThat(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY),equalTo(Optional.of(depFileRuleKey)));
  assertThat(onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_DEP_FILE),equalTo(Optional.of(ImmutableList.of(input.toString()))));
  Path fetchedArtifact=tmp.newFile("fetched_artifact.zip").toPath();
  CacheResult cacheResult=cache.fetch(factory.build(rule),LazyPath.ofInstance(fetchedArtifact));
  assertThat(cacheResult.getType(),equalTo(CacheResultType.HIT));
  assertThat(cacheResult.getMetadata().get(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY),equalTo(depFileRuleKey.toString()));
  ZipInspector inspector=new ZipInspector(fetchedArtifact);
  inspector.assertFileContents(BuildInfo.getPathToMetadataDirectory(target).resolve(BuildInfo.METADATA_KEY_FOR_DEP_FILE).toString(),new ObjectMapper().writeValueAsString(ImmutableList.of(input.toString())));
}
