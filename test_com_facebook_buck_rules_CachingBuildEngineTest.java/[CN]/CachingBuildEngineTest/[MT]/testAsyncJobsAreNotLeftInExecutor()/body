{
  BuildRuleParams buildRuleParams=new FakeBuildRuleParamsBuilder(buildTarget).build();
  TestAbstractCachingBuildRule buildRule=new LocallyBuiltTestAbstractCachingBuildRule(buildRuleParams,new SourcePathResolver(new BuildRuleResolver()));
  BuckEventBus buckEventBus=BuckEventBusFactory.newInstance();
  FakeBuckEventListener listener=new FakeBuckEventListener();
  buckEventBus.register(listener);
  BuildContext buildContext=createMock(BuildContext.class);
  expect(buildContext.getProjectRoot()).andReturn(createMock(Path.class));
  NoopArtifactCache artifactCache=new NoopArtifactCache();
  expect(buildContext.getArtifactCache()).andStubReturn(artifactCache);
  expect(buildContext.getStepRunner()).andStubReturn(null);
  BuildInfoRecorder buildInfoRecorder=createNiceMock(BuildInfoRecorder.class);
  expect(buildContext.createBuildInfoRecorder(eq(buildTarget),anyObject(RuleKey.class),anyObject(RuleKey.class))).andReturn(buildInfoRecorder);
  expect(buildInfoRecorder.fetchArtifactForBuildable(anyObject(File.class),eq(artifactCache))).andReturn(CacheResult.miss());
  expect(buildInfoRecorder.getOutputSizeAndHash(anyObject(HashFunction.class))).andReturn(new Pair<>(0L,HashCode.fromInt(0))).anyTimes();
  OnDiskBuildInfo onDiskBuildInfo=new FakeOnDiskBuildInfo();
  buildInfoRecorder.addMetadata(CachingBuildEngine.ABI_KEY_FOR_DEPS_ON_DISK_METADATA,TestAbstractCachingBuildRule.ABI_KEY_FOR_DEPS_HASH);
  buildInfoRecorder.writeMetadataToDisk(true);
  buildInfoRecorder.performUploadToArtifactCache(artifactCache,buckEventBus);
  expectLastCall().andAnswer(new IAnswer<Object>(){
    @Override public Object answer() throws Throwable {
      Thread.sleep(500);
      return null;
    }
  }
);
  ListeningExecutorService service=listeningDecorator(Executors.newFixedThreadPool(2));
  expect(buildContext.createOnDiskBuildInfoFor(buildTarget)).andReturn(onDiskBuildInfo);
  expect(buildContext.getStepRunner()).andReturn(createStepRunner(null));
  expect(buildContext.getEventBus()).andReturn(buckEventBus).anyTimes();
  replayAll();
  CachingBuildEngine cachingBuildEngine=new CachingBuildEngine(service,CachingBuildEngine.BuildMode.SHALLOW);
  ListenableFuture<BuildResult> buildResult=cachingBuildEngine.build(buildContext,buildRule);
  BuildResult result=buildResult.get();
  assertEquals(BuildRuleSuccessType.BUILT_LOCALLY,result.getSuccess());
  assertTrue(service.shutdownNow().isEmpty());
  List<BuckEvent> events=listener.getEvents();
  assertThat(events,Matchers.hasSize(6));
  Iterator<BuckEvent> eventIter=events.iterator();
  assertEquals(configureTestEvent(BuildRuleEvent.started(buildRule),buckEventBus).getEventName(),eventIter.next().getEventName());
  assertEquals(configureTestEvent(BuildRuleEvent.suspended(buildRule),buckEventBus).getEventName(),eventIter.next().getEventName());
  assertEquals(configureTestEvent(BuildRuleEvent.resumed(buildRule),buckEventBus).getEventName(),eventIter.next().getEventName());
  assertEquals(configureTestEvent(BuildRuleEvent.suspended(buildRule),buckEventBus).getEventName(),eventIter.next().getEventName());
  assertEquals(configureTestEvent(BuildRuleEvent.resumed(buildRule),buckEventBus).getEventName(),eventIter.next().getEventName());
  assertEquals(configureTestEvent(BuildRuleEvent.finished(buildRule,BuildRuleStatus.SUCCESS,CacheResult.miss(),Optional.of(BuildRuleSuccessType.BUILT_LOCALLY),Optional.<HashCode>absent(),Optional.<Long>absent()),buckEventBus).getEventName(),eventIter.next().getEventName());
  verifyAll();
}
