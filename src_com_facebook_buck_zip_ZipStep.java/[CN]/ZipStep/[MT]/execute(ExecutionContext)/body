{
  final ProjectFilesystem filesystem=context.getProjectFilesystem();
  if (filesystem.exists(pathToZipFile)) {
    context.postEvent(ConsoleEvent.severe("Attempting to overwrite an existing zip: %s",pathToZipFile));
    return 1;
  }
  try (BufferedOutputStream baseOut=new BufferedOutputStream(filesystem.newFileOutputStream(pathToZipFile));final CustomZipOutputStream out=ZipOutputStreams.newOutputStream(baseOut,OVERWRITE_EXISTING)){
    final FileVisitor<Path> pathFileVisitor=new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attributes) throws IOException {
        if (!paths.isEmpty() && !paths.contains(file)) {
          return FileVisitResult.CONTINUE;
        }
        Path resolvedPath=filesystem.resolve(file);
        Path relativePath=junkPaths ? file.getFileName() : baseDir.relativize(file);
        String entryName=MorePaths.pathWithUnixSeparators(relativePath);
        CustomZipEntry entry=new CustomZipEntry(entryName);
        entry.setTime(attributes.lastModifiedTime().toMillis());
        entry.setCompressionLevel(compressionLevel);
        if (entry.getMethod() == ZipEntry.STORED) {
          entry.setSize(attributes.size());
          entry.setCompressedSize(attributes.size());
          entry.setCrc(com.google.common.io.Files.hash(resolvedPath.toFile(),Hashing.crc32()).padToLong());
        }
        out.putNextEntry(entry);
        Files.copy(resolvedPath,out);
        out.closeEntry();
        return FileVisitResult.CONTINUE;
      }
    }
;
    filesystem.walkRelativeFileTree(baseDir,pathFileVisitor);
  }
 catch (  IOException e) {
    context.logError(e,"Error creating zip file %s",pathToZipFile);
    return 1;
  }
  return 0;
}
