{
  ImmutableMap<Path,Path> replacementPaths;
  try {
    replacementPaths=preprocessDelegate.isPresent() ? preprocessDelegate.get().getReplacementPaths() : ImmutableMap.<Path,Path>of();
  }
 catch (  CxxHeaders.ConflictingHeadersException e) {
    throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
  }
  Optional<CxxPreprocessAndCompileStep.ToolCommand> preprocessorCommand;
  if (preprocessDelegate.isPresent()) {
    preprocessorCommand=Optional.of(new CxxPreprocessAndCompileStep.ToolCommand(preprocessDelegate.get().getPreprocessorCommand(),preprocessDelegate.get().getPreprocessorEnvironment(),preprocessDelegate.get().getColorSupport()));
  }
 else {
    preprocessorCommand=Optional.absent();
  }
  Optional<CxxPreprocessAndCompileStep.ToolCommand> compilerCommand;
  if (compiler.isPresent()) {
    Optional<SupportsColorsInOutput> colorSupport=Optional.absent();
    if (compiler.get() instanceof SupportsColorsInOutput) {
      colorSupport=Optional.of((SupportsColorsInOutput)compiler.get());
    }
    compilerCommand=Optional.of(new CxxPreprocessAndCompileStep.ToolCommand(ImmutableList.<String>builder().addAll(compiler.get().getCommandPrefix(getResolver())).addAll(getCompilerPlatformPrefix()).addAll(getCompilerSuffix()).build(),compiler.get().getEnvironment(getResolver()),colorSupport));
  }
 else {
    compilerCommand=Optional.absent();
  }
  return new CxxPreprocessAndCompileStep(getProjectFilesystem(),operation,output,getDepFilePath(),getResolver().deprecatedGetPath(input),inputType,preprocessorCommand,compilerCommand,replacementPaths,sanitizer,preprocessDelegate.isPresent() ? preprocessDelegate.get().getPreprocessorExtraLineProcessor() : Optional.<Function<String,Iterable<String>>>absent());
}
