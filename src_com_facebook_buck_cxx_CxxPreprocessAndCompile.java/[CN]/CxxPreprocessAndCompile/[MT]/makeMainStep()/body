{
  ImmutableMap.Builder<Path,Path> replacementPathsBuilder=ImmutableMap.builder();
  try {
    for (    Map.Entry<Path,SourcePath> entry : CxxHeaders.concat(includes).getFullNameToPathMap().entrySet()) {
      replacementPathsBuilder.put(entry.getKey(),getResolver().deprecatedGetPath(entry.getValue()));
    }
  }
 catch (  CxxHeaders.ConflictingHeadersException e) {
    throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
  }
  ImmutableMap<Path,Path> replacementPaths=replacementPathsBuilder.build();
  Optional<ImmutableList<String>> preprocessorCommand;
  if (preprocessor.isPresent()) {
    preprocessorCommand=Optional.of(ImmutableList.<String>builder().addAll(preprocessor.get().getCommandPrefix(getResolver())).addAll(getPreprocessorPlatformPrefix()).addAll(getPreprocessorSuffix()).addAll(preprocessor.get().getExtraFlags().or(ImmutableList.<String>of())).build());
  }
 else {
    preprocessorCommand=Optional.absent();
  }
  Optional<ImmutableList<String>> compilerCommand;
  if (compiler.isPresent()) {
    compilerCommand=Optional.of(ImmutableList.<String>builder().addAll(compiler.get().getCommandPrefix(getResolver())).addAll(getCompilerPlatformPrefix()).addAll(getCompilerSuffix()).build());
  }
 else {
    compilerCommand=Optional.absent();
  }
  return new CxxPreprocessAndCompileStep(getProjectFilesystem(),operation,output,getDepFilePath(),getResolver().deprecatedGetPath(input),inputType,preprocessorCommand,compilerCommand,replacementPaths,sanitizer,Optionals.bind(preprocessor,new Function<Preprocessor,Optional<Function<String,Iterable<String>>>>(){
    @Override public Optional<Function<String,Iterable<String>>> apply(    Preprocessor input){
      return input.getExtraLineProcessor();
    }
  }
));
}
