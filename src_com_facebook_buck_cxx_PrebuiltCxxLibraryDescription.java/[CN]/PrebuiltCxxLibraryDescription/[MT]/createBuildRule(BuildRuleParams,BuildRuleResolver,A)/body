{
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  final BuildTarget target=params.getBuildTarget();
  final boolean headerOnly=args.headerOnly.or(false);
  final boolean provided=args.provided.or(false);
  final boolean linkWhole=args.linkWhole.or(false);
  final String libDir=args.libDir.or("lib");
  final String libName=args.libName.or(target.getShortNameOnly());
  final String soname=args.soname.or(String.format("lib%s.so",libName));
  final Path staticLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.a",libName));
  final SourcePath staticLibrary=new PathSourcePath(staticLibraryPath);
  final Path sharedLibraryPath;
  final SourcePath sharedLibrary;
  Path prebuiltSharedLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.so",libName));
  if (params.getProjectFilesystem().exists(prebuiltSharedLibraryPath)) {
    sharedLibraryPath=prebuiltSharedLibraryPath;
    sharedLibrary=new PathSourcePath(sharedLibraryPath);
  }
 else {
    BuildTarget sharedLibraryTarget=BuildTargets.extendFlavoredBuildTarget(params.getBuildTarget(),SHARED);
    sharedLibraryPath=BuildTargets.getBinPath(sharedLibraryTarget,"%s").resolve(soname);
    CxxLink cxxLink=CxxLinkableEnhancer.createCxxLinkableBuildRule(cxxPlatform,params,pathResolver,ImmutableList.<String>of(),ImmutableList.<String>of(),BuildTargets.extendFlavoredBuildTarget(params.getBuildTarget(),SHARED),CxxLinkableEnhancer.LinkType.SHARED,Optional.of(soname),sharedLibraryPath,ImmutableList.of(staticLibrary),NativeLinkable.Type.SHARED,params.getDeps());
    resolver.addToIndex(cxxLink);
    sharedLibrary=new BuildRuleSourcePath(cxxLink);
  }
  Function<String,Path> fullPathFn=new Function<String,Path>(){
    @Override public Path apply(    String input){
      return target.getBasePath().resolve(input);
    }
  }
;
  final ImmutableList<Path> includeDirs=FluentIterable.from(args.includeDirs.or(ImmutableList.of("include"))).transform(fullPathFn).toList();
  return new CxxLibrary(params,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(){
      return new CxxPreprocessorInput(ImmutableSet.<BuildTarget>of(),ImmutableList.<String>of(),ImmutableList.<String>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableList.<Path>of(),includeDirs);
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    Linker linker,    Type type){
      ImmutableList.Builder<SourcePath> librariesBuilder=ImmutableList.builder();
      ImmutableList.Builder<String> linkerArgsBuilder=ImmutableList.builder();
      if (!headerOnly) {
        if (provided || type == Type.SHARED) {
          librariesBuilder.add(sharedLibrary);
          linkerArgsBuilder.add(sharedLibraryPath.toString());
        }
 else {
          librariesBuilder.add(staticLibrary);
          if (linkWhole) {
            linkerArgsBuilder.addAll(linker.linkWhole(staticLibraryPath.toString()));
          }
 else {
            linkerArgsBuilder.add(staticLibraryPath.toString());
          }
        }
      }
      final ImmutableList<SourcePath> libraries=librariesBuilder.build();
      final ImmutableList<String> linkerArgs=linkerArgsBuilder.build();
      return new NativeLinkableInput(libraries,linkerArgs);
    }
    @Override public PythonPackageComponents getPythonPackageComponents(){
      ImmutableMap.Builder<Path,SourcePath> nativeLibrariesBuilder=ImmutableMap.builder();
      if (!headerOnly && !provided) {
        nativeLibrariesBuilder.put(Paths.get(soname),sharedLibrary);
      }
      ImmutableMap<Path,SourcePath> nativeLibraries=nativeLibrariesBuilder.build();
      return new PythonPackageComponents(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),nativeLibraries);
    }
  }
;
}
