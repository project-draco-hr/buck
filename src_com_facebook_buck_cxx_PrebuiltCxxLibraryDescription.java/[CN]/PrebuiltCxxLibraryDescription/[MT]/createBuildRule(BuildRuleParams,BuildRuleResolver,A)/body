{
  final BuildTarget target=params.getBuildTarget();
  final boolean headerOnly=args.headerOnly.or(false);
  final boolean provided=args.provided.or(false);
  final boolean linkWhole=args.linkWhole.or(false);
  final String libDir=args.libDir.or("lib");
  final String libName=args.libName.or(target.getShortNameOnly());
  final String soname=args.soname.or(String.format("lib%s.so",libName));
  final Path sharedLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.so",libName));
  final Path staticLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.a",libName));
  Function<String,Path> fullPathFn=new Function<String,Path>(){
    @Override public Path apply(    String input){
      return target.getBasePath().resolve(input);
    }
  }
;
  final ImmutableList<Path> includeDirs=FluentIterable.from(args.includeDirs.or(ImmutableList.of("include"))).transform(fullPathFn).toList();
  return new CxxLibrary(params){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(){
      return new CxxPreprocessorInput(ImmutableSet.<BuildTarget>of(),ImmutableList.<String>of(),ImmutableList.<String>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableList.<Path>of(),includeDirs);
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    Linker linker,    Type type){
      boolean wholeArchive=linkWhole && !provided && type != Type.SHARED;
      Path library=provided || type == Type.SHARED ? sharedLibraryPath : staticLibraryPath;
      ImmutableList.Builder<SourcePath> librariesBuilder=ImmutableList.builder();
      ImmutableList.Builder<String> linkerArgsBuilder=ImmutableList.builder();
      if (!headerOnly) {
        if (wholeArchive) {
          linkerArgsBuilder.addAll(linker.linkWhole(library.toString()));
        }
 else {
          linkerArgsBuilder.add(library.toString());
        }
        librariesBuilder.add(new PathSourcePath(library));
      }
      final ImmutableList<SourcePath> libraries=librariesBuilder.build();
      final ImmutableList<String> linkerArgs=linkerArgsBuilder.build();
      return new NativeLinkableInput(libraries,linkerArgs);
    }
    @Override public PythonPackageComponents getPythonPackageComponents(){
      ImmutableMap.Builder<Path,SourcePath> nativeLibrariesBuilder=ImmutableMap.builder();
      if (!headerOnly && !provided) {
        nativeLibrariesBuilder.put(Paths.get(soname),new PathSourcePath(sharedLibraryPath));
      }
      ImmutableMap<Path,SourcePath> nativeLibraries=nativeLibrariesBuilder.build();
      return new PythonPackageComponents(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),nativeLibraries);
    }
  }
;
}
