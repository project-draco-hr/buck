{
  Optional<Map.Entry<Flavor,Type>> type;
  Optional<Map.Entry<Flavor,CxxPlatform>> platform;
  try {
    type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget().getFlavors());
    platform=cxxPlatforms.getFlavorAndValue(params.getBuildTarget().getFlavors());
  }
 catch (  FlavorDomainException e) {
    throw new HumanReadableException("%s: %s",params.getBuildTarget(),e.getMessage());
  }
  if (type.isPresent()) {
    Preconditions.checkState(type.get().getValue() == Type.SHARED);
    Preconditions.checkState(platform.isPresent());
    return createSharedLibraryBuildRule(params,resolver,platform.get().getValue(),args);
  }
  final BuildTarget target=params.getBuildTarget();
  boolean headerOnly=args.headerOnly.or(false);
  boolean provided=args.provided.or(false);
  boolean linkWhole=args.linkWhole.or(false);
  String libDir=args.libDir.or("lib");
  String libName=args.libName.or(target.getShortNameOnly());
  String soname=args.soname.or(String.format("lib%s.so",libName));
  Path staticLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.a",libName));
  Path sharedLibraryPath=target.getBasePath().resolve(libDir).resolve(String.format("lib%s.so",libName));
  Function<String,Path> fullPathFn=new Function<String,Path>(){
    @Override public Path apply(    String input){
      return target.getBasePath().resolve(input);
    }
  }
;
  final ImmutableList<Path> includeDirs=FluentIterable.from(args.includeDirs.or(ImmutableList.of("include"))).transform(fullPathFn).toList();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  return new PrebuiltCxxLibrary(params,resolver,pathResolver,includeDirs,staticLibraryPath,sharedLibraryPath,args.linkerFlags.or(ImmutableList.<String>of()),soname,headerOnly,linkWhole,provided);
}
