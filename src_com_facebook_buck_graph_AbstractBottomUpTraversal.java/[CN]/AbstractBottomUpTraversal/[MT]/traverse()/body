{
  Iterables.addAll(nodesToExplore,graph.getNodesWithNoOutgoingEdges());
  while (!nodesToExplore.isEmpty()) {
    T node=nodesToExplore.remove();
    if (visitedNodes.contains(node)) {
      Preconditions.checkState(false,"The queue of nodes to explore should not contain a node that has already been" + " visited.");
    }
    visit(node);
    visitedNodes.add(node);
    for (    T exploreCandidate : graph.getIncomingNodesFor(node)) {
      if (!effectiveOutDegreesOfExplorableNodes.containsKey(exploreCandidate)) {
        effectiveOutDegreesOfExplorableNodes.put(exploreCandidate,new AtomicInteger(Iterables.size(graph.getOutgoingNodesFor(exploreCandidate))));
      }
      if (effectiveOutDegreesOfExplorableNodes.get(exploreCandidate).decrementAndGet() == 0) {
        nodesToExplore.add(exploreCandidate);
      }
    }
  }
}
