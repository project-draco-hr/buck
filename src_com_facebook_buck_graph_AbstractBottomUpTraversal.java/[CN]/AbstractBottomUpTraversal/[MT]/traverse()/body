{
  nodesToExplore.addAll(graph.getNodesWithNoOutgoingEdges());
  while (!nodesToExplore.isEmpty()) {
    T node=nodesToExplore.remove();
    if (visitedNodes.contains(node)) {
      Preconditions.checkState(false,"The queue of nodes to explore should not contain a node that has already been" + " visited.");
    }
    visit(node);
    visitedNodes.add(node);
    for (    T exploreCandidate : graph.getIncomingNodesFor(node)) {
      boolean hasUnexploredDependency=false;
      for (      T dep : graph.getOutgoingNodesFor(exploreCandidate)) {
        if (!visitedNodes.contains(dep)) {
          hasUnexploredDependency=true;
          break;
        }
      }
      if (!hasUnexploredDependency) {
        nodesToExplore.add(exploreCandidate);
      }
    }
  }
}
