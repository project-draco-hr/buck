def resolve(requirements, fetchers=None, interpreter=None, platform=None, context=None, precedence=None, cache=None, cache_ttl=None):
    'Produce all distributions needed to (recursively) meet `requirements`\n\n  :param requirements: An iterator of Requirement-like things, either\n    :class:`pkg_resources.Requirement` objects or requirement strings.\n  :keyword fetchers: (optional) A list of :class:`Fetcher` objects for locating packages.  If\n    unspecified, the default is to look for packages on PyPI.\n  :keyword interpreter: (optional) A :class:`PythonInterpreter` object to use for building\n    distributions and for testing distribution compatibility.\n  :keyword platform: (optional) A PEP425-compatible platform string to use for filtering\n    compatible distributions.  If unspecified, the current platform is used, as determined by\n    `Platform.current()`.\n  :keyword context: (optional) A :class:`Context` object to use for network access.  If\n    unspecified, the resolver will attempt to use the best available network context.\n  :type threads: int\n  :keyword precedence: (optional) An ordered list of allowable :class:`Package` classes\n    to be used for producing distributions.  For example, if precedence is supplied as\n    ``(WheelPackage, SourcePackage)``, wheels will be preferred over building from source, and\n    eggs will not be used at all.  If ``(WheelPackage, EggPackage)`` is suppplied, both wheels and\n    eggs will be used, but the resolver will not resort to building anything from source.\n  :keyword cache: (optional) A directory to use to cache distributions locally.\n  :keyword cache_ttl: (optional integer in seconds) If specified, consider non-exact matches when\n    resolving requirements.  For example, if ``setuptools==2.2`` is specified and setuptools 2.2 is\n    available in the cache, it will always be used.  However, if a non-exact requirement such as\n    ``setuptools>=2,<3`` is specified and there exists a setuptools distribution newer than\n    cache_ttl seconds that satisfies the requirement, then it will be used.  If the distribution\n    is older than cache_ttl seconds, it will be ignored.  If ``cache_ttl`` is not specified,\n    resolving inexact requirements will always result in making network calls through the\n    ``context``.\n  :returns: List of :class:`pkg_resources.Distribution` instances meeting ``requirements``.\n  :raises Unsatisfiable: If ``requirements`` is not transitively satisfiable.\n  :raises Untranslateable: If no compatible distributions could be acquired for\n    a particular requirement.\n\n  This method improves upon the setuptools dependency resolution algorithm by maintaining sets of\n  all compatible distributions encountered for each requirement rather than the single best\n  distribution encountered for each requirement.  This prevents situations where ``tornado`` and\n  ``tornado==2.0`` could be treated as incompatible with each other because the "best\n  distribution" when encountering ``tornado`` was tornado 3.0.  Instead, ``resolve`` maintains the\n  set of compatible distributions for each requirement as it is encountered, and iteratively filters\n  the set.  If the set of distributions ever becomes empty, then ``Unsatisfiable`` is raised.\n\n  .. versionchanged:: 0.8\n    A number of keywords were added to make requirement resolution slightly easier to configure.\n    The optional ``obtainer`` keyword was replaced by ``fetchers``, ``translator``, ``context``,\n    ``threads``, ``precedence``, ``cache`` and ``cache_ttl``, also all optional keywords.\n\n  .. versionchanged:: 1.0\n    The ``translator`` and ``threads`` keywords have been removed.  The choice of threading\n    policy is now implicit.  The choice of translation policy is dictated by ``precedence``\n    directly.\n\n  .. versionchanged:: 1.0\n    ``resolver`` is now just a wrapper around the :class:`Resolver` and :class:`CachingResolver`\n    classes.\n  '
    builder = ResolverOptionsBuilder(fetchers=fetchers, precedence=precedence, context=context)
    if cache:
        resolver = CachingResolver(cache, cache_ttl, interpreter=interpreter, platform=platform)
    else:
        resolver = Resolver(interpreter=interpreter, platform=platform)
    return resolver.resolve(resolvables_from_iterable(requirements, builder))
