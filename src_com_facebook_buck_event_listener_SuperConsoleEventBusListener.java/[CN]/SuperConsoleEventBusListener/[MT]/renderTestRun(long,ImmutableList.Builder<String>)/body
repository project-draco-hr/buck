{
  ImmutableList<Map.Entry<Long,Optional<? extends TestRuleEvent>>> eventsByThread=FluentIterable.from(threadsToRunningTestRuleEvent.entrySet()).toSortedList(new Comparator<Map.Entry<Long,Optional<? extends TestRuleEvent>>>(){
    @Override public int compare(    Map.Entry<Long,Optional<? extends TestRuleEvent>> a,    Map.Entry<Long,Optional<? extends TestRuleEvent>> b){
      return Long.signum(a.getKey() - b.getKey());
    }
  }
);
  for (  Map.Entry<Long,Optional<? extends TestRuleEvent>> entry : eventsByThread) {
    String threadLine=" |=> ";
    Optional<? extends TestRuleEvent> startedEvent=entry.getValue();
    if (!startedEvent.isPresent()) {
      threadLine+="IDLE";
      threadLine=ansi.asSubtleText(threadLine);
    }
 else {
      AtomicLong accumulatedTime=accumulatedRuleTime.get(startedEvent.get().getBuildTarget());
      long elapsedTimeMs=(currentMillis - startedEvent.get().getTimestamp()) + (accumulatedTime != null ? accumulatedTime.get() : 0);
      threadLine+=String.format("%s...  %s",startedEvent.get().getBuildTarget(),formatElapsedTime(elapsedTimeMs));
      Optional<? extends TestSummaryEvent> summaryEvent=threadsToRunningTestSummaryEvent.get(entry.getKey());
      Optional<? extends LeafEvent> leafEvent=threadsToRunningStep.get(entry.getKey());
      String eventName;
      long eventTime;
      if (summaryEvent != null && summaryEvent.isPresent()) {
        eventName=summaryEvent.get().getTestName();
        eventTime=summaryEvent.get().getTimestamp();
      }
 else       if (leafEvent != null && leafEvent.isPresent()) {
        eventName=leafEvent.get().getCategory();
        eventTime=leafEvent.get().getTimestamp();
      }
 else {
        eventName=null;
        eventTime=0;
      }
      if (eventName != null) {
        threadLine+=String.format(" (running %s[%s])",eventName,formatElapsedTime(currentMillis - eventTime));
      }
      if (elapsedTimeMs > WARNING_THRESHOLD_MS) {
        if (elapsedTimeMs > ERROR_THRESHOLD_MS) {
          threadLine=ansi.asErrorText(threadLine);
        }
 else {
          threadLine=ansi.asWarningText(threadLine);
        }
      }
    }
    lines.add(threadLine);
  }
}
