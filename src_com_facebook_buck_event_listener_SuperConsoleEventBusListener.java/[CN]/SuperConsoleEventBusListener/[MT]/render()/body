{
  LOG.verbose("Rendering");
  String lastRenderClear=clearLastRender();
  ImmutableList<String> lines=createRenderLinesAtTime(clock.currentTimeMillis());
  ImmutableList<String> logLines=createLogRenderLines();
  lastNumLinesPrinted=lines.size();
synchronized (console.getStdOut()) {
synchronized (console.getStdErr()) {
      boolean stdoutDirty=console.getStdOut().isDirty();
      boolean stderrDirty=console.getStdErr().isDirty();
      if (stdoutDirty || stderrDirty) {
        LOG.debug("Stopping console output (stdout dirty %s, stderr dirty %s).",stdoutDirty,stderrDirty);
        stopRenderScheduler();
      }
 else       if (!lastRenderClear.isEmpty() || !lines.isEmpty() || !logLines.isEmpty()) {
        Iterable<String> renderedLines=Iterables.concat(MoreIterables.zipAndConcat(logLines,Iterables.cycle("\n")),ansi.asNoWrap(MoreIterables.zipAndConcat(lines,Iterables.cycle("\n"))));
        int bufferSize=lastRenderClear.length();
        for (        String part : renderedLines) {
          bufferSize+=part.length();
        }
        StringBuilder fullFrame=new StringBuilder(bufferSize);
        fullFrame.append(lastRenderClear);
        for (        String part : renderedLines) {
          fullFrame.append(part);
        }
        console.getStdErr().getRawStream().print(fullFrame);
      }
    }
  }
}
