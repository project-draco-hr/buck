{
  String watchmanOutput=Joiner.on('\n').join("{","\"version\": \"2.9.2\",","\"clock\": \"c:1386170113:26390:5:50273\",","\"is_fresh_instance\": true,","\"files\": []","}");
  final Set<WatchEvent<?>> events=Sets.newHashSet();
  EventBus bus=new EventBus("watchman test");
  bus.register(new Object(){
    @Subscribe public void listen(    WatchEvent<?> event){
      events.add(event);
    }
  }
);
  FakeProcess fakeProcess=new FakeProcess(0,watchmanOutput,"");
  WatchmanWatcher watcher=createWatcher(bus,fakeProcess,new IncrementingFakeClock(),new ObjectMapper(),200,-1);
  watcher.postEvents(new BuckEventBus(new FakeClock(0),new BuildId()),ImmutableSet.<String>builder());
  boolean overflowSeen=false;
  for (  WatchEvent<?> event : events) {
    overflowSeen|=event.kind().equals(StandardWatchEventKinds.OVERFLOW);
  }
  assertTrue("Watchman query process should be destroyed.",fakeProcess.isDestroyed());
  assertTrue("Watchman query process should be waited for.",fakeProcess.isWaitedFor());
  assertTrue(overflowSeen);
}
