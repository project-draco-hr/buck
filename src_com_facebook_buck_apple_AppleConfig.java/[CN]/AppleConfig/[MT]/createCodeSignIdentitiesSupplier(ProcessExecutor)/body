{
  return Suppliers.memoize(new Supplier<ImmutableSet<CodeSignIdentity>>(){
    @Override public ImmutableSet<CodeSignIdentity> get(){
      ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(ImmutableList.of("security","find-identity","-v","-p","codesigning")).build();
      Set<ProcessExecutor.Option> options=EnumSet.of(ProcessExecutor.Option.EXPECTING_STD_OUT);
      ProcessExecutor.Result result;
      try {
        result=processExecutor.launchAndExecute(processExecutorParams,options,Optional.<String>absent(),Optional.<Long>absent(),Optional.<Function<Process,Void>>absent());
      }
 catch (      InterruptedException|IOException e) {
        LOG.warn("Could not execute security, continuing without codesign identity.");
        return ImmutableSet.of();
      }
      if (result.getExitCode() != 0) {
        throw new RuntimeException("security -v -p codesigning failed: " + result.getStderr());
      }
      Matcher matcher=CODE_SIGN_IDENTITY_PATTERN.matcher(result.getStdout().get());
      ImmutableSet.Builder<CodeSignIdentity> builder=ImmutableSet.builder();
      while (matcher.find()) {
        String hash=matcher.group(1);
        String fullName=matcher.group(2);
        CodeSignIdentity identity=CodeSignIdentity.builder().setHash(hash).setFullName(fullName).build();
        builder.add(identity);
        LOG.debug("Found code signing identity: " + identity.toString());
      }
      ImmutableSet<CodeSignIdentity> allValidIdentities=builder.build();
      if (allValidIdentities.isEmpty()) {
        LOG.warn("No valid code signing identities found.  Device build/install won't work.");
      }
 else       if (allValidIdentities.size() > 1) {
        LOG.warn("More than 1 valid identity found.  This could potentially " + "cause the wrong one to be used unless explicitly specified via CODE_SIGN_IDENTITY.");
      }
      return allValidIdentities;
    }
  }
);
}
