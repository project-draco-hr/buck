{
  ImmutableList.Builder<Step> commands=ImmutableList.builder();
  BuildTarget buildTarget=getBuildTarget();
  JavacOptions javacOptions=this.javacOptions;
  if (getProperties().is(ANDROID)) {
    javacOptions=JavacOptions.builder(this.javacOptions).setBootclasspath(context.getAndroidBootclasspathSupplier().get()).build();
  }
  androidResourceDeps=UberRDotJavaUtil.getAndroidResourceDeps(this,context.getDependencyGraph());
  boolean dependsOnAndroidResourceRules=!androidResourceDeps.isEmpty();
  if (dependsOnAndroidResourceRules) {
    UberRDotJavaUtil.createDummyRDotJavaFiles(androidResourceDeps,buildTarget,commands);
  }
  ImmutableSetMultimap<JavaLibraryRule,String> transitiveClasspathEntries=getTransitiveClasspathEntries();
  ImmutableSetMultimap<JavaLibraryRule,String> declaredClasspathEntries=getDeclaredClasspathEntries();
  if (dependsOnAndroidResourceRules) {
    ImmutableSetMultimap.Builder<JavaLibraryRule,String> transitiveClasspathEntriesWithRDotJava=ImmutableSetMultimap.builder();
    transitiveClasspathEntriesWithRDotJava.putAll(transitiveClasspathEntries);
    ImmutableSetMultimap.Builder<JavaLibraryRule,String> declaredClasspathEntriesWithRDotJava=ImmutableSetMultimap.builder();
    declaredClasspathEntriesWithRDotJava.putAll(declaredClasspathEntries);
    ImmutableSet<String> rDotJavaClasspath=ImmutableSet.of(UberRDotJavaUtil.getRDotJavaBinFolder(buildTarget));
    transitiveClasspathEntriesWithRDotJava.putAll(this,rDotJavaClasspath);
    declaredClasspathEntriesWithRDotJava.putAll(this,rDotJavaClasspath);
    declaredClasspathEntries=declaredClasspathEntriesWithRDotJava.build();
    transitiveClasspathEntries=transitiveClasspathEntriesWithRDotJava.build();
  }
  String annotationGenFolder=javacOptions.getAnnotationProcessingData().getGeneratedSourceFolderName();
  if (annotationGenFolder != null) {
    MakeCleanDirectoryStep mkdirGeneratedSources=new MakeCleanDirectoryStep(annotationGenFolder);
    commands.add(mkdirGeneratedSources);
  }
  String outputDirectory=getClassesDir(getBuildTarget());
  commands.add(new MakeCleanDirectoryStep(outputDirectory));
  Optional<DependencyCheckingJavacStep.SuggestBuildRules> suggestBuildRule=createSuggestBuildFunction(context,transitiveClasspathEntries,declaredClasspathEntries,JAR_RESOLVER);
  createCommandsForJavac(outputDirectory,ImmutableSet.copyOf(transitiveClasspathEntries.values()),ImmutableSet.copyOf(declaredClasspathEntries.values()),javacOptions,context.getBuildDependencies(),suggestBuildRule,commands);
  addResourceCommands(context,commands,outputDirectory,context.getJavaPackageFinder());
  if (outputJar.isPresent()) {
    commands.add(new MakeCleanDirectoryStep(getOutputJarDirPath(getBuildTarget())));
    commands.add(new JarDirectoryStep(outputJar.get(),Collections.singleton(outputDirectory),null,null));
  }
  Preconditions.checkNotNull(abiKeySupplier,"abiKeySupplier must be set so that getAbiKey() will " + "return a non-null value if this rule builds successfully.");
  addStepsToRecordAbiToDisk(commands,buildableContext);
  return commands.build();
}
