{
  BuildRuleResolver ruleResolver=new BuildRuleResolver();
  SourcePathResolver resolver=new SourcePathResolver(ruleResolver);
  BuildRule rule1=new FakeBuildRule(BuildTargetFactory.newInstance("//fake:rule1"),resolver){
    @Override @Nullable public Path getPathToOutputFile(){
      return Paths.get("buck-out/gen/fake/rule1.txt");
    }
  }
;
  BuildRule rule2=new FakeBuildRule(BuildTargetFactory.newInstance("//fake:rule2"),resolver);
  BuildRule rule3=new FakeBuildRule(BuildTargetFactory.newInstance("//fake:rule3"),resolver);
  List<BuildRule> rulesToBuild=ImmutableList.of(rule1,rule2,rule3);
  List<BuildRuleSuccess> results=Lists.newArrayList();
  results.add(new BuildRuleSuccess(rule1,Type.BUILT_LOCALLY));
  results.add(null);
  results.add(new BuildRuleSuccess(rule3,Type.FETCHED_FROM_CACHE));
  String expectedReport="\u001B[1m\u001B[42m\u001B[30mOK  \u001B[0m //fake:rule1 " + "BUILT_LOCALLY buck-out/gen/fake/rule1.txt\n" + "\u001B[1m\u001B[41m\u001B[37mFAIL\u001B[0m //fake:rule2\n"+ "\u001B[1m\u001B[42m\u001B[30mOK  \u001B[0m //fake:rule3 FETCHED_FROM_CACHE\n";
  String observedReport=BuildCommand.generateBuildReport(rulesToBuild,results,Ansi.forceTty());
  assertEquals(expectedReport,observedReport);
}
