{
  Optional<Map.Entry<Flavor,Type>> type;
  try {
    type=LIBRARY_TYPE.getFlavorAndValue(params.getBuildTarget().getFlavors());
  }
 catch (  FlavorDomainException e) {
    throw new HumanReadableException("%s: %s",params.getBuildTarget(),e.getMessage());
  }
  if (type.isPresent()) {
    Set<Flavor> flavors=Sets.newHashSet(params.getBuildTarget().getFlavors());
    flavors.remove(type.get().getKey());
    BuildTarget target=BuildTargets.extendFlavoredBuildTarget(params.getBuildTarget().getUnflavoredTarget(),flavors);
    BuildRuleParams typeParams=params.copyWithChanges(params.getBuildRuleType(),target,params.getDeclaredDeps(),params.getExtraDeps());
    if (type.get().getValue().equals(Type.HEADERS)) {
      return createHeaderSymlinkTreeBuildRule(typeParams,resolver,args);
    }
 else     if (type.get().getValue().equals(Type.SHARED)) {
      return createSharedLibraryBuildRule(typeParams,resolver,args);
    }
 else {
      return createStaticLibraryBuildRule(typeParams,resolver,args);
    }
  }
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  return new CxxLibrary(params,resolver,pathResolver,CxxPreprocessorFlags.fromArgs(args.propagatedPpFlags,args.propagatedLangPpFlags),CxxDescriptionEnhancer.parseHeaders(params,resolver,args),args.linkWhole.or(false),args.soname);
}
