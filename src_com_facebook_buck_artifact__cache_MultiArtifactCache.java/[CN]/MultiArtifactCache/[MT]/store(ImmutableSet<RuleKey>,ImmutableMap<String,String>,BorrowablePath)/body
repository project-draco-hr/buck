{
  List<ListenableFuture<Void>> storeFutures=Lists.newArrayListWithExpectedSize(writableArtifactCaches.size());
  for (  ArtifactCache artifactCache : writableArtifactCaches) {
    if (artifactCache.equals(writableArtifactCaches.get(writableArtifactCaches.size() - 1))) {
      output=BorrowablePath.borrowablePath(output.getPath());
    }
 else {
      output=BorrowablePath.notBorrowablePath(output.getPath());
    }
    storeFutures.add(artifactCache.store(ruleKeys,metadata,output));
  }
  return Futures.transformAsync(Futures.allAsList(storeFutures),new AsyncFunction<List<Void>,Void>(){
    @Override @Nullable public ListenableFuture<Void> apply(    List<Void> input) throws Exception {
      return null;
    }
  }
);
}
