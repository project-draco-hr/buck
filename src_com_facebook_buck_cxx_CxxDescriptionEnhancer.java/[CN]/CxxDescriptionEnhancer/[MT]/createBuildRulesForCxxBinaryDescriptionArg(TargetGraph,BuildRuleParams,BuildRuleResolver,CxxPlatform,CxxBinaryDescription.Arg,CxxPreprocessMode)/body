{
  ImmutableMap<String,CxxSource> srcs=parseCxxSources(params,resolver,cxxPlatform,args);
  ImmutableMap<Path,SourcePath> headers=parseHeaders(params,resolver,cxxPlatform,args);
  ImmutableMap<String,SourcePath> lexSrcs=parseLexSources(params,resolver,args);
  ImmutableMap<String,SourcePath> yaccSrcs=parseYaccSources(params,resolver,args);
  SourcePathResolver sourcePathResolver=new SourcePathResolver(resolver);
  Linker.LinkableDepType linkStyle=args.linkStyle.or(Linker.LinkableDepType.STATIC);
  Path linkOutput=getLinkOutputPath(params.getBuildTarget());
  ImmutableList.Builder<String> extraLdFlagsBuilder=ImmutableList.builder();
  CommandTool.Builder executableBuilder=new CommandTool.Builder();
  CxxHeaderSourceSpec lexYaccSources=requireLexYaccSources(params,resolver,sourcePathResolver,cxxPlatform,lexSrcs,yaccSrcs);
  HeaderSymlinkTree headerSymlinkTree=requireHeaderSymlinkTree(params,resolver,sourcePathResolver,cxxPlatform,true,lexSrcs,yaccSrcs,headers,HeaderVisibility.PRIVATE);
  ImmutableList<CxxPreprocessorInput> cxxPreprocessorInput=collectCxxPreprocessorInput(targetGraph,params,cxxPlatform,CxxFlags.getLanguageFlags(args.preprocessorFlags,args.platformPreprocessorFlags,args.langPreprocessorFlags,cxxPlatform),ImmutableList.of(headerSymlinkTree),getFrameworkSearchPaths(args.frameworks,cxxPlatform,new SourcePathResolver(resolver)),CxxPreprocessables.getTransitiveCxxPreprocessorInput(targetGraph,cxxPlatform,FluentIterable.from(params.getDeps()).filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
  ImmutableMap<String,CxxSource> sources=ImmutableMap.<String,CxxSource>builder().putAll(srcs).putAll(lexYaccSources.getCxxSources()).build();
  ImmutableMap<CxxPreprocessAndCompile,SourcePath> objects=CxxSourceRuleFactory.requirePreprocessAndCompileRules(params,resolver,sourcePathResolver,cxxPlatform,cxxPreprocessorInput,CxxFlags.getFlags(args.compilerFlags,args.platformCompilerFlags,cxxPlatform),args.prefixHeader,preprocessMode,sources,linkStyle == Linker.LinkableDepType.STATIC ? CxxSourceRuleFactory.PicType.PDC : CxxSourceRuleFactory.PicType.PIC);
  extraLdFlagsBuilder.addAll(CxxFlags.getFlags(args.linkerFlags,args.platformLinkerFlags,cxxPlatform));
  if (linkStyle == Linker.LinkableDepType.SHARED) {
    SymlinkTree sharedLibraries=resolver.addToIndex(createSharedLibrarySymlinkTree(targetGraph,params,sourcePathResolver,cxxPlatform,Predicates.instanceOf(NativeLinkable.class)));
    extraLdFlagsBuilder.addAll(Linkers.iXlinker("-rpath",String.format("%s/%s",cxxPlatform.getLd().origin(),linkOutput.getParent().relativize(sharedLibraries.getRoot()).toString())));
    executableBuilder.addDep(sharedLibraries);
    executableBuilder.addInputs(sharedLibraries.getLinks().values());
  }
  CxxLink cxxLink=CxxLinkableEnhancer.createCxxLinkableBuildRule(targetGraph,cxxPlatform,params,sourcePathResolver,extraLdFlagsBuilder.build(),createCxxLinkTarget(params.getBuildTarget()),Linker.LinkType.EXECUTABLE,Optional.<String>absent(),linkOutput,objects.values(),ImmutableList.<SourcePath>of(),linkStyle,params.getDeps(),args.cxxRuntimeType,Optional.<SourcePath>absent(),ImmutableSet.<BuildRule>of());
  resolver.addToIndex(cxxLink);
  executableBuilder.addArg(new BuildTargetSourcePath(cxxLink.getBuildTarget()));
  return new CxxLinkAndCompileRules(cxxLink,ImmutableSortedSet.copyOf(objects.keySet()),executableBuilder.build());
}
