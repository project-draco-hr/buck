{
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  ImmutableList<CxxSource> srcs=parseCxxSources(params.getBuildTarget(),pathResolver,args.srcs.or(ImmutableList.<SourcePath>of()));
  ImmutableMap<Path,SourcePath> headers=parseHeaders(params.getBuildTarget(),pathResolver,args.headerNamespace.transform(MorePaths.TO_PATH).or(params.getBuildTarget().getBasePath()),args.headers.or((ImmutableList.<SourcePath>of())));
  ImmutableMap<String,SourcePath> lexSrcs=pathResolver.getSourcePathNames(params.getBuildTarget(),"lexSrcs",args.lexSrcs.or(ImmutableList.<SourcePath>of()));
  ImmutableMap<String,SourcePath> yaccSrcs=pathResolver.getSourcePathNames(params.getBuildTarget(),"yaccSrcs",args.yaccSrcs.or(ImmutableList.<SourcePath>of()));
  CxxHeaderSourceSpec lexYaccSources=createLexYaccBuildRules(params,resolver,cxxPlatform,ImmutableList.<String>of(),lexSrcs,ImmutableList.<String>of(),yaccSrcs);
  SymlinkTree headerSymlinkTree=createHeaderSymlinkTreeBuildRule(params,resolver,headers);
  CxxPreprocessorInput cxxPreprocessorInput=combineCxxPreprocessorInput(params,cxxPlatform,args.preprocessorFlags.or(ImmutableList.<String>of()),headerSymlinkTree,ImmutableMap.<Path,SourcePath>builder().putAll(headers).putAll(lexYaccSources.getCxxHeaders()).build());
  ImmutableList<SourcePath> objects=createPreprocessAndCompileBuildRules(params,resolver,cxxPlatform,cxxPreprocessorInput,args.compilerFlags.or(ImmutableList.<String>of()),false,ImmutableList.<CxxSource>builder().addAll(srcs).addAll(lexYaccSources.getCxxSources()).build());
  Path output=getOutputPath(params.getBuildTarget());
  CxxLink cxxLink=CxxLinkableEnhancer.createCxxLinkableBuildRule(cxxPlatform,params,new SourcePathResolver(resolver),ImmutableList.<String>of(),ImmutableList.<String>of(),createCxxLinkTarget(params.getBuildTarget()),CxxLinkableEnhancer.LinkType.EXECUTABLE,Optional.<String>absent(),output,objects,NativeLinkable.Type.STATIC,params.getDeps());
  resolver.addToIndex(cxxLink);
  return cxxLink;
}
