{
  ImmutableMap<String,CxxSource> srcs=parseCxxSources(params,resolver,args);
  ImmutableMap<Path,SourcePath> headers=parseHeaders(params,resolver,args);
  ImmutableMap<String,SourcePath> lexSrcs=parseLexSources(params,resolver,args);
  ImmutableMap<String,SourcePath> yaccSrcs=parseYaccSources(params,resolver,args);
  CxxHeaderSourceSpec lexYaccSources=createLexYaccBuildRules(params,resolver,cxxPlatform,ImmutableList.<String>of(),lexSrcs,ImmutableList.<String>of(),yaccSrcs);
  SymlinkTree headerSymlinkTree=createHeaderSymlinkTreeBuildRule(params,resolver,cxxPlatform.asFlavor(),headers);
  CxxPreprocessorInput cxxPreprocessorInput=combineCxxPreprocessorInput(params,cxxPlatform,CxxPreprocessorFlags.fromArgs(args.preprocessorFlags,args.langPreprocessorFlags),headerSymlinkTree,ImmutableMap.<Path,SourcePath>builder().putAll(headers).putAll(lexYaccSources.getCxxHeaders()).build());
  ImmutableList<SourcePath> objects=createPreprocessAndCompileBuildRules(params,resolver,cxxPlatform,cxxPreprocessorInput,args.compilerFlags.or(ImmutableList.<String>of()),false,ImmutableMap.<String,CxxSource>builder().putAll(srcs).putAll(lexYaccSources.getCxxSources()).build());
  Path output=getOutputPath(params.getBuildTarget());
  CxxLink cxxLink=CxxLinkableEnhancer.createCxxLinkableBuildRule(cxxPlatform,params,new SourcePathResolver(resolver),ImmutableList.<String>of(),ImmutableList.<String>of(),createCxxLinkTarget(params.getBuildTarget()),CxxLinkableEnhancer.LinkType.EXECUTABLE,Optional.<String>absent(),output,objects,NativeLinkable.Type.STATIC,params.getDeps());
  resolver.addToIndex(cxxLink);
  return cxxLink;
}
