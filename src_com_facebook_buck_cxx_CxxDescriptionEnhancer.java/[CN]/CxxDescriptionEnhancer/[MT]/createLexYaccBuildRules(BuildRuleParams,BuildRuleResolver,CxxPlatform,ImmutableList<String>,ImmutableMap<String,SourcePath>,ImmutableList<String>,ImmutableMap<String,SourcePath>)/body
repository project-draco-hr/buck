{
  if (!lexSrcs.isEmpty() && !cxxPlatform.getLex().isPresent()) {
    throw new HumanReadableException("Platform %s must support lex to compile srcs %s",cxxPlatform,lexSrcs);
  }
  if (!yaccSrcs.isEmpty() && !cxxPlatform.getYacc().isPresent()) {
    throw new HumanReadableException("Platform %s must support yacc to compile srcs %s",cxxPlatform,yaccSrcs);
  }
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  ImmutableMap.Builder<String,CxxSource> lexYaccCxxSourcesBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<Path,SourcePath> lexYaccHeadersBuilder=ImmutableMap.builder();
  UnflavoredBuildTarget unflavoredBuildTarget=params.getBuildTarget().getUnflavoredBuildTarget();
  for (  ImmutableMap.Entry<String,SourcePath> ent : lexSrcs.entrySet()) {
    final String name=ent.getKey();
    final SourcePath source=ent.getValue();
    BuildTarget target=createLexBuildTarget(unflavoredBuildTarget,name);
    Path outputSource=getLexSourceOutputPath(unflavoredBuildTarget,name);
    Path outputHeader=getLexHeaderOutputPath(unflavoredBuildTarget,name);
    Lex lex=new Lex(params.copyWithChanges(target,Suppliers.ofInstance(ImmutableSortedSet.copyOf(pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),pathResolver,cxxPlatform.getLex().get(),ImmutableList.<String>builder().addAll(cxxPlatform.getLexFlags()).addAll(lexFlags).build(),outputSource,outputHeader,source);
    resolver.addToIndex(lex);
    lexYaccCxxSourcesBuilder.put(name + ".cc",CxxSource.of(CxxSource.Type.CXX,new BuildTargetSourcePath(lex.getBuildTarget(),outputSource),ImmutableList.<String>of()));
    lexYaccHeadersBuilder.put(params.getBuildTarget().getBasePath().resolve(name + ".h"),new BuildTargetSourcePath(lex.getBuildTarget(),outputHeader));
  }
  for (  ImmutableMap.Entry<String,SourcePath> ent : yaccSrcs.entrySet()) {
    final String name=ent.getKey();
    final SourcePath source=ent.getValue();
    BuildTarget target=createYaccBuildTarget(unflavoredBuildTarget,name);
    Path outputPrefix=getYaccOutputPrefix(unflavoredBuildTarget,Files.getNameWithoutExtension(name));
    Yacc yacc=new Yacc(params.copyWithChanges(target,Suppliers.ofInstance(ImmutableSortedSet.copyOf(pathResolver.filterBuildRuleInputs(ImmutableList.of(source)))),Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>of())),pathResolver,cxxPlatform.getYacc().get(),ImmutableList.<String>builder().addAll(cxxPlatform.getYaccFlags()).addAll(yaccFlags).build(),outputPrefix,source);
    resolver.addToIndex(yacc);
    lexYaccCxxSourcesBuilder.put(name + ".cc",CxxSource.of(CxxSource.Type.CXX,new BuildTargetSourcePath(yacc.getBuildTarget(),Yacc.getSourceOutputPath(outputPrefix)),ImmutableList.<String>of()));
    lexYaccHeadersBuilder.put(params.getBuildTarget().getBasePath().resolve(name + ".h"),new BuildTargetSourcePath(yacc.getBuildTarget(),Yacc.getHeaderOutputPath(outputPrefix)));
  }
  return CxxHeaderSourceSpec.of(lexYaccHeadersBuilder.build(),lexYaccCxxSourcesBuilder.build());
}
