{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  final Path pathToNativeLibs=getPathToNativeLibsDir();
  steps.add(new MakeCleanDirectoryStep(pathToNativeLibs));
  for (  Path nativeLibDir : nativeLibDirectories) {
    copyNativeLibrary(nativeLibDir,pathToNativeLibs,cpuFilters,steps);
  }
  for (  Map.Entry<Map.Entry<TargetCpuType,String>,Path> entry : filteredNativeLibraries.entrySet()) {
    Optional<String> abiDirectoryComponent=getAbiDirectoryComponent(entry.getKey().getKey());
    Preconditions.checkState(abiDirectoryComponent.isPresent());
    Path destination=pathToNativeLibs.resolve(abiDirectoryComponent.get()).resolve(entry.getKey().getValue());
    NdkCxxPlatform platform=Preconditions.checkNotNull(nativePlatforms.get(entry.getKey().getKey()));
    Path objcopy=getResolver().getPath(platform.getObjcopy());
    steps.add(new MkdirStep(destination.getParent()));
    steps.add(new ObjcopyStep(objcopy,ImmutableList.of("--strip-unneeded"),entry.getValue(),destination));
  }
  final Path pathToMetadataTxt=getPathToMetadataTxt();
  steps.add(new AbstractExecutionStep("hash_native_libs"){
    @Override public int execute(    ExecutionContext context){
      ProjectFilesystem filesystem=context.getProjectFilesystem();
      ImmutableList.Builder<String> metadataLines=ImmutableList.builder();
      try {
        for (        Path nativeLib : filesystem.getFilesUnderPath(pathToNativeLibs)) {
          String filesha1=filesystem.computeSha1(nativeLib);
          Path relativePath=pathToNativeLibs.relativize(nativeLib);
          metadataLines.add(String.format("%s %s",relativePath.toString(),filesha1));
        }
        filesystem.writeLinesToPath(metadataLines.build(),pathToMetadataTxt);
      }
 catch (      IOException e) {
        context.logError(e,"There was an error hashing native libraries.");
        return 1;
      }
      return 0;
    }
  }
);
  buildableContext.recordArtifactsInDirectory(pathToNativeLibs);
  buildableContext.recordArtifact(pathToMetadataTxt);
  return steps.build();
}
