{
  BuildTarget buildTarget=params.getBuildTarget();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  Optional<Map.Entry<Flavor,Type>> type=LIBRARY_TYPE.getFlavorAndValue(buildTarget);
  Optional<CxxPlatform> cxxPlatform=cxxPlatforms.getValue(buildTarget);
  if (type.isPresent()) {
    Preconditions.checkState(cxxPlatform.isPresent());
    BuildTarget baseTarget=params.getBuildTarget().withoutFlavors(Sets.union(Type.FLAVOR_VALUES,cxxPlatforms.getFlavors()));
switch (type.get().getValue()) {
case PACKAGE_SHARED:
case PACKAGE_STATIC:
case PACKAGE_STATIC_PIC:
      Linker.LinkableDepType depType;
    if (type.get().getValue().equals(Type.PACKAGE_SHARED)) {
      depType=Linker.LinkableDepType.SHARED;
    }
 else     if (type.get().getValue().equals(Type.PACKAGE_STATIC)) {
      depType=Linker.LinkableDepType.STATIC;
    }
 else {
      depType=Linker.LinkableDepType.STATIC_PIC;
    }
  return createPackage(params,resolver,pathResolver,cxxPlatform.get(),args,depType);
case SHARED:
return requireSharedLibrary(baseTarget,params,resolver,pathResolver,cxxPlatform.get(),args);
case STATIC_PIC:
case STATIC:
return requireStaticLibrary(baseTarget,params,resolver,pathResolver,cxxPlatform.get(),args,type.get().getValue() == Type.STATIC ? Linker.LinkableDepType.STATIC : Linker.LinkableDepType.STATIC_PIC);
}
throw new IllegalStateException(String.format("%s: unexpected type `%s`",params.getBuildTarget(),type.get().getValue()));
}
return new HaskellLibrary(params,pathResolver,resolver);
}
