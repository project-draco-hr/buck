{
  ProjectFilesystem projectFilesystem=EasyMock.createMock(ProjectFilesystem.class);
  EasyMock.expect(projectFilesystem.getProjectRoot()).andReturn(new File("."));
  BuildTargetParser buildTargetParser=new BuildTargetParser(projectFilesystem){
    @Override public BuildTarget parse(    String buildTargetName,    ParseContext parseContext) throws NoSuchBuildTargetException {
      return BuildTargetFactory.newInstance(buildTargetName);
    }
  }
;
  BuildFileTree buildFiles=EasyMock.createMock(BuildFileTree.class);
  EasyMock.replay(projectFilesystem,buildFiles);
  Map<String,BuildRuleBuilder> knownBuildTargets=createKnownBuildTargets();
  Parser parser=new Parser(projectFilesystem,buildFiles,buildTargetParser,knownBuildTargets);
  BuildTarget rootNode=BuildTargetFactory.newInstance("//:A");
  Iterable<BuildTarget> buildTargets=ImmutableSet.of(rootNode);
  Iterable<String> defaultIncludes=ImmutableList.of();
  try {
    parser.findAllTransitiveDependencies(buildTargets,defaultIncludes);
    fail("Should have thrown a HumanReadableException.");
  }
 catch (  HumanReadableException e) {
    assertEquals("Cycle found: //:C -> //:E -> //:F -> //:C",e.getMessage());
  }
  EasyMock.verify(projectFilesystem,buildFiles);
}
