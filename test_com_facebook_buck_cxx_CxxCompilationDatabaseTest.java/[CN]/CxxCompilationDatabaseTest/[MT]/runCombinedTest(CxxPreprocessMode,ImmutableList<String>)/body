{
  BuildTarget testBuildTarget=BuildTarget.builder(BuildTargetFactory.newInstance("//foo:baz")).addAllFlavors(ImmutableSet.of(CxxCompilationDatabase.COMPILATION_DATABASE)).build();
  BuildRuleParams testBuildRuleParams=new FakeBuildRuleParamsBuilder(testBuildTarget).setTargetGraph(TargetGraphFactory.newInstance(new CxxLibraryBuilder(testBuildTarget).build())).build();
  BuildRuleResolver testBuildRuleResolver=new BuildRuleResolver();
  SourcePathResolver testSourcePathResolver=new SourcePathResolver(testBuildRuleResolver);
  BuildTarget preprocessTarget=BuildTarget.builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget()).addFlavors(ImmutableFlavor.of("preprocess-test.cpp")).build();
  BuildTarget compileTarget=BuildTarget.builder(testBuildRuleParams.getBuildTarget().getUnflavoredBuildTarget()).addFlavors(ImmutableFlavor.of("compile-test.cpp")).build();
  ImmutableSortedSet.Builder<CxxPreprocessAndCompile> rules=ImmutableSortedSet.naturalOrder();
  CxxPreprocessAndCompileStep.Operation operation;
  BuildRuleParams compileBuildRuleParams;
switch (strategy) {
case SEPARATE:
    operation=CxxPreprocessAndCompileStep.Operation.COMPILE;
  CxxPreprocessAndCompile preprocessRule=new CxxPreprocessAndCompile(new FakeBuildRuleParamsBuilder(preprocessTarget).build(),testSourcePathResolver,operation,Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),Optional.of(ImmutableList.<String>of()),Optional.of(ImmutableList.<String>of()),Optional.<Compiler>absent(),Optional.<ImmutableList<String>>absent(),Optional.<ImmutableList<String>>absent(),Paths.get("test.o"),new TestSourcePath("test.cpp"),CxxSource.Type.CXX,ImmutableList.of(Paths.get("foo/bar"),Paths.get("test")),ImmutableList.<Path>of(),ImmutableList.<Path>of(),ImmutableList.<CxxHeaders>of(),CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER);
rules.add(preprocessRule);
compileBuildRuleParams=new FakeBuildRuleParamsBuilder(compileTarget).setDeps(ImmutableSortedSet.<BuildRule>of(preprocessRule)).build();
break;
case COMBINED:
operation=CxxPreprocessAndCompileStep.Operation.COMPILE_MUNGE_DEBUGINFO;
compileBuildRuleParams=new FakeBuildRuleParamsBuilder(compileTarget).build();
break;
case PIPED:
operation=CxxPreprocessAndCompileStep.Operation.PIPED_PREPROCESS_AND_COMPILE;
compileBuildRuleParams=new FakeBuildRuleParamsBuilder(compileTarget).build();
break;
default :
throw new RuntimeException("Invalid strategy");
}
rules.add(new CxxPreprocessAndCompile(compileBuildRuleParams,testSourcePathResolver,operation,Optional.<Tool>of(new HashedFileTool(Paths.get("preprocessor"))),Optional.of(ImmutableList.<String>of()),Optional.of(ImmutableList.<String>of()),Optional.<Compiler>of(new DefaultCompiler(new HashedFileTool(Paths.get("compiler")))),Optional.of(ImmutableList.<String>of()),Optional.of(ImmutableList.<String>of()),Paths.get("test.o"),new TestSourcePath("test.cpp"),CxxSource.Type.CXX,ImmutableList.of(Paths.get("foo/bar"),Paths.get("test")),ImmutableList.<Path>of(),ImmutableList.<Path>of(),ImmutableList.<CxxHeaders>of(),CxxPlatforms.DEFAULT_DEBUG_PATH_SANITIZER));
CxxCompilationDatabase compilationDatabase=CxxCompilationDatabase.createCompilationDatabase(testBuildRuleParams,testSourcePathResolver,strategy,rules.build());
assertEquals("getPathToOutput() should be a function of the build target.",Paths.get("buck-out/gen/foo/__baz#compilation-database.json"),compilationDatabase.getPathToOutput());
BuildContext buildContext=FakeBuildContext.NOOP_CONTEXT;
BuildableContext buildableContext=new FakeBuildableContext();
List<Step> buildSteps=compilationDatabase.getBuildSteps(buildContext,buildableContext);
assertEquals(2,buildSteps.size());
assertTrue(buildSteps.get(0) instanceof MkdirStep);
assertTrue(buildSteps.get(1) instanceof CxxCompilationDatabase.GenerateCompilationCommandsJson);
final String root="/Users/user/src";
final Path fakeRoot=Paths.get(root);
ProjectFilesystem projectFilesystem=new FakeProjectFilesystem(){
@Override public Path resolve(Path relativePath){
return fakeRoot.resolve(relativePath);
}
}
;
ExecutionContext context=TestExecutionContext.newBuilder().setProjectFilesystem(projectFilesystem).build();
CxxCompilationDatabase.GenerateCompilationCommandsJson step=(CxxCompilationDatabase.GenerateCompilationCommandsJson)buildSteps.get(1);
Iterable<CxxCompilationDatabaseEntry> observedEntries=step.createEntries(context);
Iterable<CxxCompilationDatabaseEntry> expectedEntries=ImmutableList.of(new CxxCompilationDatabaseEntry(root + "/foo",root + "/test.cpp",expectedArguments));
MoreAsserts.assertIterablesEquals(expectedEntries,observedEntries);
}
