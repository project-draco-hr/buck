{
  long entrySize=entry.getSize();
  if (entrySize <= 0) {
    return;
  }
  if (entrySize > zipSizeHardLimit) {
    throw new IllegalArgumentException("Single entry larger than limit: " + entry);
  }
  ZipOutputStreamHelper targetOut;
  boolean canFitAllRemaining=remainingSize + primaryOut.getCurrentSize() <= zipSizeHardLimit;
  if ((canFitAllRemaining && dexSplitStrategy == DexSplitStrategy.MAXIMIZE_PRIMARY_DEX_SIZE) || requiredInPrimaryZip.apply(entry.getRelativePath())) {
    if (!primaryOut.canPutEntry(entry)) {
      throw new IllegalArgumentException("Unable to fit all required files in primary zip.");
    }
    targetOut=primaryOut;
  }
 else {
    if (currentSecondaryOut == null || !currentSecondaryOut.canPutEntry(entry) || newSecondaryOutOnNextEntry) {
      if (currentSecondaryOut != null) {
        currentSecondaryOut.close();
      }
      currentSecondaryIndex++;
      File newSecondaryFile=new File(outSecondaryDir,String.format(secondaryPattern,currentSecondaryIndex));
      secondaryFiles.add(newSecondaryFile);
      currentSecondaryOut=newZipOutput(newSecondaryFile);
      newSecondaryOutOnNextEntry=false;
      Preconditions.checkState(currentSecondaryOut.canPutEntry(entry));
    }
    targetOut=currentSecondaryOut;
  }
  targetOut.putEntry(entry);
  remainingSize-=entrySize;
}
