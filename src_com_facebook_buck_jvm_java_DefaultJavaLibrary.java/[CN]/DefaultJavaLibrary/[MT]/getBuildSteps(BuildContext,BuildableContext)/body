{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  ImmutableSetMultimap<JavaLibrary,Path> declaredClasspathEntries=ImmutableSetMultimap.<JavaLibrary,Path>builder().putAll(getDeclaredClasspathEntries()).putAll(this,additionalClasspathEntries).build();
  BuildTarget target=getBuildTarget();
  Path outputDirectory=getClassesDir(target);
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),outputDirectory));
  SuggestBuildRules suggestBuildRule=DefaultSuggestBuildRules.createSuggestBuildFunction(JAR_RESOLVER,declaredClasspathEntries,ImmutableSetMultimap.<JavaLibrary,Path>builder().putAll(getTransitiveClasspathEntries()).putAll(this,additionalClasspathEntries).build(),context.getActionGraph().getNodes());
  Collection<Path> provided=JavaLibraryClasspathProvider.getJavaLibraryDeps(providedDeps).transformAndConcat(new Function<JavaLibrary,Collection<Path>>(){
    @Override public Collection<Path> apply(    JavaLibrary input){
      return input.getOutputClasspathEntries().values();
    }
  }
).filter(Predicates.notNull()).toSet();
  ImmutableSortedSet<Path> declared=ImmutableSortedSet.<Path>naturalOrder().addAll(declaredClasspathEntries.values()).addAll(provided).build();
  Step mkdir=new MakeCleanDirectoryStep(getProjectFilesystem(),getPathToAbiOutputDir());
  steps.add(mkdir);
  JavaPackageFinder finder=context.getJavaPackageFinder();
  if (resourcesRoot.isPresent()) {
    finder=new ResourcesRootPackageFinder(resourcesRoot.get(),finder);
  }
  steps.add(new CopyResourcesStep(getProjectFilesystem(),getResolver(),target,resources,outputDirectory,finder));
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),getOutputJarDirPath(target)));
  if (!getJavaSrcs().isEmpty()) {
    ClassUsageFileWriter usedClassesFileWriter;
    if (trackClassUsage) {
      final Path usedClassesFilePath=getUsedClassesFilePath(getBuildTarget());
      ClassUsageTracker classUsageTracker=new ClassUsageTracker();
      depFileListBuilder=new DependencyFileInputListBuilder(deps,classUsageTracker);
      usedClassesFileWriter=new DefaultClassUsageFileWriter(usedClassesFilePath,classUsageTracker);
      buildableContext.recordArtifact(usedClassesFilePath);
    }
 else {
      usedClassesFileWriter=NoOpClassUsageFileWriter.instance();
    }
    Path pathToSrcsList=BuildTargets.getGenPath(getBuildTarget(),"__%s__srcs");
    steps.add(new MkdirStep(getProjectFilesystem(),pathToSrcsList.getParent()));
    Path scratchDir=BuildTargets.getGenPath(target,"lib__%s____working_directory");
    steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),scratchDir));
    Optional<Path> workingDirectory=Optional.of(scratchDir);
    compileStepFactory.createCompileToJarStep(context,getJavaSrcs(),target,getResolver(),getProjectFilesystem(),declared,outputDirectory,workingDirectory,pathToSrcsList,Optional.of(suggestBuildRule),postprocessClassesCommands,ImmutableSortedSet.of(outputDirectory),Optional.<String>absent(),Optional.<Path>absent(),outputJar.get(),usedClassesFileWriter,steps,buildableContext);
  }
  Path abiJar=getOutputJarDirPath(target).resolve(String.format("%s-abi.jar",target.getShortNameAndFlavorPostfix()));
  if (outputJar.isPresent()) {
    Path output=outputJar.get();
    if (getJavaSrcs().isEmpty()) {
      steps.add(new JarDirectoryStep(getProjectFilesystem(),output,ImmutableSortedSet.of(outputDirectory),null,null));
    }
    buildableContext.recordArtifact(output);
    steps.add(new CalculateAbiStep(buildableContext,getProjectFilesystem(),output,abiJar));
  }
 else {
    Path scratch=BuildTargets.getScratchPath(target,String.format("%%s/%s-temp-abi.jar",target.getShortNameAndFlavorPostfix()));
    steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),scratch.getParent()));
    steps.add(new TouchStep(getProjectFilesystem(),scratch));
    steps.add(new CalculateAbiStep(buildableContext,getProjectFilesystem(),scratch,abiJar));
  }
  JavaLibraryRules.addAccumulateClassNamesStep(this,buildableContext,steps);
  return steps.build();
}
