{
  final Supplier<ImmutableList<JavaLibrary>> sortedTransitiveNotDeclaredDeps=Suppliers.memoize(new Supplier<ImmutableList<JavaLibrary>>(){
    @Override public ImmutableList<JavaLibrary> get(){
      ImmutableSetMultimap<JavaLibrary,Path> transitiveClasspathEntries=ImmutableSetMultimap.<JavaLibrary,Path>builder().putAll(getTransitiveClasspathEntries()).putAll(DefaultJavaLibrary.this,DefaultJavaLibrary.this.additionalClasspathEntries).build();
      Set<JavaLibrary> transitiveNotDeclaredDeps=Sets.difference(transitiveClasspathEntries.keySet(),Sets.union(ImmutableSet.of(this),declaredClasspathEntries.keySet()));
      DirectedAcyclicGraph<BuildRule> graph=BuildRuleDependencyVisitors.getBuildRuleDirectedGraphFilteredBy(context.getActionGraph().getNodes(),Predicates.instanceOf(JavaLibrary.class),Predicates.instanceOf(JavaLibrary.class));
      return FluentIterable.from(TopologicalSort.sort(graph,Predicates.<BuildRule>alwaysTrue())).filter(JavaLibrary.class).filter(Predicates.in(transitiveNotDeclaredDeps)).toList().reverse();
    }
  }
);
  SuggestBuildRules suggestBuildRuleFn=new SuggestBuildRules(){
    @Override public ImmutableSet<String> suggest(    ProjectFilesystem filesystem,    ImmutableSet<String> failedImports){
      ImmutableSet.Builder<String> suggestedDeps=ImmutableSet.builder();
      Set<String> remainingImports=Sets.newHashSet(failedImports);
      for (      JavaLibrary transitiveNotDeclaredDep : sortedTransitiveNotDeclaredDeps.get()) {
        if (isMissingBuildRule(filesystem,transitiveNotDeclaredDep,remainingImports,jarResolver)) {
          suggestedDeps.add(transitiveNotDeclaredDep.getFullyQualifiedName());
        }
        if (remainingImports.isEmpty()) {
          break;
        }
      }
      return suggestedDeps.build();
    }
  }
;
  return Optional.of(suggestBuildRuleFn);
}
