{
  this.doStore=doStore;
  this.buckEventBus=Preconditions.checkNotNull(buckEventBus);
  this.numConnectionExceptionReports=new AtomicInteger(0);
  final AstyanaxContext<Keyspace> context=new AstyanaxContext.Builder().forCluster(clusterName).forKeyspace(keyspaceName).withAstyanaxConfiguration(new AstyanaxConfigurationImpl().setCqlVersion("3.0.0").setTargetCassandraVersion("1.2").setDiscoveryType(NodeDiscoveryType.RING_DESCRIBE)).withConnectionPoolConfiguration(new ConnectionPoolConfigurationImpl(poolName).setSeeds(hosts).setPort(port).setMaxConnsPerHost(1)).withConnectionPoolMonitor(new CountingConnectionPoolMonitor()).buildKeyspace(ThriftFamilyFactory.getInstance());
  ExecutorService connectionService=MoreExecutors.getExitingExecutorService((ThreadPoolExecutor)Executors.newFixedThreadPool(1),0,TimeUnit.SECONDS);
  this.keyspaceAndTtlFuture=connectionService.submit(new Callable<KeyspaceAndTtl>(){
    @Override public KeyspaceAndTtl call() throws ConnectionException {
      context.start();
      Keyspace keyspace=context.getClient();
      try {
        verifyMagic(keyspace);
        int ttl=getTtl(keyspace);
        return new KeyspaceAndTtl(keyspace,ttl);
      }
 catch (      ConnectionException e) {
        reportConnectionFailure("Attempting to get keyspace and ttl from server.",e);
        throw e;
      }
    }
  }
);
  this.futures=Sets.newSetFromMap(new ConcurrentHashMap<ListenableFuture<OperationResult<Void>>,Boolean>());
  this.isWaitingToClose=new AtomicBoolean(false);
}
