{
  RuleKey ruleKey;
  if (canSkipRebuildIfInterfacesOfDepsAreUnchanged()) {
    ruleKey=null;
  }
 else {
    ruleKey=getRuleKey();
    Optional<RuleKey> cachedRuleKey=getRuleKeyOnDisk(context.getProjectFilesystem());
    if (cachedRuleKey.isPresent() && ruleKey.equals(cachedRuleKey.get())) {
      logger.info(String.format("[UNCHANGED %s]",getFullyQualifiedName()));
      buildRuleResult.set(new BuildRuleSuccess(this,BuildRuleSuccess.Type.MATCHING_RULE_KEY));
      return;
    }
  }
  Preconditions.checkNotNull(ruleKey,"ruleKey must be set by the preceding codepath.");
  context.getEventBus().post(BuildEvents.started(this));
  File output=getOutput();
  boolean fromCache=(output != null && context.getArtifactCache().fetch(getRuleKey(),output));
  CacheResult cacheResult=fromCache ? CacheResult.HIT : CacheResult.MISS;
  if (!fromCache) {
    try {
      executeCommandsNowThatDepsAreBuilt(context);
    }
 catch (    IOException|StepFailedException e) {
      buildRuleResult.setException(e);
      BuildEvents.finished(this,BuildRuleStatus.FAIL,cacheResult);
      return;
    }
  }
  try {
    recordBuildRuleCompleted(context.getProjectFilesystem(),context.getArtifactCache(),fromCache);
  }
 catch (  IOException e) {
    buildRuleResult.setException(e);
    BuildEvents.finished(this,BuildRuleStatus.FAIL,cacheResult);
    return;
  }
  BuildRuleSuccess.Type successType=fromCache ? BuildRuleSuccess.Type.FETCHED_FROM_CACHE : BuildRuleSuccess.Type.BUILT_LOCALLY;
  buildRuleResult.set(new BuildRuleSuccess(this,successType));
  context.getEventBus().post(BuildEvents.finished(this,BuildRuleStatus.SUCCESS,cacheResult));
  return;
}
