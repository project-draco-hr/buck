{
  ImmutableList.Builder<Step> stepsBuilder=ImmutableList.builder();
  Path metadataPath=getMetadataPath();
  Path infoPlistInputPath=getResolver().deprecatedGetPath(infoPlist);
  Path infoPlistSubstitutionTempPath=BuildTargets.getScratchPath(getBuildTarget(),"%s.plist");
  Path infoPlistOutputPath=metadataPath.resolve("Info.plist");
  stepsBuilder.add(new MakeCleanDirectoryStep(getProjectFilesystem(),bundleRoot),new MkdirStep(getProjectFilesystem(),metadataPath),new WriteFileStep(getProjectFilesystem(),"APPLWRUN",metadataPath.resolve("PkgInfo"),false),new MkdirStep(getProjectFilesystem(),infoPlistSubstitutionTempPath.getParent()),new FindAndReplaceStep(getProjectFilesystem(),infoPlistInputPath,infoPlistSubstitutionTempPath,InfoPlistSubstitution.createVariableExpansionFunction(withDefaults(infoPlistSubstitutions,ImmutableMap.of("EXECUTABLE_NAME",binaryName,"PRODUCT_NAME",binaryName)))),new PlistProcessStep(getProjectFilesystem(),infoPlistSubstitutionTempPath,infoPlistOutputPath,getInfoPlistAdditionalKeys(platformName,sdkName),getInfoPlistOverrideKeys(platformName),PlistProcessStep.OutputFormat.BINARY));
  if (hasBinary) {
    stepsBuilder.add(new MkdirStep(getProjectFilesystem(),bundleRoot.resolve(this.destinations.getExecutablesPath())));
    Path bundleBinaryPath=bundleRoot.resolve(binaryPath);
    stepsBuilder.add(CopyStep.forFile(getProjectFilesystem(),binary.get().getPathToOutput(),bundleBinaryPath));
    if (debugInfoFormat == DebugInfoFormat.DSYM) {
      buildableContext.recordArtifact(dsymPath);
      stepsBuilder.add(new DsymStep(getProjectFilesystem(),dsymutil.getCommandPrefix(getResolver()),bundleBinaryPath,dsymPath));
    }
    stepsBuilder.add(new DefaultShellStep(getProjectFilesystem().getRootPath(),ImmutableList.<String>builder().addAll(strip.getCommandPrefix(getResolver())).add("-S").add(getProjectFilesystem().resolve(bundleBinaryPath).toString()).build()));
  }
  Path bundleDestinationPath=bundleRoot.resolve(this.destinations.getResourcesPath());
  for (  SourcePath dir : resourceDirs) {
    stepsBuilder.add(new MkdirStep(getProjectFilesystem(),bundleDestinationPath));
    stepsBuilder.add(CopyStep.forDirectory(getProjectFilesystem(),getResolver().deprecatedGetPath(dir),bundleDestinationPath,CopyStep.DirectoryMode.DIRECTORY_AND_CONTENTS));
  }
  for (  SourcePath dir : dirsContainingResourceDirs) {
    stepsBuilder.add(new MkdirStep(getProjectFilesystem(),bundleDestinationPath));
    stepsBuilder.add(CopyStep.forDirectory(getProjectFilesystem(),getResolver().deprecatedGetPath(dir),bundleDestinationPath,CopyStep.DirectoryMode.CONTENTS_ONLY));
  }
  for (  SourcePath file : resourceFiles) {
    stepsBuilder.add(new MkdirStep(getProjectFilesystem(),bundleDestinationPath));
    Path resolvedFilePath=getResolver().deprecatedGetPath(file);
    Path destinationPath=bundleDestinationPath.resolve(resolvedFilePath.getFileName());
    addResourceProcessingSteps(resolvedFilePath,destinationPath,stepsBuilder);
  }
  addStepsToCopyExtensionBundlesDependencies(stepsBuilder);
  if (resourceVariantFiles.isPresent()) {
    for (    SourcePath variantSourcePath : resourceVariantFiles.get()) {
      Path variantFilePath=getResolver().deprecatedGetPath(variantSourcePath);
      Path variantDirectory=variantFilePath.getParent();
      if (variantDirectory == null || !variantDirectory.toString().endsWith(".lproj")) {
        throw new HumanReadableException("Variant files have to be in a directory with name ending in '.lproj', " + "but '%s' is not.",variantFilePath);
      }
      Path bundleVariantDestinationPath=bundleDestinationPath.resolve(variantDirectory.getFileName());
      stepsBuilder.add(new MkdirStep(getProjectFilesystem(),bundleVariantDestinationPath));
      Path destinationPath=bundleVariantDestinationPath.resolve(variantFilePath.getFileName());
      addResourceProcessingSteps(variantFilePath,destinationPath,stepsBuilder);
    }
  }
  if (assetCatalog.isPresent()) {
    Path bundleDir=assetCatalog.get().getOutputDir();
    stepsBuilder.add(CopyStep.forDirectory(getProjectFilesystem(),bundleDir,bundleRoot,CopyStep.DirectoryMode.CONTENTS_ONLY));
  }
  if (codeSignIdentity.isPresent()) {
    Optional<Path> entitlementsPlist=Optional.absent();
    final Path srcRoot=getProjectFilesystem().getRootPath().resolve(getBuildTarget().getBasePath());
    Optional<String> entitlementsPlistString=InfoPlistSubstitution.getVariableExpansionForPlatform(CODE_SIGN_ENTITLEMENTS,platformName,withDefaults(infoPlistSubstitutions,ImmutableMap.of("SOURCE_ROOT",srcRoot.toString(),"SRCROOT",srcRoot.toString())));
    if (entitlementsPlistString.isPresent()) {
      entitlementsPlist=Optional.of(srcRoot.resolve(Paths.get(entitlementsPlistString.get())));
    }
    final Path signingEntitlementsTempPath=BuildTargets.getScratchPath(getBuildTarget(),"%s.xcent");
    stepsBuilder.add(new ProvisioningProfileCopyStep(getProjectFilesystem(),infoPlistOutputPath,Optional.<String>absent(),entitlementsPlist,provisioningProfileStore,bundleDestinationPath.resolve("embedded.mobileprovision"),signingEntitlementsTempPath));
    stepsBuilder.add(new CodeSignStep(getProjectFilesystem().getRootPath(),bundleDestinationPath,signingEntitlementsTempPath,codeSignIdentity.get().getFingerprint()));
  }
  buildableContext.recordArtifact(getPathToOutput());
  return stepsBuilder.build();
}
