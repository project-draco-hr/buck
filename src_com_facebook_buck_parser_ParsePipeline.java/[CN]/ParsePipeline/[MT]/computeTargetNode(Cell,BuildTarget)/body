{
  final ListenableFuture<Path> buildFile=Futures.transformAsync(Futures.immediateFuture(buildTarget),new AsyncFunction<BuildTarget,Path>(){
    @Override public ListenableFuture<Path> apply(    BuildTarget input) throws Exception {
      Path buildFile=cell.getAbsolutePathToBuildFile(buildTarget);
      Preconditions.checkState(buildFile.isAbsolute());
      return Futures.immediateFuture(buildFile);
    }
  }
);
  ListenableFuture<ImmutableList<Map<String,Object>>> rawNodes=Futures.transformAsync(buildFile,new AsyncFunction<Path,ImmutableList<Map<String,Object>>>(){
    @Override public ListenableFuture<ImmutableList<Map<String,Object>>> apply(    Path buildFile){
      return getRawNodesJob(cell,buildFile);
    }
  }
,executorService);
  final ListenableFuture<Map<String,Object>> rawNode=Futures.transformAsync(rawNodes,new AsyncFunction<ImmutableList<Map<String,Object>>,Map<String,Object>>(){
    @Override public ListenableFuture<Map<String,Object>> apply(    ImmutableList<Map<String,Object>> rawNodes){
      Optional<Map<String,Object>> rawNode=selectRawNode(buildTarget,rawNodes);
      if (!rawNode.isPresent()) {
        Path buildFilePath=Futures.getUnchecked(buildFile);
        throw new HumanReadableException(NoSuchBuildTargetException.createForMissingBuildRule(buildTarget,BuildTargetPatternParser.forBaseName(buildTarget.getBaseName()),cell.getBuildFileName(),"Defined in file: " + buildFilePath));
      }
      return Futures.immediateFuture(rawNode.get());
    }
  }
);
  ListenableFuture<TargetNode<?>> targetNodeFuture=Futures.transformAsync(buildFile,new AsyncFunction<Path,TargetNode<?>>(){
    @Override public ListenableFuture<TargetNode<?>> apply(    Path buildFile){
      return computeTargetNode(cell,buildTarget,buildFile,rawNode);
    }
  }
);
  if (speculativeDepsTraversal) {
    Futures.addCallback(targetNodeFuture,new FutureCallback<TargetNode<?>>(){
      @Override public void onSuccess(      TargetNode<?> result){
        for (        BuildTarget depTarget : result.getDeps()) {
          Path depCellPath=depTarget.getCellPath();
          if (depCellPath.equals(cell.getRoot())) {
            try {
              getTargetNodeJob(cell,depTarget);
            }
 catch (            BuildTargetException e) {
              LOG.info(e,"Could not schedule speculative parsing for %s",depTarget);
            }
          }
        }
      }
      @Override public void onFailure(      Throwable t){
      }
    }
,executorService);
  }
  return targetNodeFuture;
}
