{
  final ListenableFuture<Path> buildFile=Futures.transformAsync(Futures.immediateFuture(buildTarget),new AsyncFunction<BuildTarget,Path>(){
    @Override public ListenableFuture<Path> apply(    BuildTarget input) throws Exception {
      Path buildFile=cell.getAbsolutePathToBuildFile(buildTarget);
      Preconditions.checkState(buildFile.isAbsolute());
      return Futures.immediateFuture(buildFile);
    }
  }
);
  ListenableFuture<ImmutableList<Map<String,Object>>> rawNodes=Futures.transformAsync(buildFile,new AsyncFunction<Path,ImmutableList<Map<String,Object>>>(){
    @Override public ListenableFuture<ImmutableList<Map<String,Object>>> apply(    Path buildFile){
      return getRawNodesJob(cell,buildFile);
    }
  }
,executorService);
  final ListenableFuture<Map<String,Object>> rawNode=Futures.transformAsync(rawNodes,new AsyncFunction<ImmutableList<Map<String,Object>>,Map<String,Object>>(){
    @Override public ListenableFuture<Map<String,Object>> apply(    ImmutableList<Map<String,Object>> rawNodes){
      Optional<Map<String,Object>> rawNode=selectRawNode(buildTarget,rawNodes);
      if (!rawNode.isPresent()) {
        Path buildFilePath=Futures.getUnchecked(buildFile);
        throw new HumanReadableException(NoSuchBuildTargetException.createForMissingBuildRule(buildTarget,BuildTargetPatternParser.forBaseName(buildTarget.getBaseName()),cell.getBuildFileName(),"Defined in file: " + buildFilePath));
      }
      return Futures.immediateFuture(rawNode.get());
    }
  }
);
  ListenableFuture<TargetNode<?>> targetNodeFuture=Futures.transformAsync(buildFile,new AsyncFunction<Path,TargetNode<?>>(){
    @Override public ListenableFuture<TargetNode<?>> apply(    Path buildFile){
      return computeTargetNode(cell,buildTarget,buildFile,rawNode);
    }
  }
);
  return targetNodeFuture;
}
