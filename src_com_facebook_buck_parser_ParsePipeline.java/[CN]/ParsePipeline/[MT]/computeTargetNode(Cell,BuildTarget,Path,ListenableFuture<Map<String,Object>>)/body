{
  ListenableFuture<TargetNode<?>> targetNodeFuture=Futures.transformAsync(rawNode,new AsyncFunction<Map<String,Object>,TargetNode<?>>(){
    @Override public ListenableFuture<TargetNode<?>> apply(    Map<String,Object> rawNode) throws BuildTargetException {
      if (shuttingDown.get()) {
        return Futures.immediateCancelledFuture();
      }
      try (SimplePerfEvent.Scope scope=Parser.getTargetNodeEventScope(buckEventBus,buildTarget)){
        TargetNode<?> targetNode=delegate.createTargetNode(cell,buildFile,buildTarget,rawNode);
        return Futures.<TargetNode<?>>immediateFuture(cache.putTargetNodeIfNotPresent(cell,buildTarget,targetNode));
      }
     }
  }
,executorService);
  if (speculativeDepsTraversal) {
    Futures.addCallback(targetNodeFuture,new FutureCallback<TargetNode<?>>(){
      @Override public void onSuccess(      TargetNode<?> result){
        for (        BuildTarget depTarget : result.getDeps()) {
          Path depCellPath=depTarget.getCellPath();
          if (depCellPath.equals(cell.getRoot())) {
            try {
              getTargetNodeJob(cell,depTarget);
            }
 catch (            BuildTargetException e) {
              LOG.info(e,"Could not schedule speculative parsing for %s",depTarget);
            }
          }
        }
      }
      @Override public void onFailure(      Throwable t){
      }
    }
,executorService);
  }
  return targetNodeFuture;
}
