{
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxLibraryBuilder.createDefaultPlatform();
  String genHeaderName="test/foo.h";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance("//:genHeader");
  GenruleBuilder genHeaderBuilder=GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName);
  genHeaderBuilder.build(resolver);
  String genSourceName="test/foo.cpp";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance("//:genSource");
  GenruleBuilder genSourceBuilder=GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName);
  genSourceBuilder.build(resolver);
  final BuildRule header=new FakeBuildRule("//:header",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule("//:symlink",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get("symlink/tree/root");
  final BuildRule privateHeader=new FakeBuildRule("//:header-private",pathResolver);
  final BuildRule privateHeaderSymlinkTree=new FakeBuildRule("//:symlink-private",pathResolver);
  final Path privateHeaderSymlinkTreeRoot=Paths.get("private/symlink/tree/root");
  final BuildRule archive=new FakeBuildRule("//:archive",pathResolver);
  BuildTarget depTarget=BuildTargetFactory.newInstance("//:dep");
  BuildRuleParams depParams=new FakeBuildRuleParamsBuilder(depTarget).build();
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    TargetGraph targetGraph,    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
switch (headerVisibility) {
case PUBLIC:
        return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
case PRIVATE:
      return CxxPreprocessorInput.builder().addRules(privateHeader.getBuildTarget(),privateHeaderSymlinkTree.getBuildTarget()).addIncludeRoots(privateHeaderSymlinkTreeRoot).build();
  }
  throw new RuntimeException("Invalid header visibility: " + headerVisibility);
}
@Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(TargetGraph targetGraph,CxxPlatform cxxPlatform,HeaderVisibility headerVisibility){
  return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(targetGraph,cxxPlatform,headerVisibility));
}
@Override public Iterable<NativeLinkable> getNativeLinkableDeps(CxxPlatform cxxPlatform){
  return FluentIterable.from(getDeclaredDeps()).filter(NativeLinkable.class);
}
@Override public Iterable<NativeLinkable> getNativeLinkableExportedDeps(CxxPlatform cxxPlatform){
  return FluentIterable.from(getDeclaredDeps()).filter(NativeLinkable.class);
}
@Override public NativeLinkableInput getNativeLinkableInput(TargetGraph targetGraph,CxxPlatform cxxPlatform,Linker.LinkableDepType type){
  return NativeLinkableInput.of(ImmutableList.<Arg>of(new SourcePathArg(getResolver(),new BuildTargetSourcePath(archive.getBuildTarget()))),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
}
@Override public NativeLinkable.Linkage getPreferredLinkage(CxxPlatform cxxPlatform){
  return Linkage.ANY;
}
@Override public PythonPackageComponents getPythonPackageComponents(TargetGraph targetGraph,PythonPlatform pythonPlatform,CxxPlatform cxxPlatform){
  return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
}
@Override public Iterable<AndroidPackageable> getRequiredPackageables(){
  return ImmutableList.of();
}
@Override public void addToCollector(AndroidPackageableCollector collector){
}
@Override public ImmutableMap<String,SourcePath> getSharedLibraries(TargetGraph targetGraph,CxxPlatform cxxPlatform){
  return ImmutableMap.of();
}
@Override public boolean isTestedBy(BuildTarget buildTarget){
  return false;
}
}
;
resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,privateHeader,privateHeaderSymlinkTree,archive,dep));
FakeProjectFilesystem filesystem=new FakeProjectFilesystem();
BuildTarget target=BuildTargetFactory.newInstance("//:rule");
CxxSourceRuleFactory cxxSourceRuleFactory=CxxSourceRuleFactoryHelper.of(filesystem.getRootPath(),target,cxxPlatform);
String headerName="test/bar.h";
String privateHeaderName="test/bar_private.h";
CxxLibraryBuilder cxxLibraryBuilder=(CxxLibraryBuilder)new CxxLibraryBuilder(target).setExportedHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(headerName),new BuildTargetSourcePath(genHeaderTarget))).setHeaders(ImmutableSortedSet.<SourcePath>of(new TestSourcePath(privateHeaderName))).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(new TestSourcePath("test/bar.cpp")),SourceWithFlags.of(new BuildTargetSourcePath(genSourceTarget)))).setFrameworks(ImmutableSortedSet.of(FrameworkPath.ofSourcePath(new TestSourcePath("/some/framework/path/s.dylib")),FrameworkPath.ofSourcePath(new TestSourcePath("/another/framework/path/a.dylib")))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
TargetGraph targetGraph=TargetGraphFactory.newInstance(cxxLibraryBuilder.build(),genSourceBuilder.build(),genHeaderBuilder.build(),GenruleBuilder.newGenruleBuilder(depTarget).build());
CxxLibrary rule=(CxxLibrary)cxxLibraryBuilder.build(resolver,filesystem,targetGraph);
Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(headerName),new TestSourcePath(headerName)).putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).putFullNameToPathMap(headerRoot.resolve(headerName),new TestSourcePath(headerName)).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeaderTarget)).build()).addIncludeRoots(getHeaderSymlinkTreeIncludePath(target,cxxPlatform,HeaderVisibility.PUBLIC)).addAllHeaderMaps(getHeaderMaps(target,cxxPlatform,HeaderVisibility.PUBLIC)).addFrameworks(FrameworkPath.ofSourcePath(new PathSourcePath(filesystem,Paths.get("/some/framework/path/s.dylib"))),FrameworkPath.ofSourcePath(new PathSourcePath(filesystem,Paths.get("/another/framework/path/a.dylib")))).build(),rule.getCxxPreprocessorInput(targetGraph,cxxPlatform,HeaderVisibility.PUBLIC));
Path privateHeaderRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE);
assertEquals(CxxPreprocessorInput.builder().addRules(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)).setIncludes(CxxHeaders.builder().putNameToPathMap(Paths.get(privateHeaderName),new TestSourcePath(privateHeaderName)).putFullNameToPathMap(privateHeaderRoot.resolve(privateHeaderName),new TestSourcePath(privateHeaderName)).build()).addIncludeRoots(getHeaderSymlinkTreeIncludePath(target,cxxPlatform,HeaderVisibility.PRIVATE)).addAllHeaderMaps(getHeaderMaps(target,cxxPlatform,HeaderVisibility.PRIVATE)).addFrameworks(FrameworkPath.ofSourcePath(new PathSourcePath(filesystem,Paths.get("/some/framework/path/s.dylib"))),FrameworkPath.ofSourcePath(new PathSourcePath(filesystem,Paths.get("/another/framework/path/a.dylib")))).build(),rule.getCxxPreprocessorInput(targetGraph,cxxPlatform,HeaderVisibility.PRIVATE));
rule.getNativeLinkableInput(targetGraph,cxxPlatform,Linker.LinkableDepType.STATIC);
BuildRule archiveRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.getFlavor(),CxxSourceRuleFactory.PicType.PDC));
assertNotNull(archiveRule);
assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget("test/bar.cpp",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC)),FluentIterable.from(archiveRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget("test/bar.cpp",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget("test/bar.cpp",CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule1);
assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PUBLIC)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
assertNotNull(compileRule2);
assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}
