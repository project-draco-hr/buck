{
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  String sourceName="test/bar.cpp";
  String genHeaderName="test/foo.h";
  GenruleDescription genHeaderDescription=new GenruleDescription();
  GenruleDescription.Arg genHeaderArg=createEmptyGenruleDescriptionArg();
  genHeaderArg.out=genHeaderName;
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance("//:genHeader");
  Genrule genHeader=(Genrule)GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName).build(resolver);
  String genSourceName="test/foo.cpp";
  GenruleDescription genSourceDescription=new GenruleDescription();
  GenruleDescription.Arg genSourceArg=createEmptyGenruleDescriptionArg();
  genHeaderArg.out=genSourceName;
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance("//:genSource");
  Genrule genSource=(Genrule)GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName).build(resolver);
  final BuildRule header=new FakeBuildRule("//:header",pathResolver);
  final BuildRule headerSymlinkTree=new FakeBuildRule("//:symlink",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get("symlink/tree/root");
  final BuildRule staticLibraryDep=new FakeBuildRule("//:static",pathResolver);
  final Path staticLibraryOutput=Paths.get("output/path/lib.a");
  final BuildRule sharedLibraryDep=new FakeBuildRule("//:shared",pathResolver);
  final Path sharedLibraryOutput=Paths.get("output/path/lib.so");
  final String sharedLibrarySoname="soname";
  BuildTarget depTarget=BuildTargetFactory.newInstance("//:dep");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform){
      return CxxPreprocessorInput.builder().setRules(ImmutableSet.of(header.getBuildTarget(),headerSymlinkTree.getBuildTarget())).setIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Type type){
      return type == Type.STATIC ? new NativeLinkableInput(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(staticLibraryDep.getBuildTarget())),ImmutableList.of(staticLibraryOutput.toString())) : new NativeLinkableInput(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibraryDep.getBuildTarget())),ImmutableList.of(sharedLibraryOutput.toString()));
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return new PythonPackageComponents(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(sharedLibraryOutput)));
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,staticLibraryDep,sharedLibraryDep));
  BuildTarget target=BuildTargetFactory.newInstance("//:rule");
  FakeBuckConfig buckConfig=new FakeBuckConfig();
  CxxBuckConfig cxxBuckConfig=new CxxBuckConfig(buckConfig);
  CxxPlatform cxxPlatform=new DefaultCxxPlatform(buckConfig);
  FlavorDomain<CxxPlatform> cxxPlatforms=new FlavorDomain<>("C/C++ Platform",ImmutableMap.of(cxxPlatform.asFlavor(),cxxPlatform));
  CxxLibraryDescription description=new CxxLibraryDescription(cxxBuckConfig,cxxPlatforms);
  CxxLibraryDescription.Arg arg=description.createEmptyConstructorArg();
  arg.headers=Optional.of(Either.<ImmutableList<SourcePath>,ImmutableMap<String,SourcePath>>ofRight(ImmutableMap.<String,SourcePath>of(genHeaderName,new BuildTargetSourcePath(genHeader.getBuildTarget()))));
  arg.srcs=Optional.of(Either.<ImmutableList<SourcePath>,ImmutableMap<String,SourcePath>>ofRight(ImmutableMap.<String,SourcePath>of(sourceName,new TestSourcePath(sourceName),genSourceName,new BuildTargetSourcePath(genSource.getBuildTarget()))));
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setTargetGraph(TargetGraphFactory.newInstance(createTargetNode(target,description,arg),createTargetNode(genSource.getBuildTarget(),genSourceDescription,genSourceArg),createTargetNode(genHeader.getBuildTarget(),genHeaderDescription,genHeaderArg))).setDeps(ImmutableSortedSet.<BuildRule>of(dep)).build();
  CxxLibrary rule=(CxxLibrary)description.createBuildRule(params,resolver,arg);
  Path headerRoot=CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.asFlavor());
  assertEquals(CxxPreprocessorInput.builder().setRules(ImmutableSet.of(CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor()))).setIncludes(ImmutableCxxHeaders.builder().putNameToPathMap(Paths.get(genHeaderName),new BuildTargetSourcePath(genHeader.getBuildTarget())).putFullNameToPathMap(headerRoot.resolve(genHeaderName),new BuildTargetSourcePath(genHeader.getBuildTarget())).build()).setIncludeRoots(ImmutableList.of(CxxDescriptionEnhancer.getHeaderSymlinkTreePath(target,cxxPlatform.asFlavor()))).build(),rule.getCxxPreprocessorInput(cxxPlatform));
  rule.getNativeLinkableInput(cxxPlatform,NativeLinkable.Type.STATIC);
  BuildRule staticRule=resolver.getRule(CxxDescriptionEnhancer.createStaticLibraryBuildTarget(target,cxxPlatform.asFlavor()));
  assertNotNull(staticRule);
  assertEquals(ImmutableSet.of(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",false),CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,false)),FluentIterable.from(staticRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule1=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,false,"test/bar.cpp"));
  assertNotNull(staticPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(staticPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule1=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",false));
  assertNotNull(staticCompileRule1);
  assertEquals(ImmutableSet.of(staticPreprocessRule1.getBuildTarget()),FluentIterable.from(staticCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticPreprocessRule2=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,false,genSourceName));
  assertNotNull(staticPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(staticPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule staticCompileRule2=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,false));
  assertNotNull(staticCompileRule2);
  assertEquals(ImmutableSet.of(staticPreprocessRule2.getBuildTarget()),FluentIterable.from(staticCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  rule.getNativeLinkableInput(cxxPlatform,NativeLinkable.Type.SHARED);
  BuildRule sharedRule=resolver.getRule(CxxDescriptionEnhancer.createSharedLibraryBuildTarget(target,cxxPlatform.asFlavor()));
  assertNotNull(sharedRule);
  assertEquals(ImmutableSet.of(sharedLibraryDep.getBuildTarget(),CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",true),CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,true)),FluentIterable.from(sharedRule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule1=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,true,"test/bar.cpp"));
  assertNotNull(sharedPreprocessRule1);
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(sharedPreprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule1=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",true));
  assertNotNull(sharedCompileRule1);
  assertEquals(ImmutableSet.of(sharedPreprocessRule1.getBuildTarget()),FluentIterable.from(sharedCompileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedPreprocessRule2=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,true,genSourceName));
  assertNotNull(sharedPreprocessRule2);
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(sharedPreprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule sharedCompileRule2=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,true));
  assertNotNull(sharedCompileRule2);
  assertEquals(ImmutableSet.of(sharedPreprocessRule2.getBuildTarget()),FluentIterable.from(sharedCompileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  PythonPackageComponents expectedPythonPackageComponents=new PythonPackageComponents(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(CxxDescriptionEnhancer.getSharedLibrarySoname(target,cxxPlatform)),new BuildTargetSourcePath(sharedRule.getBuildTarget())));
  assertEquals(expectedPythonPackageComponents,rule.getPythonPackageComponents(cxxPlatform));
}
