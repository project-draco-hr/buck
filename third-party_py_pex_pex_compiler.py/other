from __future__ import absolute_import
import contextlib
import os
import subprocess
import tempfile
from .compatibility import to_bytes
_COMPILER_MAIN = "\nfrom __future__ import print_function\n\nimport os\nimport py_compile\nimport sys\n\n\ndef compile(root, relpaths):\n  compiled = []\n  errored = {}\n  for relpath in relpaths:\n    abspath = os.path.join(root, relpath)\n    # NB: We give the compiled bytecode file a `.pyc` extension, but if PYTHONOPTIMIZE is in play\n    # the generated bytecode will be optimized.  Traditionally these optimized bytecode files would\n    # have a `.pyo` extension, but the extension only matters for location of the file to execute\n    # for a given module and not on the interpretation of its bytecode contents.  As such we're\n    # safe to pick the `.pyc` extension for all bytecode file cases without a need to interpret the\n    # current optimization setting for the active python interpreter.\n    pyc_relpath = relpath + 'c'\n    pyc_abspath = os.path.join(root, pyc_relpath)\n    try:\n      py_compile.compile(abspath, cfile=pyc_abspath, dfile=relpath, doraise=True)\n      compiled.append(pyc_relpath)\n    except py_compile.PyCompileError as e:\n      errored[e.file] = e.msg\n  return compiled, errored\n\n\ndef main(root, relpaths):\n  compiled, errored = compile(root, relpaths)\n  if not errored:\n    for path in compiled:\n      print(path)\n    sys.exit(0)\n\n  print('Encountered %%d errors compiling %%d files:' %% (len(errored), len(relpaths)),\n        file=sys.stderr)\n  for file, msg in errored.items():\n    print('  %%s: %%s' %% (file, msg), file=sys.stderr)\n  sys.exit(1)\n\nroot = %(root)r\nrelpaths = %(relpaths)r\n\nmain(root, relpaths)\n"
