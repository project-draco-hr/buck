{
  context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule));
  final OnDiskBuildInfo onDiskBuildInfo=context.createOnDiskBuildInfoFor(rule.getBuildTarget());
  final BuildInfoRecorder buildInfoRecorder=context.createBuildInfoRecorder(rule.getBuildTarget()).addBuildMetadata(BuildInfo.METADATA_KEY_FOR_RULE_KEY,rule.getRuleKey().toString()).addBuildMetadata(BuildInfo.METADATA_KEY_FOR_RULE_KEY_WITHOUT_DEPS,rule.getRuleKeyWithoutDeps().toString());
  final BuildableContext buildableContext=new DefaultBuildableContext(buildInfoRecorder);
  ListenableFuture<BuildResult> buildResult=processBuildRule(rule,context,onDiskBuildInfo,buildInfoRecorder,buildableContext,asyncCallbacks);
  if (buildMode == BuildMode.DEEP) {
    buildResult=MoreFutures.chainExceptions(getDepResults(rule,context,asyncCallbacks),buildResult);
  }
  AsyncFunction<BuildResult,BuildResult> callback=new AsyncFunction<BuildResult,BuildResult>(){
    @Override public ListenableFuture<BuildResult> apply(    @Nonnull BuildResult input) throws Exception {
      BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
      if (rule instanceof HasPostBuildSteps && (success == BuildRuleSuccessType.BUILT_LOCALLY || success == BuildRuleSuccessType.FETCHED_FROM_CACHE || success == BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED)) {
        executePostBuildSteps(rule,((HasPostBuildSteps)rule).getPostBuildSteps(context,buildableContext),context);
      }
      if (success != BuildRuleSuccessType.BUILT_LOCALLY) {
        for (        String str : onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_RECORDED_PATHS).get()) {
          buildInfoRecorder.recordArtifact(Paths.get(str));
        }
      }
      buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_TARGET,rule.getBuildTarget().toString());
      buildInfoRecorder.addMetadata(BuildInfo.METADATA_KEY_FOR_RECORDED_PATHS,FluentIterable.from(buildInfoRecorder.getRecordedPaths()).transform(Functions.toStringFunction()));
      if (success.shouldWriteRecordedMetadataToDiskAfterBuilding()) {
        try {
          boolean clearExistingMetadata=success.shouldClearAndOverwriteMetadataOnDisk();
          buildInfoRecorder.writeMetadataToDisk(clearExistingMetadata);
        }
 catch (        IOException e) {
          throw new IOException(String.format("Failed to write metadata to disk for %s.",rule),e);
        }
      }
      try {
        if (rule instanceof InitializableFromDisk) {
          doInitializeFromDisk((InitializableFromDisk<?>)rule,onDiskBuildInfo);
        }
      }
 catch (      IOException e) {
        throw new IOException(String.format("Error initializing %s from disk.",rule),e);
      }
      return Futures.immediateFuture(input);
    }
  }
;
  buildResult=Futures.transform(buildResult,callback);
  final SettableFuture<BuildResult> result=SettableFuture.create();
  asyncCallbacks.add(MoreFutures.addListenableCallback(buildResult,new FutureCallback<BuildResult>(){
    @Override public void onSuccess(    BuildResult input){
      BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
      result.set(input);
      Set<RuleKey> ruleKeys=Sets.newHashSet();
      if (success.shouldUploadResultingArtifact()) {
        ruleKeys.add(rule.getRuleKey());
      }
      if (rule instanceof SupportsInputBasedRuleKey && success.shouldUploadResultingArtifactInputBased()) {
        ruleKeys.add(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY).get());
      }
      if (!ruleKeys.isEmpty()) {
        try {
          buildInfoRecorder.performUploadToArtifactCache(ImmutableSet.copyOf(ruleKeys),context.getArtifactCache(),context.getEventBus());
        }
 catch (        Throwable t) {
          onFailure(t);
          return;
        }
      }
      Pair<Long,HashCode> outputHashAndSize;
      try {
        outputHashAndSize=buildInfoRecorder.getOutputSizeAndHash(Hashing.md5());
      }
 catch (      IOException e) {
        onFailure(e);
        return;
      }
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.finished(rule,BuildRuleStatus.SUCCESS,input.getCacheResult(),Optional.of(input.getSuccess()),Optional.of(outputHashAndSize.getSecond()),Optional.of(outputHashAndSize.getFirst())));
    }
    @Override public void onFailure(    @Nonnull Throwable thrown){
      try {
        onDiskBuildInfo.deleteExistingMetadata();
      }
 catch (      Throwable t) {
        context.getEventBus().post(ThrowableConsoleEvent.create(t,"Error when deleting metadata for %s.",rule));
      }
      result.setException(thrown);
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.finished(rule,BuildRuleStatus.FAIL,CacheResult.miss(),Optional.<BuildRuleSuccessType>absent(),Optional.<HashCode>absent(),Optional.<Long>absent()));
      if (thrown instanceof InterruptedException) {
        Thread.currentThread().interrupt();
      }
    }
  }
));
  return result;
}
