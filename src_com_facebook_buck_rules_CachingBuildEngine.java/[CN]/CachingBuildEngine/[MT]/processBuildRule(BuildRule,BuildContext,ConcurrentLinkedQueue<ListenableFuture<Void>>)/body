{
  context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule));
  final OnDiskBuildInfo onDiskBuildInfo=context.createOnDiskBuildInfoFor(rule.getBuildTarget());
  final BuildInfoRecorder buildInfoRecorder=context.createBuildInfoRecorder(rule.getBuildTarget()).addBuildMetadata(BuildInfo.METADATA_KEY_FOR_RULE_KEY,rule.getRuleKey().toString()).addBuildMetadata(BuildInfo.METADATA_KEY_FOR_RULE_KEY_WITHOUT_DEPS,rule.getRuleKeyWithoutDeps().toString());
  final BuildableContext buildableContext=new DefaultBuildableContext(buildInfoRecorder);
  ListenableFuture<BuildResult> buildResult=processBuildRule(rule,context,onDiskBuildInfo,buildInfoRecorder,buildableContext,asyncCallbacks);
  if (buildMode == BuildMode.DEEP) {
    buildResult=MoreFutures.chainExceptions(getDepResults(rule,context,asyncCallbacks),buildResult);
  }
  AsyncFunction<BuildResult,BuildResult> callback=new AsyncFunction<BuildResult,BuildResult>(){
    @Override public ListenableFuture<BuildResult> apply(    @Nonnull BuildResult input) throws Exception {
      if (input.getStatus() != BuildRuleStatus.SUCCESS) {
        return Futures.immediateFuture(input);
      }
      BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
      if (success != BuildRuleSuccessType.BUILT_LOCALLY) {
        for (        String str : onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_RECORDED_PATHS).get()) {
          buildInfoRecorder.recordArtifact(Paths.get(str));
        }
      }
      if (success.outputsHaveChanged()) {
        if (rule instanceof HasPostBuildSteps) {
          executePostBuildSteps(rule,((HasPostBuildSteps)rule).getPostBuildSteps(context,buildableContext),context);
        }
        for (        Path path : buildInfoRecorder.getRecordedPaths()) {
          fileHashCache.invalidate(path);
        }
      }
      if (useDependencyFileRuleKey(rule) && success == BuildRuleSuccessType.BUILT_LOCALLY) {
        ImmutableList<Path> inputs=((SupportsDependencyFileRuleKey)rule).getInputsAfterBuildingLocally();
        for (        Path path : inputs) {
          Preconditions.checkState(!path.isAbsolute(),String.format("%s: reported absolute path as an input: %s",rule.getBuildTarget(),path));
        }
        ImmutableList<String> inputStrings=FluentIterable.from(inputs).transform(Functions.toStringFunction()).toList();
        buildInfoRecorder.addMetadata(BuildInfo.METADATA_KEY_FOR_DEP_FILE,inputStrings);
        Optional<RuleKey> depFileRuleKey=calculateDepFileRuleKey(rule,Optional.of(inputStrings),false);
        Preconditions.checkState(depFileRuleKey.isPresent());
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY,depFileRuleKey.get().toString());
      }
      buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_TARGET,rule.getBuildTarget().toString());
      buildInfoRecorder.addMetadata(BuildInfo.METADATA_KEY_FOR_RECORDED_PATHS,FluentIterable.from(buildInfoRecorder.getRecordedPaths()).transform(Functions.toStringFunction()));
      if (success.shouldWriteRecordedMetadataToDiskAfterBuilding()) {
        try {
          boolean clearExistingMetadata=success.shouldClearAndOverwriteMetadataOnDisk();
          buildInfoRecorder.writeMetadataToDisk(clearExistingMetadata);
        }
 catch (        IOException e) {
          throw new IOException(String.format("Failed to write metadata to disk for %s.",rule),e);
        }
      }
      try {
        if (rule instanceof InitializableFromDisk) {
          doInitializeFromDisk((InitializableFromDisk<?>)rule,onDiskBuildInfo);
        }
      }
 catch (      IOException e) {
        throw new IOException(String.format("Error initializing %s from disk.",rule),e);
      }
      return Futures.immediateFuture(input);
    }
  }
;
  buildResult=Futures.transform(buildResult,callback);
  final SettableFuture<BuildResult> result=SettableFuture.create();
  asyncCallbacks.add(MoreFutures.addListenableCallback(buildResult,new FutureCallback<BuildResult>(){
    private void cleanupAfterError(){
      try {
        onDiskBuildInfo.deleteExistingMetadata();
      }
 catch (      Throwable t) {
        context.getEventBus().post(ThrowableConsoleEvent.create(t,"Error when deleting metadata for %s.",rule));
      }
    }
    private void uploadToCache(    BuildRuleSuccessType success){
      Set<RuleKey> ruleKeys=Sets.newHashSet();
      if (success.shouldUploadResultingArtifact()) {
        ruleKeys.add(rule.getRuleKey());
      }
      if (rule instanceof SupportsInputBasedRuleKey && success.shouldUploadResultingArtifactInputBased()) {
        ruleKeys.add(onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY).get());
      }
      if (!ruleKeys.isEmpty()) {
        try {
          buildInfoRecorder.performUploadToArtifactCache(ImmutableSet.copyOf(ruleKeys),context.getArtifactCache(),context.getEventBus());
        }
 catch (        Throwable t) {
          context.getEventBus().post(ThrowableConsoleEvent.create(t,"Error uploading to cache for %s.",rule));
        }
      }
    }
    private void handleResult(    BuildResult input){
      Optional<Long> outputSize=Optional.absent();
      Optional<HashCode> outputHash=Optional.absent();
      Optional<BuildRuleSuccessType> successType=Optional.absent();
      if (input.getStatus() == BuildRuleStatus.FAIL) {
        firstFailure=input.getFailure();
        cleanupAfterError();
      }
      result.set(input);
      if (input.getStatus() == BuildRuleStatus.SUCCESS) {
        BuildRuleSuccessType success=Preconditions.checkNotNull(input.getSuccess());
        successType=Optional.of(success);
        uploadToCache(success);
        try {
          outputSize=Optional.of(buildInfoRecorder.getOutputSize());
          outputHash=Optional.of(buildInfoRecorder.getOutputHash(fileHashCache));
        }
 catch (        IOException e) {
          context.getEventBus().post(ThrowableConsoleEvent.create(e,"Error getting output hash and size for %s.",rule));
        }
      }
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.finished(rule,input.getStatus(),input.getCacheResult(),successType,outputHash,outputSize));
    }
    @Override public void onSuccess(    BuildResult input){
      handleResult(input);
    }
    @Override public void onFailure(    @Nonnull Throwable thrown){
      handleResult(BuildResult.failure(rule,thrown));
      if (thrown instanceof InterruptedException) {
        Thread.currentThread().interrupt();
      }
    }
  }
));
  return result;
}
