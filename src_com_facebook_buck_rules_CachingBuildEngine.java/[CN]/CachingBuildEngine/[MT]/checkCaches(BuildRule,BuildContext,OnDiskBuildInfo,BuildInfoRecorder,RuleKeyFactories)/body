{
  return new AsyncFunction<List<BuildResult>,Optional<BuildResult>>(){
    @Override public ListenableFuture<Optional<BuildResult>> apply(    List<BuildResult> depResults) throws InterruptedException, IOException {
      for (      BuildResult depResult : depResults) {
        if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && depResult.getStatus() != BuildRuleStatus.SUCCESS) {
          return Futures.immediateFuture(Optional.of(BuildResult.canceled(rule,Preconditions.checkNotNull(depResult.getFailure()))));
        }
      }
      if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && !context.isKeepGoing() && firstFailure != null) {
        return Futures.immediateFuture(Optional.of(BuildResult.canceled(rule,firstFailure)));
      }
      ListenableFuture<Optional<BuildResult>> inputResult=performInputBasedCacheFetch(rule,context,onDiskBuildInfo,buildInfoRecorder,ruleKeyFactory);
      return Futures.transformAsync(inputResult,new AsyncFunction<Optional<BuildResult>,Optional<BuildResult>>(){
        @Override public ListenableFuture<Optional<BuildResult>> apply(        Optional<BuildResult> result) throws InterruptedException, IOException {
          if (result.isPresent()) {
            return Futures.immediateFuture(result);
          }
          if (useDependencyFileRuleKey(rule)) {
            Optional<Pair<RuleKey,ImmutableSet<SourcePath>>> depFileRuleKeyAndInputs=calculateDepFileRuleKey(rule,onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_DEP_FILE),true);
            if (depFileRuleKeyAndInputs.isPresent()) {
              RuleKey depFileRuleKey=depFileRuleKeyAndInputs.get().getFirst();
              buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY,depFileRuleKey.toString());
              Optional<RuleKey> lastDepFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY);
              if (lastDepFileRuleKey.isPresent() && depFileRuleKey.equals(lastDepFileRuleKey.get())) {
                return Futures.immediateFuture(Optional.of(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_DEP_FILE_RULE_KEY,CacheResult.localKeyUnchangedHit())));
              }
            }
          }
          ListenableFuture<Optional<BuildResult>> manifestResult=performManifestBasedCacheFetch(rule,context,buildInfoRecorder);
          return Futures.transform(manifestResult,new Function<Optional<BuildResult>,Optional<BuildResult>>(){
            @Override public Optional<BuildResult> apply(            Optional<BuildResult> result){
              if (result.isPresent()) {
                return result;
              }
              Optional<BuildResult> abiResult=performAbiBasedCacheFetch(rule,ruleKeyFactory,buildInfoRecorder,onDiskBuildInfo);
              if (abiResult.isPresent()) {
                return abiResult;
              }
              if (buildMode == BuildMode.POPULATE_FROM_REMOTE_CACHE) {
                LOG.info("Cannot populate cache for " + rule.getBuildTarget().getFullyQualifiedName());
                return Optional.of(BuildResult.canceled(rule,new HumanReadableException("Skipping %s: in cache population mode local builds are disabled",rule)));
              }
              return Optional.absent();
            }
          }
,service);
        }
      }
,service);
    }
  }
;
}
