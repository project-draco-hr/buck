{
  return new AsyncFunction<List<BuildResult>,Optional<BuildResult>>(){
    @Override public ListenableFuture<Optional<BuildResult>> apply(    List<BuildResult> depResults) throws InterruptedException, IOException {
      for (      BuildResult depResult : depResults) {
        if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && depResult.getStatus() != BuildRuleStatus.SUCCESS) {
          return Futures.immediateFuture(Optional.of(BuildResult.canceled(rule,Preconditions.checkNotNull(depResult.getFailure()))));
        }
      }
      if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && !context.isKeepGoing() && firstFailure != null) {
        return Futures.immediateFuture(Optional.of(BuildResult.canceled(rule,firstFailure)));
      }
      if (useDependencyFileRuleKey(rule)) {
        Optional<Pair<RuleKey,ImmutableSet<SourcePath>>> depFileRuleKeyAndInputs=calculateDepFileRuleKey(rule,onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_DEP_FILE),true);
        if (depFileRuleKeyAndInputs.isPresent()) {
          RuleKey depFileRuleKey=depFileRuleKeyAndInputs.get().getFirst();
          Optional<RuleKey> lastDepFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY);
          if (lastDepFileRuleKey.isPresent() && depFileRuleKey.equals(lastDepFileRuleKey.get())) {
            return Futures.immediateFuture(Optional.of(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_DEP_FILE_RULE_KEY,CacheResult.localKeyUnchangedHit())));
          }
        }
      }
      ListenableFuture<Optional<BuildResult>> manifestResult=performManifestBasedCacheFetch(rule,context,buildInfoRecorder);
      return Futures.transformAsync(manifestResult,new AsyncFunction<Optional<BuildResult>,Optional<BuildResult>>(){
        @Override public ListenableFuture<Optional<BuildResult>> apply(        Optional<BuildResult> result) throws InterruptedException {
          if (result.isPresent()) {
            return Futures.immediateFuture(result);
          }
          ListenableFuture<Optional<BuildResult>> inputResult=performInputBasedCacheFetch(rule,context,onDiskBuildInfo,buildInfoRecorder,ruleKeyFactory);
          return Futures.transformAsync(inputResult,new AsyncFunction<Optional<BuildResult>,Optional<BuildResult>>(){
            @Override public ListenableFuture<Optional<BuildResult>> apply(            Optional<BuildResult> result){
              if (result.isPresent()) {
                return Futures.immediateFuture(result);
              }
              if (rule instanceof AbiRule) {
                RuleKey abiRuleKey=ruleKeyFactory.abiRuleKeyBuilderFactory.build(rule);
                buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY,abiRuleKey.toString());
                Optional<RuleKey> lastAbiRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY);
                if (abiRuleKey.equals(lastAbiRuleKey.orNull())) {
                  return Futures.immediateFuture(Optional.of(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_ABI_RULE_KEY,CacheResult.localKeyUnchangedHit())));
                }
              }
              if (buildMode == BuildMode.POPULATE_FROM_REMOTE_CACHE) {
                LOG.info("Cannot populate cache for " + rule.getBuildTarget().getFullyQualifiedName());
                return Futures.immediateFuture(Optional.of(BuildResult.canceled(rule,new HumanReadableException("Skipping %s: in cache population mode local " + "builds are disabled",rule))));
              }
              return Futures.immediateFuture(Optional.<BuildResult>absent());
            }
          }
,service);
        }
      }
,service);
    }
  }
;
}
