{
  final SettableFuture<BuildRuleSuccess> newFuture=SettableFuture.create();
  SettableFuture<BuildRuleSuccess> existingFuture=results.putIfAbsent(rule.getBuildTarget(),newFuture);
  if (existingFuture != null) {
    return existingFuture;
  }
  try {
    List<ListenableFuture<BuildRuleSuccess>> builtDeps=Lists.newArrayListWithCapacity(rule.getDeps().size());
    for (    BuildRule dep : rule.getDeps()) {
      builtDeps.add(buildInternal(context,dep,asyncJobs));
    }
    ListenableFuture<List<BuildRuleSuccess>> allBuiltDeps=Futures.allAsList(builtDeps);
    ListenableFuture<Void> callbackFuture=context.getStepRunner().addCallback(allBuiltDeps,new FutureCallback<List<BuildRuleSuccess>>(){
      private final BuckEventBus eventBus=context.getEventBus();
      private final OnDiskBuildInfo onDiskBuildInfo=context.createOnDiskBuildInfoFor(rule.getBuildTarget());
      /** 
 * It is imperative that:
 * <ol>
 * <li>The {@link BuildInfoRecorder} is not constructed until all of the{@link BuildRule}'s {@code deps} are guaranteed to be built. This ensures that
 * the {@link RuleKey} will be available before the {@link BuildInfoRecorder} is
 * constructed.
 * <p>
 * This is why a {@link Supplier} is used.
 * <li>Only one {@link BuildInfoRecorder} is created per {@link BuildRule}. This
 * ensures that all build-related information for a {@link BuildRule} goes though
 * a single recorder, whose data will be persisted in {@link #onSuccess(List)}.
 * <p>
 * This is why {@link Suppliers#memoize(Supplier)} is used.
 * </ol>
 */
      private final Supplier<BuildInfoRecorder> buildInfoRecorder=Suppliers.memoize(new Supplier<BuildInfoRecorder>(){
        @Override public BuildInfoRecorder get(){
          RuleKey ruleKey;
          RuleKey ruleKeyWithoutDeps;
          ruleKey=rule.getRuleKey();
          ruleKeyWithoutDeps=rule.getRuleKeyWithoutDeps();
          return context.createBuildInfoRecorder(rule.getBuildTarget(),ruleKey,ruleKeyWithoutDeps);
        }
      }
);
      private boolean startOfBuildWasRecordedOnTheEventBus=false;
      @Override public void onSuccess(      List<BuildRuleSuccess> deps){
        eventBus.logVerboseAndPost(LOG,BuildRuleEvent.started(rule));
        startOfBuildWasRecordedOnTheEventBus=true;
        BuildResult result=null;
        try {
          ruleKeys.putIfAbsent(rule.getBuildTarget(),rule.getRuleKey());
          result=buildOnceDepsAreBuilt(rule,context,onDiskBuildInfo,buildInfoRecorder.get(),shouldTryToFetchFromCache(rule));
          if (result.getStatus() == BuildRuleStatus.SUCCESS) {
            recordBuildRuleSuccess(result);
          }
        }
 catch (        InterruptedException|RuntimeException e) {
          result=new BuildResult(e);
        }
        if (result.getStatus() == BuildRuleStatus.FAIL) {
          recordBuildRuleFailure(result);
          if (result.getFailure() instanceof InterruptedException) {
            Thread.currentThread().interrupt();
          }
        }
      }
      private void recordBuildRuleSuccess(      BuildResult result) throws InterruptedException {
        BuildRuleSuccess.Type success=result.getSuccess();
        if (success != null && success.shouldWriteRecordedMetadataToDiskAfterBuilding()) {
          try {
            boolean clearExistingMetadata=success.shouldClearAndOverwriteMetadataOnDisk();
            buildInfoRecorder.get().writeMetadataToDisk(clearExistingMetadata);
          }
 catch (          IOException e) {
            eventBus.post(ThrowableConsoleEvent.create(e,"Failed to write metadata to disk for %s.",rule));
            onFailure(e);
            return;
          }
        }
        doHydrationAfterBuildStepsFinish(rule,onDiskBuildInfo);
        BuildRuleSuccess buildRuleSuccess=new BuildRuleSuccess(rule,result.getSuccess());
        newFuture.set(buildRuleSuccess);
        if (success != null && success.shouldUploadResultingArtifact()) {
          buildInfoRecorder.get().performUploadToArtifactCache(context.getArtifactCache(),eventBus);
        }
        logBuildRuleFinished(result);
      }
      @Override public void onFailure(      Throwable failure){
        recordBuildRuleFailure(new BuildResult(failure));
      }
      private void recordBuildRuleFailure(      BuildResult result){
        try {
          onDiskBuildInfo.deleteExistingMetadata();
        }
 catch (        IOException e) {
          eventBus.post(ThrowableConsoleEvent.create(e,"Error when deleting metadata for %s.",rule));
        }
        if (startOfBuildWasRecordedOnTheEventBus) {
          logBuildRuleFinished(result);
        }
        newFuture.setException(Preconditions.checkNotNull(result.getFailure()));
      }
      private void logBuildRuleFinished(      BuildResult result){
        eventBus.logVerboseAndPost(LOG,BuildRuleEvent.finished(rule,result.getStatus(),result.getCacheResult(),Optional.fromNullable(result.getSuccess())));
      }
    }
,service);
    asyncJobs.add(callbackFuture);
  }
 catch (  Throwable failure) {
    newFuture.setException(failure);
  }
  return newFuture;
}
