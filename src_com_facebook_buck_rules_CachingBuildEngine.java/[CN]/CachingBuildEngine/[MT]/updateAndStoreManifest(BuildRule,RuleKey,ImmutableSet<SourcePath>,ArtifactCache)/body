{
  Preconditions.checkState(useManifestCaching(rule));
  Pair<RuleKey,ImmutableSet<SourcePath>> manifestKey=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem()).depFileRuleKeyBuilderFactory.buildManifestKey(rule);
  final Path manifestPath=getManifestPath(rule);
  Manifest manifest=new Manifest();
  if (rule.getProjectFilesystem().exists(manifestPath)) {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath)){
      manifest=new Manifest(inputStream);
    }
   }
  if (manifest.size() >= maxDepFileCacheEntries) {
    manifest=new Manifest();
  }
  manifest.addEntry(fileHashCaches.getUnchecked(rule.getProjectFilesystem()),key,pathResolver,manifestKey.getSecond(),inputs);
  try (OutputStream outputStream=rule.getProjectFilesystem().newFileOutputStream(manifestPath)){
    manifest.serialize(outputStream);
  }
   final NamedTemporaryFile tempFile=new NamedTemporaryFile("buck.",".manifest");
  try {
    try (InputStream inputStream=rule.getProjectFilesystem().newFileInputStream(manifestPath);OutputStream outputStream=new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(tempFile.get())))){
      ByteStreams.copy(inputStream,outputStream);
    }
     cache.store(ImmutableSet.of(manifestKey.getFirst()),ImmutableMap.<String,String>of(),tempFile.get()).addListener(new Runnable(){
      @Override public void run(){
        try {
          tempFile.close();
        }
 catch (        IOException e) {
          LOG.warn(e,"Error occurred while deleting temporary manifest file for %s",manifestPath);
        }
      }
    }
,MoreExecutors.directExecutor());
  }
 catch (  InterruptedException e) {
    tempFile.close();
    throw e;
  }
}
