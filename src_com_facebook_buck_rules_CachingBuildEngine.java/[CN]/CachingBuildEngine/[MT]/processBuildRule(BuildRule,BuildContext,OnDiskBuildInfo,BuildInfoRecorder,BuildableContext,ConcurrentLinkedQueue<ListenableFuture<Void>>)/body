{
  Optional<RuleKey> cachedRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY);
  if (cachedRuleKey.isPresent() && rule.getRuleKey().equals(cachedRuleKey.get())) {
    return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.MATCHING_RULE_KEY,CacheResult.localKeyUnchangedHit()));
  }
  final CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,rule.getRuleKey(),buildInfoRecorder,context.getArtifactCache(),context.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE,cacheResult));
  }
  context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.suspended(rule));
  return Futures.transform(getDepResults(rule,context,asyncCallbacks),new AsyncFunction<List<BuildResult>,BuildResult>(){
    @Override public ListenableFuture<BuildResult> apply(    @Nonnull List<BuildResult> depResults) throws Exception {
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule));
      if (rule instanceof SupportsInputBasedRuleKey) {
        RuleKey inputRuleKey=inputBasedRuleKeyBuilderFactory.newInstance(rule).build();
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY,inputRuleKey.toString());
        Optional<RuleKey> lastInputRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY);
        if (lastInputRuleKey.isPresent() && lastInputRuleKey.get().equals(inputRuleKey)) {
          return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.MATCHING_INPUT_BASED_RULE_KEY,CacheResult.localKeyUnchangedHit()));
        }
        CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,inputRuleKey,buildInfoRecorder,context.getArtifactCache(),context.getProjectFilesystem(),context);
        if (cacheResult.getType().isSuccess()) {
          return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED,cacheResult));
        }
      }
      AbiRule abiRule=checkIfRuleOrBuildableIsAbiRule(rule);
      if (abiRule != null) {
        RuleKey ruleKeyNoDeps=rule.getRuleKeyWithoutDeps();
        Optional<RuleKey> cachedRuleKeyNoDeps=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY_WITHOUT_DEPS);
        if (ruleKeyNoDeps.equals(cachedRuleKeyNoDeps.orNull())) {
          Sha1HashCode abiKeyForDeps=abiRule.getAbiKeyForDeps();
          Optional<Sha1HashCode> cachedAbiKeyForDeps=onDiskBuildInfo.getHash(ABI_KEY_FOR_DEPS_ON_DISK_METADATA);
          if (abiKeyForDeps.equals(cachedAbiKeyForDeps.orNull())) {
            return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.MATCHING_DEPS_ABI_AND_RULE_KEY_NO_DEPS,AbstractCacheResult.localKeyUnchangedHit()));
          }
        }
      }
      executeCommandsNowThatDepsAreBuilt(rule,context,buildableContext,buildInfoRecorder);
      return Futures.immediateFuture(new BuildResult(rule,BuildRuleSuccessType.BUILT_LOCALLY,cacheResult));
    }
  }
,service);
}
