{
  if (!context.isKeepGoing() && firstFailure != null) {
    return Futures.immediateFuture(BuildResult.canceled(rule,firstFailure));
  }
  final RuleKeyFactories ruleKeyFactory=ruleKeyFactories.getUnchecked(rule.getProjectFilesystem());
  Optional<RuleKey> cachedRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY);
  if (ruleKeyFactory.defaultRuleKeyBuilderFactory.build(rule).equals(cachedRuleKey.orNull())) {
    return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_RULE_KEY,CacheResult.localKeyUnchangedHit()));
  }
  final CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,ruleKeyFactory.defaultRuleKeyBuilderFactory.build(rule),buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE,cacheResult));
  }
  context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.suspended(rule,ruleKeyFactory.defaultRuleKeyBuilderFactory));
  return Futures.transformAsync(getDepResults(rule,context,asyncCallbacks),new AsyncFunction<List<BuildResult>,BuildResult>(){
    @Override public ListenableFuture<BuildResult> apply(    @Nonnull List<BuildResult> depResults) throws Exception {
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule,ruleKeyFactory.defaultRuleKeyBuilderFactory));
      for (      BuildResult depResult : depResults) {
        if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && depResult.getStatus() != BuildRuleStatus.SUCCESS) {
          return Futures.immediateFuture(BuildResult.canceled(rule,Preconditions.checkNotNull(depResult.getFailure())));
        }
      }
      if (buildMode != BuildMode.POPULATE_FROM_REMOTE_CACHE && !context.isKeepGoing() && firstFailure != null) {
        return Futures.immediateFuture(BuildResult.canceled(rule,firstFailure));
      }
      if (useDependencyFileRuleKey(rule)) {
        Optional<RuleKey> depFileRuleKey=calculateDepFileRuleKey(rule,onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_DEP_FILE),true);
        if (depFileRuleKey.isPresent()) {
          Optional<RuleKey> lastDepFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY);
          if (depFileRuleKey.equals(lastDepFileRuleKey)) {
            return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_DEP_FILE_RULE_KEY,CacheResult.localKeyUnchangedHit()));
          }
        }
      }
      if (useManifestCaching(rule)) {
        CacheResult cacheResult=performManifestBasedCacheFetch(rule,context,buildInfoRecorder);
        if (cacheResult.getType().isSuccess()) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_MANIFEST_BASED,cacheResult));
        }
      }
      if (rule instanceof SupportsInputBasedRuleKey) {
        RuleKey inputRuleKey=ruleKeyFactory.inputBasedRuleKeyBuilderFactory.build(rule);
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY,inputRuleKey.toString());
        Optional<RuleKey> lastInputRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY);
        if (inputRuleKey.equals(lastInputRuleKey.orNull())) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_INPUT_BASED_RULE_KEY,CacheResult.localKeyUnchangedHit()));
        }
        CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,inputRuleKey,buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
        if (cacheResult.getType().isSuccess()) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED,cacheResult));
        }
      }
      if (rule instanceof AbiRule) {
        RuleKey abiRuleKey=ruleKeyFactory.abiRuleKeyBuilderFactory.build(rule);
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY,abiRuleKey.toString());
        Optional<RuleKey> lastAbiRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY);
        if (abiRuleKey.equals(lastAbiRuleKey.orNull())) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_ABI_RULE_KEY,CacheResult.localKeyUnchangedHit()));
        }
      }
      if (buildMode == BuildMode.POPULATE_FROM_REMOTE_CACHE) {
        LOG.info("Cannot populate cache for " + rule.getBuildTarget().getFullyQualifiedName());
        return Futures.immediateFuture(BuildResult.canceled(rule,new HumanReadableException("Skipping %s: in cache population mode local builds are disabled",rule)));
      }
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.suspended(rule,ruleKeyFactory.defaultRuleKeyBuilderFactory));
      return service.submit(new Callable<BuildResult>(){
        @Override public BuildResult call() throws Exception {
          context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule,ruleKeyFactory.defaultRuleKeyBuilderFactory));
          executeCommandsNowThatDepsAreBuilt(rule,context,buildableContext);
          return BuildResult.success(rule,BuildRuleSuccessType.BUILT_LOCALLY,cacheResult);
        }
      }
);
    }
  }
,service);
}
