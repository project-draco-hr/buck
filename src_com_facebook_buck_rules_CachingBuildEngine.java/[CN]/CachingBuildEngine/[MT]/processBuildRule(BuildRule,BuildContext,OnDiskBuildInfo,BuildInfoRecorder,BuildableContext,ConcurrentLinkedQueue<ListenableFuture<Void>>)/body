{
  if (!context.isKeepGoing() && firstFailure != null) {
    return Futures.immediateFuture(BuildResult.canceled(rule,firstFailure));
  }
  Optional<RuleKey> cachedRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_RULE_KEY);
  if (rule.getRuleKey().equals(cachedRuleKey.orNull())) {
    return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_RULE_KEY,CacheResult.localKeyUnchangedHit()));
  }
  final CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,rule.getRuleKey(),buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
  if (cacheResult.getType().isSuccess()) {
    return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE,cacheResult));
  }
  context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.suspended(rule));
  return Futures.transform(getDepResults(rule,context,asyncCallbacks),new AsyncFunction<List<BuildResult>,BuildResult>(){
    @Override public ListenableFuture<BuildResult> apply(    @Nonnull List<BuildResult> depResults) throws Exception {
      context.getEventBus().logVerboseAndPost(LOG,BuildRuleEvent.resumed(rule));
      for (      BuildResult depResult : depResults) {
        if (depResult.getStatus() != BuildRuleStatus.SUCCESS) {
          return Futures.immediateFuture(BuildResult.canceled(rule,Preconditions.checkNotNull(depResult.getFailure())));
        }
      }
      if (!context.isKeepGoing() && firstFailure != null) {
        return Futures.immediateFuture(BuildResult.canceled(rule,firstFailure));
      }
      if (useDependencyFileRuleKey(rule)) {
        Optional<RuleKey> depFileRuleKey=calculateDepFileRuleKey(rule,onDiskBuildInfo.getValues(BuildInfo.METADATA_KEY_FOR_DEP_FILE),onDiskBuildInfo.getMultimap(BuildInfo.METADATA_KEY_FOR_INPUT_MAP),true);
        if (depFileRuleKey.isPresent()) {
          Optional<RuleKey> lastDepFileRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_DEP_FILE_RULE_KEY);
          if (depFileRuleKey.equals(lastDepFileRuleKey)) {
            return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_DEP_FILE_RULE_KEY,CacheResult.localKeyUnchangedHit()));
          }
        }
      }
      if (rule instanceof SupportsInputBasedRuleKey) {
        RuleKey inputRuleKey=inputBasedRuleKeyBuilderFactory.newInstance(rule).build();
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY,inputRuleKey.toString());
        Optional<RuleKey> lastInputRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_INPUT_BASED_RULE_KEY);
        if (inputRuleKey.equals(lastInputRuleKey.orNull())) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_INPUT_BASED_RULE_KEY,CacheResult.localKeyUnchangedHit()));
        }
        CacheResult cacheResult=tryToFetchArtifactFromBuildCacheAndOverlayOnTopOfProjectFilesystem(rule,inputRuleKey,buildInfoRecorder,context.getArtifactCache(),rule.getProjectFilesystem(),context);
        if (cacheResult.getType().isSuccess()) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.FETCHED_FROM_CACHE_INPUT_BASED,cacheResult));
        }
      }
      if (rule instanceof AbiRule) {
        RuleKey abiRuleKey=abiRuleKeyBuilderFactory.newInstance(rule).build();
        buildInfoRecorder.addBuildMetadata(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY,abiRuleKey.toString());
        Optional<RuleKey> lastAbiRuleKey=onDiskBuildInfo.getRuleKey(BuildInfo.METADATA_KEY_FOR_ABI_RULE_KEY);
        if (abiRuleKey.equals(lastAbiRuleKey.orNull())) {
          return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.MATCHING_ABI_RULE_KEY,AbstractCacheResult.localKeyUnchangedHit()));
        }
      }
      executeCommandsNowThatDepsAreBuilt(rule,context,buildableContext);
      return Futures.immediateFuture(BuildResult.success(rule,BuildRuleSuccessType.BUILT_LOCALLY,cacheResult));
    }
  }
,service);
}
