{
  Path iosSimulatorPath=appleDeveloperDirectoryPath.resolve("Applications/iOS Simulator.app");
  ImmutableList<String> command=ImmutableList.of("open","-a",iosSimulatorPath.toString(),"--args","-CurrentDeviceUDID",simulatorUdid);
  LOG.debug("Launching iOS simulator %s: %s",simulatorUdid,command);
  ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().setCommand(command).build();
  ProcessExecutor.Result result=processExecutor.launchAndExecute(processExecutorParams);
  if (result.getExitCode() != 0) {
    LOG.error("Error %d running %s",result.getExitCode(),command);
    return false;
  }
  Predicate<AppleSimulator> simulatorBootedPredicate=new Predicate<AppleSimulator>(){
    @Override public boolean apply(    AppleSimulator simulator){
      return simulator.getUdid().equals(simulatorUdid) && simulator.getSimulatorState() == AppleSimulatorState.BOOTED;
    }
  }
;
  long millisWaited=0;
  boolean simulatorBooted=false;
  while (!simulatorBooted && millisWaited < simulatorBootTimeoutMillis) {
    LOG.debug("Checking if iOS simulator %s has finished booting...",simulatorUdid);
    ImmutableSet<AppleSimulator> runningSimulators=AppleSimulatorDiscovery.discoverAppleSimulators(processExecutor);
    if (Iterables.any(runningSimulators,simulatorBootedPredicate)) {
      LOG.debug("iOS simulator %s has finished booting.",simulatorUdid);
      simulatorBooted=true;
    }
 else {
      LOG.debug("Sleeping for %s ms waiting for simulator to finish booting...",SIMULATOR_POLL_TIMEOUT_MILLIS);
      Thread.sleep(SIMULATOR_POLL_TIMEOUT_MILLIS);
      millisWaited+=SIMULATOR_POLL_TIMEOUT_MILLIS;
    }
  }
  return simulatorBooted;
}
