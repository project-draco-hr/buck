def resolve(requirements, obtainer=None, interpreter=None, platform=None):
    'List all distributions needed to (recursively) meet `requirements`\n\n  When resolving dependencies, multiple (potentially incompatible) requirements may be encountered.\n  Handle this situation by iteratively filtering a set of potential project\n  distributions by new requirements, and finally choosing the highest version meeting all\n  requirements, or raise an error indicating unsatisfiable requirements.\n\n  Note: should `pkg_resources.WorkingSet.resolve` correctly handle multiple requirements in the\n  future this should go away in favor of using what setuptools provides.\n\n  :returns: List of :class:`pkg_resources.Distribution` instances meeting `requirements`.\n  '
    cache = _DistributionCache()
    interpreter = (interpreter or PythonInterpreter.get())
    platform = (platform or Platform.current())
    obtainer = (obtainer or Obtainer.default(platform=platform, interpreter=interpreter))
    requirements = maybe_requirement_list(requirements)
    distribution_set = defaultdict(list)
    requirement_set = defaultdict(list)
    processed_requirements = set()

    def packages(requirement, existing=None):
        if (existing is None):
            existing = obtainer.iter(requirement)
        return [package for package in existing if (package.satisfies(requirement) and package.compatible(interpreter.identity, platform))]

    def requires(package, requirement):
        if (not cache.has(package)):
            dist = obtainer.obtain(package)
            if (dist is None):
                raise Untranslateable(('Package %s is not translateable.' % package))
            if (not distribution_compatible(dist, interpreter, platform)):
                raise Untranslateable(('Could not get distribution for %s on appropriate platform.' % package))
            cache.put(package, dist)
        dist = cache.get(package)
        return dist.requires(extras=requirement.extras)
    while True:
        while requirements:
            requirement = requirements.pop(0)
            requirement_set[requirement.key].append(requirement)
            distribution_list = distribution_set[requirement.key] = packages(requirement, existing=distribution_set.get(requirement.key))
            if (not distribution_list):
                raise Unsatisfiable(('Cannot satisfy requirements: %s' % requirement_set[requirement.key]))
        for (requirement_key, requirement_list) in requirement_set.items():
            new_requirements = OrderedSet()
            highest_package = distribution_set[requirement_key][0]
            for requirement in requirement_list:
                if (requirement in processed_requirements):
                    continue
                new_requirements.update(requires(highest_package, requirement))
                processed_requirements.add(requirement)
            requirements.extend(list(new_requirements))
        if (not requirements):
            break
    to_activate = set()
    for distributions in distribution_set.values():
        to_activate.add(cache.get(distributions[0]))
    return to_activate
