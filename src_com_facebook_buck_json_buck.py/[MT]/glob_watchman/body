@memoized
def glob_watchman(includes, excludes, include_dotfiles, base_path, project_root, sync_cookie_state):
    assert includes, 'The includes argument must be a non-empty list of strings.'
    match_exprs = ['allof', 'exists']
    match_flags = {}
    if include_dotfiles:
        match_flags['includedotfiles'] = True
    if includes:
        match_exprs.append((['anyof'] + [['match', i, 'wholename', match_flags] for i in includes]))
    if excludes:
        match_exprs.append(['not', (['anyof'] + [['match', x, 'wholename', match_flags] for x in excludes])])
    query_params = {'relative_root': base_path, 'path': [''], 'fields': ['name'], 'expression': match_exprs, }
    if sync_cookie_state.use_sync_cookies:
        sync_cookie_state.use_sync_cookies = False
    else:
        query_params['sync_timeout'] = 0
    query = ['query', project_root, query_params]
    process = subprocess.Popen(['watchman', '-j', '--no-pretty'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, _) = process.communicate(input=json.dumps(query))
    res = json.loads(stdout)
    if res.get('error'):
        raise RuntimeError('Error from Watchman query {}: {}'.format(query, res.get('error')))
    if res.get('warning'):
        print  >> sys.stderr, 'Watchman warning from query {}: {}'.format(query, res.get('warning'))
    result = res.get('files', [])
    return sorted(result)
