{
  ProjectFilesystem projectFilesystem=new FakeProjectFilesystem();
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver());
  BuildTarget target=BuildTargetFactory.newInstance("//foo:bar");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).build();
  CxxPlatform cxxPlatform=DefaultCxxPlatforms.build(new CxxBuckConfig(FakeBuckConfig.builder().build()));
  final BuildTarget publicHeaderTarget=BuildTargetFactory.newInstance("//:header");
  final BuildTarget publicHeaderSymlinkTreeTarget=BuildTargetFactory.newInstance("//:symlink");
  final Path publicHeaderSymlinkTreeRoot=Paths.get("symlink/tree/root");
  final BuildTarget privateHeaderTarget=BuildTargetFactory.newInstance("//:privateheader");
  final BuildTarget privateHeaderSymlinkTreeTarget=BuildTargetFactory.newInstance("//:privatesymlink");
  final Path privateHeaderSymlinkTreeRoot=Paths.get("private/symlink/tree/root");
  final BuildRule archive=new FakeBuildRule("//:archive",pathResolver);
  final Path archiveOutput=Paths.get("output/path/lib.a");
  final BuildRule sharedLibrary=new FakeBuildRule("//:shared",pathResolver);
  final Path sharedLibraryOutput=Paths.get("output/path/lib.so");
  final String sharedLibrarySoname="lib.so";
  FakeCxxLibrary cxxLibrary=new FakeCxxLibrary(params,pathResolver,publicHeaderTarget,publicHeaderSymlinkTreeTarget,publicHeaderSymlinkTreeRoot,privateHeaderTarget,privateHeaderSymlinkTreeTarget,privateHeaderSymlinkTreeRoot,archive,archiveOutput,sharedLibrary,sharedLibraryOutput,sharedLibrarySoname,ImmutableSortedSet.<BuildTarget>of());
  CxxPreprocessorInput expectedPublicCxxPreprocessorInput=CxxPreprocessorInput.builder().addRules(publicHeaderTarget,publicHeaderSymlinkTreeTarget).addIncludeRoots(publicHeaderSymlinkTreeRoot).build();
  assertEquals(expectedPublicCxxPreprocessorInput,cxxLibrary.getCxxPreprocessorInput(TargetGraph.EMPTY,cxxPlatform,HeaderVisibility.PUBLIC));
  CxxPreprocessorInput expectedPrivateCxxPreprocessorInput=CxxPreprocessorInput.builder().addRules(privateHeaderTarget,privateHeaderSymlinkTreeTarget).addIncludeRoots(privateHeaderSymlinkTreeRoot).build();
  assertEquals(expectedPrivateCxxPreprocessorInput,cxxLibrary.getCxxPreprocessorInput(TargetGraph.EMPTY,cxxPlatform,HeaderVisibility.PRIVATE));
  NativeLinkableInput expectedStaticNativeLinkableInput=NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
  assertEquals(expectedStaticNativeLinkableInput,cxxLibrary.getNativeLinkableInput(TargetGraph.EMPTY,cxxPlatform,Linker.LinkableDepType.STATIC));
  NativeLinkableInput expectedSharedNativeLinkableInput=NativeLinkableInput.of(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(sharedLibrary.getBuildTarget())),ImmutableList.of(sharedLibraryOutput.toString()),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
  assertEquals(expectedSharedNativeLinkableInput,cxxLibrary.getNativeLinkableInput(TargetGraph.EMPTY,cxxPlatform,Linker.LinkableDepType.SHARED));
  PythonPackageComponents expectedPythonPackageComponents=PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(Paths.get(sharedLibrarySoname),new PathSourcePath(projectFilesystem,sharedLibraryOutput)),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
  assertEquals(expectedPythonPackageComponents,cxxLibrary.getPythonPackageComponents(TargetGraph.EMPTY,PythonTestUtils.PYTHON_PLATFORM,cxxPlatform));
  assertEquals(ImmutableList.<Step>of(),cxxLibrary.getBuildSteps(null,null));
  assertNull(cxxLibrary.getPathToOutput());
}
