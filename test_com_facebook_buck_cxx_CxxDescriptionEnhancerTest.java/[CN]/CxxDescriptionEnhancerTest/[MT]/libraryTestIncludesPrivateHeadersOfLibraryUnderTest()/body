{
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver());
  BuildTarget libTarget=BuildTargetFactory.newInstance("//:lib");
  BuildTarget testTarget=BuildTargetFactory.newInstance("//:test");
  BuildRuleParams libParams=new FakeBuildRuleParamsBuilder(libTarget).build();
  FakeCxxLibrary libRule=new FakeCxxLibrary(libParams,pathResolver,BuildTargetFactory.newInstance("//:header"),BuildTargetFactory.newInstance("//:symlink"),Paths.get("symlink/tree/lib"),BuildTargetFactory.newInstance("//:privateheader"),BuildTargetFactory.newInstance("//:privatesymlink"),Paths.get("private/symlink/tree/lib"),new FakeBuildRule("//:archive",pathResolver),Paths.get("output/path/lib.a"),new FakeBuildRule("//:shared",pathResolver),Paths.get("output/path/lib.so"),"lib.so",ImmutableSortedSet.of(testTarget));
  BuildRuleParams testParams=new FakeBuildRuleParamsBuilder(testTarget).setDeps(ImmutableSortedSet.<BuildRule>of(libRule)).build();
  ImmutableList<CxxPreprocessorInput> combinedInput=CxxDescriptionEnhancer.collectCxxPreprocessorInput(TargetGraph.EMPTY,testParams,CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableMultimap.<CxxSource.Type,String>of(),ImmutableList.<HeaderSymlinkTree>of(),ImmutableSet.<Path>of(),CxxPreprocessables.getTransitiveCxxPreprocessorInput(TargetGraph.EMPTY,CxxPlatformUtils.DEFAULT_PLATFORM,FluentIterable.from(testParams.getDeps()).filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
  assertThat("Test of library should include both public and private headers",CxxPreprocessorInput.concat(combinedInput).getIncludeRoots(),hasItems(Paths.get("symlink/tree/lib"),Paths.get("private/symlink/tree/lib")));
}
