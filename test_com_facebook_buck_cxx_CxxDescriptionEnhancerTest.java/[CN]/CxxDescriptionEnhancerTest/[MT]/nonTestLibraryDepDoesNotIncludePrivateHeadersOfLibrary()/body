{
  SourcePathResolver pathResolver=new SourcePathResolver(new BuildRuleResolver(TargetGraph.EMPTY,new BuildTargetNodeToBuildRuleTransformer()));
  BuildTarget libTarget=BuildTargetFactory.newInstance("//:lib");
  BuildRuleParams libParams=new FakeBuildRuleParamsBuilder(libTarget).build();
  ProjectFilesystem filesystem=libParams.getProjectFilesystem();
  FakeCxxLibrary libRule=new FakeCxxLibrary(libParams,pathResolver,BuildTargetFactory.newInstance("//:header"),BuildTargetFactory.newInstance("//:symlink"),filesystem.resolve("symlink/tree/lib"),BuildTargetFactory.newInstance("//:privateheader"),BuildTargetFactory.newInstance("//:privatesymlink"),filesystem.resolve("private/symlink/tree/lib"),new FakeBuildRule("//:archive",pathResolver),new FakeBuildRule("//:shared",pathResolver),Paths.get("output/path/lib.so"),"lib.so",ImmutableSortedSet.<BuildTarget>of());
  BuildTarget otherLibDepTarget=BuildTargetFactory.newInstance("//:other");
  BuildRuleParams otherLibDepParams=new FakeBuildRuleParamsBuilder(otherLibDepTarget).setDeclaredDeps(ImmutableSortedSet.<BuildRule>of(libRule)).build();
  ImmutableList<CxxPreprocessorInput> otherInput=CxxDescriptionEnhancer.collectCxxPreprocessorInput(otherLibDepParams,CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableMultimap.<CxxSource.Type,String>of(),ImmutableList.<HeaderSymlinkTree>of(),ImmutableSet.<FrameworkPath>of(),CxxPreprocessables.getTransitiveCxxPreprocessorInput(CxxPlatformUtils.DEFAULT_PLATFORM,FluentIterable.from(otherLibDepParams.getDeps()).filter(Predicates.instanceOf(CxxPreprocessorDep.class))));
  assertThat("Non-test rule with library dep should include public and not private headers",CxxPreprocessorInput.concat(otherInput).getIncludeRoots(),allOf(hasItem(filesystem.resolve("symlink/tree/lib")),not(hasItem(filesystem.resolve("private/symlink/tree/lib")))));
}
