{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  final Path output=BuildTargets.getScratchPath(getProjectFilesystem(),getBuildTarget(),"__%s/deps.txt");
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),output.getParent()));
  appendWorkerSteps(steps,output);
  steps.add(new MakeCleanDirectoryStep(getProjectFilesystem(),outputDir));
  steps.add(new AbstractExecutionStep("hash_js_inputs"){
    @Override public StepExecutionResult execute(    ExecutionContext context) throws IOException {
      ImmutableList<Path> paths;
      try {
        paths=FluentIterable.from(getProjectFilesystem().readLines(output)).transform(MorePaths.TO_PATH).transform(getProjectFilesystem().getRelativizer()).toSortedList(Ordering.natural());
      }
 catch (      IOException e) {
        context.logError(e,"Error reading output of the 'react-native-deps' step.");
        return StepExecutionResult.ERROR;
      }
      FluentIterable<SourcePath> unlistedSrcs=FluentIterable.from(paths).transform(SourcePaths.toSourcePath(getProjectFilesystem())).filter(Predicates.not(Predicates.in(srcs)));
      if (!unlistedSrcs.isEmpty()) {
        context.logError(new RuntimeException(),"Entry path '%s' transitively uses the following source files which were not " + "included in 'srcs':\n%s",entryPath,Joiner.on('\n').join(unlistedSrcs));
        return StepExecutionResult.ERROR;
      }
      Hasher hasher=Hashing.sha1().newHasher();
      for (      Path path : paths) {
        try {
          hasher.putUnencodedChars(getProjectFilesystem().computeSha1(path));
        }
 catch (        IOException e) {
          context.logError(e,"Error hashing input file: %s",path);
          return StepExecutionResult.ERROR;
        }
      }
      String inputsHash=hasher.hash().toString();
      buildableContext.addMetadata(METADATA_KEY_FOR_INPUTS_HASH,inputsHash);
      getProjectFilesystem().writeContentsToPath(inputsHash,inputsHashFile);
      return StepExecutionResult.SUCCESS;
    }
  }
);
  return steps.build();
}
