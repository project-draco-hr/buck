def _kill_buckd_process_and_wait(self, buckd_pid):
    with Tracing('BuckRepo._kill_buckd_process_and_wait'):
        try:
            print('Terminating existing buckd process...', file=sys.stderr)
            os.kill(buckd_pid, signal.SIGTERM)
            print('Waiting for existing buckd process to exit...', file=sys.stderr)
            for count in range(100):
                time.sleep(0.1)
                os.kill(buckd_pid, signal.SIGTERM)
            else:
                print(textwrap.dedent('                        Could not kill existing buckd process after 10 seconds!\n                        Force killing existing buckd process.'), file=sys.stderr)
                os.kill(buckd_pid, signal.SIGKILL)
        except OSError as e:
            if (e.errno != errno.ESRCH):
                raise
