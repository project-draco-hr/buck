{
  final ImmutableList.Builder<BuildRule> filteredRules=ImmutableList.builder();
  AbstractAcyclicDepthFirstPostOrderTraversal<BuildRule> traversal=new AbstractAcyclicDepthFirstPostOrderTraversal<BuildRule>(){
    @Override protected Iterator<BuildRule> findChildren(    BuildRule node) throws IOException {
      ImmutableSortedSet<BuildRule> defaultDeps=node.getDeps();
      if (node.getType().equals(AppleBundleDescription.TYPE) && mode != RecursiveRuleDependenciesMode.COMPLETE) {
        AppleBundle bundle=(AppleBundle)node;
        ImmutableSortedSet.Builder<BuildRule> editedDeps=ImmutableSortedSet.naturalOrder();
        for (        BuildRule rule : defaultDeps) {
          if (rule != bundle.getBinary()) {
            editedDeps.add(rule);
          }
 else {
            editedDeps.addAll(bundle.getBinary().getDeps());
          }
        }
        defaultDeps=editedDeps.build();
      }
      ImmutableSortedSet<BuildRule> deps;
      if (node != rule) {
switch (mode) {
case LINKING:
          if (node.getType().equals(AppleLibraryDescription.TYPE)) {
            AppleLibrary library=(AppleLibrary)node;
            if (library.getLinkedDynamically()) {
              deps=ImmutableSortedSet.of();
            }
 else {
              deps=defaultDeps;
            }
          }
 else           if (node.getType().equals(AppleBundleDescription.TYPE)) {
            deps=ImmutableSortedSet.of();
          }
 else {
            deps=defaultDeps;
          }
        break;
case COPYING:
      if (node.getType().equals(AppleBundleDescription.TYPE)) {
        deps=ImmutableSortedSet.of();
      }
 else {
        deps=defaultDeps;
      }
    break;
default :
  deps=defaultDeps;
break;
}
}
 else {
deps=defaultDeps;
}
return deps.iterator();
}
@Override protected void onNodeExplored(BuildRule node){
if (node != rule && (!types.isPresent() || types.get().contains(node.getType()))) {
filteredRules.add(node);
}
}
@Override protected void onTraversalComplete(Iterable<BuildRule> nodesInExplorationOrder){
}
}
;
try {
traversal.traverse(ImmutableList.of(rule));
}
 catch (AbstractAcyclicDepthFirstPostOrderTraversal.CycleException|IOException|InterruptedException e) {
throw new RuntimeException(e);
}
return filteredRules.build();
}
