{
  BuildRule projectRule=projectConfig.getProjectRule();
  Buildable buildable=projectRule.getBuildable();
  Preconditions.checkState(projectRule instanceof JavaLibraryRule || buildable instanceof JavaLibraryRule || buildable instanceof JavaBinary|| projectRule instanceof AndroidLibraryRule|| buildable instanceof AndroidResource|| projectRule instanceof AndroidBinaryRule|| buildable instanceof NdkLibrary,"project_config() does not know how to process a src_target of type %s.",projectRule.getType().getName());
  LinkedHashSet<DependentModule> dependencies=Sets.newLinkedHashSet();
  final BuildTarget target=projectConfig.getBuildTarget();
  Module module=new Module(projectRule,target);
  module.name=getIntellijNameForRule(projectRule);
  module.isIntelliJPlugin=projectConfig.getIsIntelliJPlugin();
  String relativePath=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.pathToImlFile=String.format("%s%s.iml",relativePath,module.name);
  boolean includeSourceFolder=true;
  boolean hasSourceFoldersForTestRule=addSourceFolders(module,projectConfig.getTestRule(),projectConfig.getTestsSourceRoots(),true);
  BuildRule testRule=projectConfig.getTestRule();
  if (testRule != null) {
    walkRuleAndAdd(testRule,true,dependencies,projectConfig.getSrcRule());
  }
  boolean hasSourceFoldersForSrcRule=addSourceFolders(module,projectConfig.getSrcRule(),projectConfig.getSourceRoots(),false);
  addRootExcludes(module,projectConfig.getSrcRule(),projectFilesystem);
  if (!hasSourceFoldersForTestRule && !hasSourceFoldersForSrcRule) {
    includeSourceFolder=false;
  }
  boolean isAndroidRule=projectRule.getProperties().is(ANDROID);
  if (isAndroidRule) {
    boolean hasSourceFolders=!module.sourceFolders.isEmpty();
    module.sourceFolders.add(SourceFolder.GEN);
    if (!hasSourceFolders) {
      includeSourceFolder=true;
    }
  }
  walkRuleAndAdd(projectRule,false,dependencies,projectConfig.getSrcRule());
  String basePathWithSlash=projectConfig.getBuildTarget().getBasePathWithSlash();
  module.moduleGenPath=generateRelativeGenPath(basePathWithSlash).toString();
  DependentModule jdkDependency;
  if (isAndroidRule) {
    if (projectRule.getBuildable() instanceof NdkLibrary) {
      NdkLibrary ndkLibrary=(NdkLibrary)projectRule.getBuildable();
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
      module.nativeLibs=Paths.get(relativePath).relativize(ndkLibrary.getLibraryPath()).toString();
    }
 else     if (projectRule.getBuildable() instanceof AndroidResource) {
      AndroidResource androidResource=(AndroidResource)projectRule.getBuildable();
      module.resFolder=createRelativePath(androidResource.getRes(),target);
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
 else     if (projectRule instanceof AndroidBinaryRule) {
      AndroidBinaryRule androidBinaryRule=(AndroidBinaryRule)projectRule;
      module.resFolder=null;
      module.isAndroidLibraryProject=false;
      KeystoreProperties keystoreProperties=KeystoreProperties.createFromPropertiesFile(androidBinaryRule.getKeystore().getPathToStore(),androidBinaryRule.getKeystore().getPathToPropertiesFile(),projectFilesystem);
      module.keystorePath=Paths.get(relativePath).relativize(keystoreProperties.getKeystore()).toString();
    }
 else {
      module.isAndroidLibraryProject=true;
      module.keystorePath=null;
    }
    module.hasAndroidFacet=true;
    module.proguardConfigPath=null;
    if (pathToDefaultAndroidManifest.isPresent()) {
      String androidManifest=basePathWithSlash + "AndroidManifest.xml";
      if (!projectFilesystem.exists(androidManifest)) {
        String manifestPath=this.pathToDefaultAndroidManifest.get();
        String rootPrefix="//";
        Preconditions.checkState(manifestPath.startsWith(rootPrefix),"Currently, we expect this option to start with '%s', " + "indicating that it is relative to the root of the repository.",rootPrefix);
        manifestPath=manifestPath.substring(rootPrefix.length());
        String relativePathToManifest=Paths.get(basePathWithSlash).relativize(Paths.get(manifestPath)).toString();
        module.androidManifest="/" + relativePathToManifest;
      }
    }
    jdkDependency=DependentModule.newInheritedJdk();
  }
 else {
    module.hasAndroidFacet=false;
    if (module.isIntelliJPlugin()) {
      jdkDependency=DependentModule.newIntelliJPluginJdk();
    }
 else {
      jdkDependency=DependentModule.newStandardJdk();
    }
  }
  module.dependencies=createDependenciesInOrder(includeSourceFolder,dependencies,jdkDependency);
  JavaLibraryRule javaLibraryRule=null;
  if (projectRule.getBuildable() instanceof JavaLibraryRule) {
    javaLibraryRule=(JavaLibraryRule)projectRule.getBuildable();
  }
 else   if (projectRule instanceof JavaLibraryRule) {
    javaLibraryRule=(JavaLibraryRule)projectRule;
  }
  if (javaLibraryRule != null) {
    AnnotationProcessingData processingData=javaLibraryRule.getAnnotationProcessingData();
    Path annotationGenSrc=processingData.getGeneratedSourceFolderName();
    if (annotationGenSrc != null) {
      module.annotationGenPath="/" + Paths.get(basePathWithSlash).relativize(annotationGenSrc).toString();
      module.annotationGenIsForTest=!hasSourceFoldersForSrcRule;
    }
  }
  return module;
}
