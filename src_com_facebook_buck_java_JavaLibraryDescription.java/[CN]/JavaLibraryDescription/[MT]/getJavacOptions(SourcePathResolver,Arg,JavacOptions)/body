{
  if ((args.source.isPresent() || args.target.isPresent()) && args.javaVersion.isPresent()) {
    throw new HumanReadableException("Please set either source and target or java_version.");
  }
  JavacOptions.Builder builder=JavacOptions.builder(defaultOptions);
  if (args.javaVersion.isPresent()) {
    builder.setSourceLevel(args.javaVersion.get());
    builder.setTargetLevel(args.javaVersion.get());
  }
  if (args.source.isPresent()) {
    builder.setSourceLevel(args.source.get());
  }
  if (args.target.isPresent()) {
    builder.setTargetLevel(args.target.get());
  }
  if (args.extraArguments.isPresent()) {
    builder.addAllExtraArguments(args.extraArguments.get());
  }
  if (args.compiler.isPresent()) {
    Either<BuiltInJavac,SourcePath> left=args.compiler.get();
    if (left.isRight()) {
      SourcePath right=left.getRight();
      Optional<BuildRule> possibleRule=resolver.getRule(right);
      if (possibleRule.isPresent()) {
        BuildRule rule=possibleRule.get();
        if (rule instanceof PrebuiltJar) {
          builder.setJavacJarPath(new BuildTargetSourcePath(rule.getBuildTarget()));
        }
 else {
          throw new HumanReadableException("Only prebuilt_jar targets can be used as a javac");
        }
      }
 else {
        builder.setJavacPath(resolver.getPath(right));
      }
    }
  }
 else {
    if (args.javac.isPresent() || args.javacJar.isPresent()) {
      if (args.javac.isPresent() && args.javacJar.isPresent()) {
        throw new HumanReadableException("Cannot set both javac and javacjar");
      }
      builder.setJavacPath(args.javac);
      builder.setJavacJarPath(args.javacJar);
    }
  }
  return builder;
}
