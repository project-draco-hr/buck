{
  final Supplier<Set<Path>> primaryInputsToDex;
  final Optional<Path> secondaryDexDir;
  final Optional<Supplier<Multimap<Path,Path>>> secondaryOutputToInputs;
  if (shouldSplitDex()) {
    Optional<Path> proguardFullConfigFile=Optional.absent();
    Optional<Path> proguardMappingFile=Optional.absent();
    if (packageType.isBuildWithObfuscation()) {
      proguardFullConfigFile=Optional.of(getPathForProGuardDirectory().resolve("configuration.txt"));
      proguardMappingFile=Optional.of(getPathForProGuardDirectory().resolve("mapping.txt"));
    }
    Path splitZipDir=getBinPath("__%s_split_zip__");
    steps.add(new MakeCleanDirectoryStep(splitZipDir));
    Path primaryJarPath=splitZipDir.resolve("primary.jar");
    Path secondaryJarMetaDirParent=splitZipDir.resolve("secondary_meta");
    Path secondaryJarMetaDir=secondaryJarMetaDirParent.resolve(SECONDARY_DEX_SUBDIR);
    steps.add(new MakeCleanDirectoryStep(secondaryJarMetaDir));
    Path secondaryJarMeta=secondaryJarMetaDir.resolve("metadata.txt");
    final Path secondaryZipDir=getBinPath("__%s_secondary_zip__");
    steps.add(new MakeCleanDirectoryStep(secondaryZipDir));
    Path zipSplitReportDir=getBinPath("__%s_split_zip_report__");
    steps.add(new MakeCleanDirectoryStep(zipSplitReportDir));
    SplitZipStep splitZipCommand=new SplitZipStep(classpathEntriesToDex,secondaryJarMeta,primaryJarPath,secondaryZipDir,"secondary-%d.jar",proguardFullConfigFile,proguardMappingFile,dexSplitMode.getPrimaryDexPatterns(),dexSplitMode.getPrimaryDexClassesFile().transform(sourcePathResolver),dexSplitMode.getDexSplitStrategy(),dexSplitMode.getDexStore(),zipSplitReportDir,dexSplitMode.useLinearAllocSplitDex(),dexSplitMode.getLinearAllocHardLimit());
    steps.add(splitZipCommand);
    Path secondaryDexParentDir=getBinPath("__%s_secondary_dex__/");
    secondaryDexDir=Optional.of(secondaryDexParentDir.resolve(SECONDARY_DEX_SUBDIR));
    steps.add(new MkdirStep(secondaryDexDir.get()));
    secondaryDexDirectories.add(secondaryJarMetaDirParent);
    secondaryDexDirectories.add(secondaryDexParentDir);
    primaryInputsToDex=Suppliers.<Set<Path>>ofInstance(ImmutableSet.of(primaryJarPath));
    Supplier<Multimap<Path,Path>> secondaryOutputToInputsMap=splitZipCommand.getOutputToInputsMapSupplier(secondaryDexDir.get());
    secondaryOutputToInputs=Optional.of(secondaryOutputToInputsMap);
  }
 else {
    primaryInputsToDex=Suppliers.ofInstance(classpathEntriesToDex);
    secondaryDexDir=Optional.absent();
    secondaryOutputToInputs=Optional.absent();
  }
  Path successDir=getBinPath("__%s_smart_dex__/.success");
  steps.add(new MkdirStep(successDir));
  EnumSet<DxStep.Option> dxOptions=PackageType.RELEASE.equals(packageType) ? EnumSet.noneOf(DxStep.Option.class) : EnumSet.of(DxStep.Option.NO_OPTIMIZE);
  SmartDexingStep smartDexingCommand=new SmartDexingStep(primaryDexPath,primaryInputsToDex,secondaryDexDir,secondaryOutputToInputs,successDir,Optional.<Integer>absent(),dxOptions);
  steps.add(smartDexingCommand);
}
