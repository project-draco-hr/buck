{
  SourcePathResolver resolver=new SourcePathResolver(new BuildRuleResolver());
  BuildRule d=new FakeNativeLinkable("//:d",resolver,NativeLinkableInput.builder().addArgs(new StringArg("d")).build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of());
  BuildRule c=new FakeNativeLinkable("//:c",resolver,NativeLinkableInput.builder().addArgs(new StringArg("c")).build(),NativeLinkable.Linkage.STATIC,ImmutableMap.<String,SourcePath>of(),d);
  BuildRule b=new FakeNativeLinkable("//:b",resolver,NativeLinkableInput.builder().addArgs(new StringArg("b")).build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(),c);
  BuildRule a=new FakeNativeLinkable("//:a",resolver,NativeLinkableInput.builder().addArgs(new StringArg("a")).build(),NativeLinkable.Linkage.ANY,ImmutableMap.<String,SourcePath>of(),b);
  NativeLinkableInput inputForTop=NativeLinkables.getTransitiveNativeLinkableInput(TargetGraph.EMPTY,CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(a),Linker.LinkableDepType.SHARED,ImmutableSet.<BuildTarget>of(),false);
  assertThat(FluentIterable.from(inputForTop.getArgs()).transform(Arg.stringifyFunction()).toList(),Matchers.containsInAnyOrder("a","b","d"));
  assertThat(FluentIterable.from(inputForTop.getArgs()).transform(Arg.stringifyFunction()).toList(),Matchers.not(Matchers.contains("c")));
  NativeLinkableInput inputForB=NativeLinkables.getTransitiveNativeLinkableInput(TargetGraph.EMPTY,CxxPlatformUtils.DEFAULT_PLATFORM,ImmutableList.of(c),Linker.LinkableDepType.SHARED,ImmutableSet.<BuildTarget>of(),false);
  assertThat(FluentIterable.from(inputForB.getArgs()).transform(Arg.stringifyFunction()).toList(),Matchers.containsInAnyOrder("c","d"));
}
