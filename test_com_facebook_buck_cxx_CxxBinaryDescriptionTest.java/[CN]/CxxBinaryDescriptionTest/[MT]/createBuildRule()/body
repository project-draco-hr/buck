{
  ProjectFilesystem projectFilesystem=new FakeProjectFilesystem();
  BuildRuleResolver resolver=new BuildRuleResolver(TargetGraph.EMPTY,new BuildTargetNodeToBuildRuleTransformer());
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  CxxPlatform cxxPlatform=CxxBinaryBuilder.createDefaultPlatform();
  String genHeaderName="test/foo.h";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance("//:genHeader");
  Genrule genHeader=(Genrule)GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName).build(resolver);
  String genSourceName="test/foo.cpp";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance("//:genSource");
  Genrule genSource=(Genrule)GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName).build(resolver);
  final BuildRule header=createFakeBuildRule("//:header",pathResolver);
  final BuildRule headerSymlinkTree=createFakeBuildRule("//:symlink",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get("symlink/tree/root");
  final BuildRule archive=createFakeBuildRule("//:archive",pathResolver);
  BuildTarget depTarget=BuildTargetFactory.newInstance("//:dep");
  BuildRuleParams depParams=new FakeBuildRuleParamsBuilder(depTarget).build();
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return CxxPreprocessorInput.builder().addRules(header.getBuildTarget(),headerSymlinkTree.getBuildTarget()).addIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public ImmutableMap<BuildTarget,CxxPreprocessorInput> getTransitiveCxxPreprocessorInput(    CxxPlatform cxxPlatform,    HeaderVisibility headerVisibility){
      return ImmutableMap.of(getBuildTarget(),getCxxPreprocessorInput(cxxPlatform,headerVisibility));
    }
    @Override public Iterable<NativeLinkable> getNativeLinkableDeps(    CxxPlatform cxxPlatform){
      return FluentIterable.from(getDeclaredDeps()).filter(NativeLinkable.class);
    }
    @Override public Iterable<NativeLinkable> getNativeLinkableExportedDeps(    CxxPlatform cxxPlatform){
      return FluentIterable.from(getDeclaredDeps()).filter(NativeLinkable.class);
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Linker.LinkableDepType type){
      return NativeLinkableInput.of(ImmutableList.<Arg>of(new SourcePathArg(getResolver(),new BuildTargetSourcePath(archive.getBuildTarget()))),ImmutableSet.<FrameworkPath>of(),ImmutableSet.<FrameworkPath>of());
    }
    @Override public NativeLinkable.Linkage getPreferredLinkage(    CxxPlatform cxxPlatform){
      return Linkage.ANY;
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    PythonPlatform pythonPlatform,    CxxPlatform cxxPlatform){
      return PythonPackageComponents.of(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableSet.<SourcePath>of(),Optional.<Boolean>absent());
    }
    @Override public Iterable<AndroidPackageable> getRequiredPackageables(){
      return ImmutableList.of();
    }
    @Override public void addToCollector(    AndroidPackageableCollector collector){
    }
    @Override public ImmutableMap<String,SourcePath> getSharedLibraries(    CxxPlatform cxxPlatform){
      return ImmutableMap.of();
    }
    @Override public boolean isTestedBy(    BuildTarget buildTarget){
      return false;
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,archive,dep));
  BuildTarget target=BuildTargetFactory.newInstance("//:rule");
  CxxBinaryBuilder cxxBinaryBuilder=new CxxBinaryBuilder(target).setSrcs(ImmutableSortedSet.of(SourceWithFlags.of(new FakeSourcePath("test/bar.cpp")),SourceWithFlags.of(new BuildTargetSourcePath(genSource.getBuildTarget())))).setHeaders(ImmutableSortedSet.<SourcePath>of(new FakeSourcePath("test/bar.h"),new BuildTargetSourcePath(genHeader.getBuildTarget()))).setDeps(ImmutableSortedSet.of(dep.getBuildTarget()));
  CxxBinary binRule=(CxxBinary)cxxBinaryBuilder.build(resolver);
  CxxLink rule=binRule.getRule();
  CxxSourceRuleFactory cxxSourceRuleFactory=new CxxSourceRuleFactory(cxxBinaryBuilder.createBuildRuleParams(resolver,projectFilesystem),resolver,pathResolver,cxxPlatform,ImmutableList.<CxxPreprocessorInput>of(),ImmutableList.<String>of(),Optional.<SourcePath>absent());
  assertEquals(ImmutableSet.of(cxxSourceRuleFactory.createCompileBuildTarget("test/bar.cpp",CxxSourceRuleFactory.PicType.PDC),cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC),archive.getBuildTarget()),FluentIterable.from(rule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule1=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget("test/bar.cpp",CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule1=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget("test/bar.cpp",CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule1);
  assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule2=resolver.getRule(cxxSourceRuleFactory.createPreprocessBuildTarget(genSourceName,CxxSource.Type.CXX,CxxSourceRuleFactory.PicType.PDC));
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.getFlavor(),HeaderVisibility.PRIVATE)),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule2=resolver.getRule(cxxSourceRuleFactory.createCompileBuildTarget(genSourceName,CxxSourceRuleFactory.PicType.PDC));
  assertNotNull(compileRule2);
  assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}
