{
  BuildRuleResolver resolver=new BuildRuleResolver();
  SourcePathResolver pathResolver=new SourcePathResolver(resolver);
  String genHeaderName="test/foo.h";
  BuildTarget genHeaderTarget=BuildTargetFactory.newInstance("//:genHeader");
  Genrule genHeader=(Genrule)GenruleBuilder.newGenruleBuilder(genHeaderTarget).setOut(genHeaderName).build(resolver);
  String genSourceName="test/foo.cpp";
  BuildTarget genSourceTarget=BuildTargetFactory.newInstance("//:genSource");
  Genrule genSource=(Genrule)GenruleBuilder.newGenruleBuilder(genSourceTarget).setOut(genSourceName).build(resolver);
  final BuildRule header=createFakeBuildRule("//:header",pathResolver);
  final BuildRule headerSymlinkTree=createFakeBuildRule("//:symlink",pathResolver);
  final Path headerSymlinkTreeRoot=Paths.get("symlink/tree/root");
  final BuildRule archive=createFakeBuildRule("//:archive",pathResolver);
  final Path archiveOutput=Paths.get("output/path/lib.a");
  BuildTarget depTarget=BuildTargetFactory.newInstance("//:dep");
  BuildRuleParams depParams=BuildRuleParamsFactory.createTrivialBuildRuleParams(depTarget);
  AbstractCxxLibrary dep=new AbstractCxxLibrary(depParams,pathResolver){
    @Override public CxxPreprocessorInput getCxxPreprocessorInput(    CxxPlatform cxxPlatform){
      return CxxPreprocessorInput.builder().setRules(ImmutableSet.of(header.getBuildTarget(),headerSymlinkTree.getBuildTarget())).setIncludeRoots(headerSymlinkTreeRoot).build();
    }
    @Override public NativeLinkableInput getNativeLinkableInput(    CxxPlatform cxxPlatform,    Type type){
      return new NativeLinkableInput(ImmutableList.<SourcePath>of(new BuildTargetSourcePath(archive.getBuildTarget())),ImmutableList.of(archiveOutput.toString()));
    }
    @Override public PythonPackageComponents getPythonPackageComponents(    CxxPlatform cxxPlatform){
      return new PythonPackageComponents(ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of(),ImmutableMap.<Path,SourcePath>of());
    }
  }
;
  resolver.addAllToIndex(ImmutableList.of(header,headerSymlinkTree,archive));
  BuildTarget target=BuildTargetFactory.newInstance("//:rule");
  BuildRuleParams params=new FakeBuildRuleParamsBuilder(target).setDeps(ImmutableSortedSet.<BuildRule>of(dep)).build();
  CxxBinaryDescription.Arg arg=new CxxBinaryDescription.Arg();
  arg.deps=Optional.of(ImmutableSortedSet.of(dep.getBuildTarget()));
  arg.srcs=Optional.of(Either.<ImmutableList<SourcePath>,ImmutableMap<String,SourcePath>>ofLeft(ImmutableList.<SourcePath>of(new TestSourcePath("test/bar.cpp"),new BuildTargetSourcePath(genSource.getBuildTarget()))));
  arg.headers=Optional.of(Either.<ImmutableList<SourcePath>,ImmutableMap<String,SourcePath>>ofLeft(ImmutableList.<SourcePath>of(new TestSourcePath("test/bar.h"),new BuildTargetSourcePath(genHeader.getBuildTarget()))));
  arg.compilerFlags=Optional.absent();
  arg.preprocessorFlags=Optional.absent();
  arg.langPreprocessorFlags=Optional.absent();
  arg.lexSrcs=Optional.absent();
  arg.yaccSrcs=Optional.absent();
  arg.headerNamespace=Optional.absent();
  CxxBuckConfig cxxBuckConfig=new CxxBuckConfig(new FakeBuckConfig());
  DefaultCxxPlatform cxxPlatform=new DefaultCxxPlatform(new FakeBuckConfig());
  CxxBinaryDescription description=new CxxBinaryDescription(cxxBuckConfig,cxxPlatform,new FlavorDomain<>("platform",ImmutableMap.<Flavor,CxxPlatform>of()));
  CxxBinary binRule=description.createBuildRule(params,resolver,arg);
  CxxLink rule=binRule.getRule();
  assertEquals(ImmutableSet.of(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",false),CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,false),archive.getBuildTarget()),FluentIterable.from(rule.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule1=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,false,"test/bar.cpp"));
  assertEquals(ImmutableSet.of(genHeaderTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(preprocessRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule1=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),"test/bar.cpp",false));
  assertNotNull(compileRule1);
  assertEquals(ImmutableSet.of(preprocessRule1.getBuildTarget()),FluentIterable.from(compileRule1.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule preprocessRule2=resolver.getRule(CxxPreprocessables.createPreprocessBuildTarget(target,cxxPlatform.asFlavor(),CxxSource.Type.CXX,false,genSourceName));
  assertEquals(ImmutableSet.of(genHeaderTarget,genSourceTarget,headerSymlinkTree.getBuildTarget(),header.getBuildTarget(),CxxDescriptionEnhancer.createHeaderSymlinkTreeTarget(target,cxxPlatform.asFlavor())),FluentIterable.from(preprocessRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
  BuildRule compileRule2=resolver.getRule(CxxCompilableEnhancer.createCompileBuildTarget(target,cxxPlatform.asFlavor(),genSourceName,false));
  assertNotNull(compileRule2);
  assertEquals(ImmutableSet.of(preprocessRule2.getBuildTarget()),FluentIterable.from(compileRule2.getDeps()).transform(HasBuildTarget.TO_TARGET).toSet());
}
