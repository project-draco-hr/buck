{
  Process watchmanProcess=watchmanProcessSupplier.get();
  try {
    LOG.debug("Writing query to Watchman: %s",query);
    watchmanProcess.getOutputStream().write(query.getBytes(Charsets.US_ASCII));
    watchmanProcess.getOutputStream().close();
    LOG.debug("Parsing JSON output from Watchman");
    final long parseStartTimeMillis=clock.currentTimeMillis();
    InputStream jsonInput=watchmanProcess.getInputStream();
    if (LOG.isVerboseEnabled()) {
      byte[] fullResponse=ByteStreams.toByteArray(jsonInput);
      jsonInput.close();
      jsonInput=new ByteArrayInputStream(fullResponse);
      LOG.verbose("Full JSON: " + new String(fullResponse,Charsets.UTF_8).trim());
    }
    JsonParser jsonParser=jsonFactory.createJsonParser(jsonInput);
    PathEventBuilder builder=new PathEventBuilder();
    JsonToken token=jsonParser.nextToken();
    int eventCount=0;
    while (token != null) {
      boolean shouldOverflow=false;
      if (eventCount > overflow) {
        LOG.warn("Received too many events from Watchmen (%d > overflow max %d), posting overflow " + "event and giving up.",eventCount,overflow);
        shouldOverflow=true;
      }
 else {
        long elapsedMillis=clock.currentTimeMillis() - parseStartTimeMillis;
        if (elapsedMillis >= timeoutMillis) {
          LOG.warn("Parsing took too long (timeout %d ms), posting overflow event and giving up.",timeoutMillis);
          shouldOverflow=true;
        }
      }
      if (shouldOverflow) {
        postWatchEvent(createOverflowEvent());
        watchmanProcess.destroy();
        return;
      }
switch (token) {
case FIELD_NAME:
        String fieldName=jsonParser.getCurrentName();
switch (fieldName) {
case "is_fresh_instance":
        Boolean newInstance=jsonParser.nextBooleanValue();
      if (newInstance) {
        LOG.info("Fresh watchman instance detected. " + "Posting overflow event to flush caches.");
        postWatchEvent(createOverflowEvent());
      }
    break;
case "name":
  File file=new File(jsonParser.nextTextValue());
if (!file.isDirectory()) {
  builder.setPath(file.toPath());
}
break;
case "new":
if (jsonParser.nextBooleanValue()) {
builder.setCreationEvent();
}
break;
case "exists":
if (!jsonParser.nextBooleanValue()) {
builder.setDeletionEvent();
}
break;
case "error":
WatchmanWatcherException e=new WatchmanWatcherException(jsonParser.nextTextValue());
LOG.error(e,"Error in Watchman output");
throw e;
}
break;
case END_OBJECT:
if (builder.canBuild()) {
postWatchEvent(builder.build());
++eventCount;
}
builder=new PathEventBuilder();
break;
default :
break;
}
token=jsonParser.nextToken();
}
int watchmanExitCode;
LOG.debug("Posted %d Watchman events. Waiting for subprocess to exit...",eventCount);
watchmanExitCode=watchmanProcess.waitFor();
if (watchmanExitCode != 0) {
LOG.error("Watchman exited with error code %d",watchmanExitCode);
postWatchEvent(createOverflowEvent());
ByteArrayOutputStream buffer=new ByteArrayOutputStream();
ByteStreams.copy(watchmanProcess.getErrorStream(),buffer);
throw new WatchmanWatcherException("Watchman failed with exit code " + watchmanExitCode + ": "+ buffer.toString());
}
 else {
LOG.debug("Watchman exited cleanly.");
}
}
 catch (InterruptedException e) {
LOG.warn(e,"Killing Watchman process on interrupted exception");
postWatchEvent(createOverflowEvent());
watchmanProcess.destroy();
Thread.currentThread().interrupt();
throw e;
}
catch (IOException e) {
LOG.error(e,"Killing Watchman process on I/O exception");
postWatchEvent(createOverflowEvent());
watchmanProcess.destroy();
throw e;
}
}
