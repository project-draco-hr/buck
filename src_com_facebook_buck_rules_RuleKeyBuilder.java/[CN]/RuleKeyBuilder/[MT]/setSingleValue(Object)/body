{
  if (val == null) {
    return feed(new byte[0]);
  }
 else   if (val instanceof Boolean) {
    if (logElms != null) {
      logElms.add(String.format("boolean(\"%s\"):",(boolean)val ? "true" : "false"));
    }
    feed(((boolean)val ? "t" : "f").getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof Enum) {
    if (logElms != null) {
      logElms.add(String.format("enum(%s):",val));
    }
    feed(String.valueOf(val).getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof Number) {
    if (logElms != null) {
      logElms.add(String.format("number(%s):",val));
    }
    Class<?> wrapped=Primitives.wrap(val.getClass());
    if (Double.class.equals(wrapped)) {
      hasher.putDouble(((Double)val).doubleValue());
    }
 else     if (Float.class.equals(wrapped)) {
      hasher.putFloat(((Float)val).floatValue());
    }
 else     if (Integer.class.equals(wrapped)) {
      hasher.putInt(((Integer)val).intValue());
    }
 else     if (Long.class.equals(wrapped)) {
      hasher.putLong(((Long)val).longValue());
    }
 else     if (Short.class.equals(wrapped)) {
      hasher.putShort(((Short)val).shortValue());
    }
 else {
      throw new RuntimeException(("Unhandled number type: " + val.getClass()));
    }
  }
 else   if (val instanceof Path) {
    throw new HumanReadableException("It's not possible to reliably disambiguate Paths. They are disallowed from rule keys");
  }
 else   if (val instanceof String) {
    if (logElms != null) {
      logElms.add(String.format("string(\"%s\"):",val));
    }
    feed(((String)val).getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof BuildRule) {
    return setBuildRule((BuildRule)val);
  }
 else   if (val instanceof BuildRuleType) {
    if (logElms != null) {
      logElms.add(String.format("ruleKeyType(%s):",val));
    }
    feed(val.toString().getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof RuleKey) {
    if (logElms != null) {
      logElms.add(String.format("ruleKey(sha1=%s):",val));
    }
    feed(val.toString().getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof BuildTarget || val instanceof UnflavoredBuildTarget) {
    if (logElms != null) {
      logElms.add(String.format("target(%s):",val));
    }
    feed(((HasBuildTarget)val).getBuildTarget().getFullyQualifiedName().getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof Either) {
    Either<?,?> either=(Either<?,?>)val;
    if (either.isLeft()) {
      setSingleValue(either.getLeft());
    }
 else {
      setSingleValue(either.getRight());
    }
  }
 else   if (val instanceof SourcePath) {
    return setSourcePath((SourcePath)val);
  }
 else   if (val instanceof NonHashableSourcePathContainer) {
    NonHashableSourcePathContainer nonHashableSourcePathContainer=(NonHashableSourcePathContainer)val;
    return setNonHashingSourcePath(nonHashableSourcePathContainer.getSourcePath());
  }
 else   if (val instanceof SourceRoot) {
    if (logElms != null) {
      logElms.add(String.format("sourceroot(%s):",val));
    }
    feed(((SourceRoot)val).getName().getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof SourceWithFlags) {
    SourceWithFlags source=(SourceWithFlags)val;
    setSingleValue(source.getSourcePath());
    feed("[".getBytes(StandardCharsets.UTF_8));
    for (    String flag : source.getFlags()) {
      feed(flag.getBytes(StandardCharsets.UTF_8));
      feed(",".getBytes(StandardCharsets.UTF_8));
    }
    feed("]".getBytes(StandardCharsets.UTF_8));
  }
 else   if (val instanceof Sha1HashCode) {
    setSingleValue(((Sha1HashCode)val).getHash());
  }
 else   if (val instanceof byte[]) {
    if (logElms != null) {
      logElms.add(String.format("byteArray(%s):",val));
    }
    feed((byte[])val);
  }
 else {
    throw new RuntimeException("Unsupported value type: " + val.getClass());
  }
  return this;
}
