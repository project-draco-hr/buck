{
  ImmutableList.Builder<Step> steps=ImmutableList.builder();
  steps.add(new RmStep(getPathToDex(),true));
  steps.add(new MkdirStep(getPathToDex().getParent()));
  final ImmutableSortedMap<String,HashCode> classNamesToHashes=javaLibrary.getClassNamesToHashes();
  final boolean hasClassesToDx=!classNamesToHashes.isEmpty();
  final Supplier<Integer> linearAllocEstimate;
  if (hasClassesToDx) {
    Path pathToOutputFile=javaLibrary.getPathToOutput();
    EstimateLinearAllocStep estimate=new EstimateLinearAllocStep(pathToOutputFile);
    steps.add(estimate);
    linearAllocEstimate=estimate;
    DxStep dx=new DxStep(getPathToDex(),Collections.singleton(pathToOutputFile),EnumSet.of(DxStep.Option.USE_CUSTOM_DX_IF_AVAILABLE,DxStep.Option.RUN_IN_PROCESS,DxStep.Option.NO_OPTIMIZE,DxStep.Option.FORCE_JUMBO));
    steps.add(dx);
    steps.add(new ZipScrubberStep(getPathToDex()));
  }
 else {
    linearAllocEstimate=Suppliers.ofInstance(0);
  }
  String stepName=hasClassesToDx ? "record_dx_success" : "record_empty_dx";
  AbstractExecutionStep recordArtifactAndMetadataStep=new AbstractExecutionStep(stepName){
    @Override public int execute(    ExecutionContext context) throws IOException {
      if (hasClassesToDx) {
        buildableContext.recordArtifact(getPathToDex());
      }
      buildableContext.addMetadata(LINEAR_ALLOC_KEY_ON_DISK_METADATA,String.valueOf(linearAllocEstimate.get()));
      buildableContext.addMetadata(CLASSNAMES_TO_HASHES,context.getObjectMapper().writeValueAsString(Maps.transformValues(classNamesToHashes,Functions.toStringFunction())));
      return 0;
    }
  }
;
  steps.add(recordArtifactAndMetadataStep);
  return steps.build();
}
