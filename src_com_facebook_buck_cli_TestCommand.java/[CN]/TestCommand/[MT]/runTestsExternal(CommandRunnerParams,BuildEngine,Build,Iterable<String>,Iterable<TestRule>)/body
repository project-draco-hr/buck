{
  List<String> infoFileArgs=Lists.newArrayList();
  for (  TestRule testRule : testRules) {
    if (!(testRule instanceof ExternalTestRunnerRule)) {
      params.getBuckEventBus().post(ConsoleEvent.severe(String.format("Test %s does not support external test running",testRule.getBuildTarget())));
      return 1;
    }
    RuleKey ruleKey=buildEngine.getRuleKey(testRule.getBuildTarget());
    Path infoFile=params.getCell().getFilesystem().resolve(testRule.getPathToTestOutputDirectory().resolve(String.format("external_runner.%s.json",ruleKey)));
    if (!Files.exists(infoFile) || !isResultsCacheEnabled(params.getBuckConfig())) {
      Files.createDirectories(infoFile.getParent());
      ExternalTestRunnerRule rule=(ExternalTestRunnerRule)testRule;
      params.getObjectMapper().writeValue(infoFile.toFile(),rule.getExternalTestRunnerSpec(build.getExecutionContext(),getTestRunningOptions(params)));
    }
    infoFileArgs.add(infoFile.toString());
  }
  ListeningProcessExecutor processExecutor=new ListeningProcessExecutor();
  ProcessExecutorParams processExecutorParams=ProcessExecutorParams.builder().addAllCommand(command).addAllCommand(infoFileArgs).setDirectory(params.getCell().getFilesystem().getRootPath().toFile()).build();
  final WritableByteChannel stdout=Channels.newChannel(params.getConsole().getStdOut());
  final WritableByteChannel stderr=Channels.newChannel(params.getConsole().getStdErr());
  ListeningProcessExecutor.ProcessListener processListener=new ListeningProcessExecutor.ProcessListener(){
    @Override public void onStart(    ListeningProcessExecutor.LaunchedProcess process){
    }
    @Override public void onExit(    int exitCode){
    }
    @Override public void onStdout(    ByteBuffer buffer,    boolean closed){
      try {
        stdout.write(buffer);
      }
 catch (      IOException e) {
        throw Throwables.propagate(e);
      }
    }
    @Override public void onStderr(    ByteBuffer buffer,    boolean closed){
      try {
        stderr.write(buffer);
      }
 catch (      IOException e) {
        throw Throwables.propagate(e);
      }
    }
    @Override public boolean onStdinReady(    ByteBuffer buffer){
      buffer.flip();
      return false;
    }
  }
;
  ListeningProcessExecutor.LaunchedProcess process=processExecutor.launchProcess(processExecutorParams,processListener);
  return processExecutor.waitForProcess(process,Long.MAX_VALUE,TimeUnit.DAYS);
}
