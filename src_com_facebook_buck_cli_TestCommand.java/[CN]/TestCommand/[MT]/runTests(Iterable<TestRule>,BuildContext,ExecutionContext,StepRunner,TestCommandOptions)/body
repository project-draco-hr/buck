{
  ImmutableSet<JavaLibraryRule> rulesUnderTest;
  if (options.isCodeCoverageEnabled()) {
    rulesUnderTest=getRulesUnderTest(tests);
    if (!rulesUnderTest.isEmpty()) {
      try {
        if (options.isJacocoEnabled()) {
          stepRunner.runStep(new MakeCleanDirectoryStep(JUnitStep.JACOCO_OUTPUT_DIR));
        }
 else {
          stepRunner.runStep(new MakeCleanDirectoryStep(JUnitStep.EMMA_OUTPUT_DIR));
          stepRunner.runStep(getInstrumentCommand(rulesUnderTest,executionContext.getProjectFilesystem()));
        }
      }
 catch (      StepFailedException e) {
        console.printBuildFailureWithoutStacktrace(e);
        DebugLog.log("Failing test run due to code coverage exception: " + e.toString());
        return 1;
      }
    }
  }
 else {
    rulesUnderTest=ImmutableSet.of();
  }
  getBuckEventBus().post(TestRunEvent.started(options.isRunAllTests(),options.getArgumentsFormattedAsBuildTargets()));
  List<ListenableFuture<TestResults>> results=Lists.newArrayList();
  Verbosity verbosity=console.getVerbosity();
  final boolean printTestResults=(verbosity != Verbosity.SILENT);
  FutureCallback<TestResults> onTestFinishedCallback=new FutureCallback<TestResults>(){
    @Override public void onSuccess(    TestResults testResults){
      if (printTestResults) {
        getBuckEventBus().post(IndividualTestEvent.finished(options.getArgumentsFormattedAsBuildTargets(),testResults));
      }
    }
    @Override public void onFailure(    Throwable throwable){
      throwable.printStackTrace(getStdErr());
    }
  }
;
  TestRuleKeyFileHelper testRuleKeyFileHelper=new TestRuleKeyFileHelper(executionContext.getProjectFilesystem());
  for (  TestRule test : tests) {
    List<Step> steps;
    boolean isTestRunRequired=isTestRunRequiredForTest(test,executionContext,testRuleKeyFileHelper);
    if (isTestRunRequired) {
      getBuckEventBus().post(IndividualTestEvent.started(options.getArgumentsFormattedAsBuildTargets()));
      ImmutableList.Builder<Step> stepsBuilder=ImmutableList.builder();
      List<Step> testSteps=test.runTests(buildContext,executionContext);
      if (!testSteps.isEmpty()) {
        stepsBuilder.addAll(testSteps);
        stepsBuilder.add(testRuleKeyFileHelper.createRuleKeyInDirStep(test));
      }
      steps=stepsBuilder.build();
    }
 else {
      steps=ImmutableList.of();
    }
    ListenableFuture<TestResults> testResults=stepRunner.runStepsAndYieldResult(steps,getCachingStatusTransformingCallable(isTestRunRequired,test.interpretTestResults(executionContext)),test.getBuildTarget());
    Futures.addCallback(testResults,onTestFinishedCallback);
    results.add(testResults);
  }
  ListenableFuture<List<TestResults>> uberFuture=Futures.allAsList(results);
  List<TestResults> completedResults;
  try {
    completedResults=uberFuture.get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace(getStdErr());
    DebugLog.log("Failing test run due to interrupted exception: " + e.toString());
    return 1;
  }
catch (  ExecutionException e) {
    e.printStackTrace(getStdErr());
    DebugLog.log("Failing test run due to execution exception: " + e.toString());
    return 1;
  }
  getBuckEventBus().post(TestRunEvent.finished(options.getArgumentsFormattedAsBuildTargets(),completedResults));
  if (options.getPathToXmlTestOutput() != null) {
    try (Writer writer=Files.newWriter(new File(options.getPathToXmlTestOutput()),Charsets.UTF_8)){
      writeXmlOutput(completedResults,writer);
    }
   }
  if (options.isCodeCoverageEnabled() && !rulesUnderTest.isEmpty()) {
    try {
      Optional<DefaultJavaPackageFinder> defaultJavaPackageFinderOptional=options.getJavaPackageFinder();
      Path outputDirectory;
      if (options.isJacocoEnabled()) {
        outputDirectory=JUnitStep.JACOCO_OUTPUT_DIR;
      }
 else {
        outputDirectory=JUnitStep.EMMA_OUTPUT_DIR;
      }
      stepRunner.runStep(getReportCommand(rulesUnderTest,defaultJavaPackageFinderOptional,getProjectFilesystem(),outputDirectory));
    }
 catch (    StepFailedException e) {
      console.printBuildFailureWithoutStacktrace(e);
      DebugLog.log("Failing test run due to coverage step exception: " + e.toString());
      return 1;
    }
  }
  boolean failures=Iterables.any(completedResults,new Predicate<TestResults>(){
    @Override public boolean apply(    TestResults results){
      return !results.isSuccess();
    }
  }
);
  if (failures) {
    StringBuilder message=new StringBuilder();
    message.append("Failing test run due to failed tests:\n");
    for (    TestResults completedResult : completedResults) {
      if (!completedResult.isSuccess()) {
        message.append("  ").append(completedResult.getBuildTarget()).append("\n");
      }
    }
    DebugLog.log(message.toString());
  }
  return failures ? 1 : 0;
}
