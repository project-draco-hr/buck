{
  ImmutableSet.Builder<File> removals=ImmutableSet.builder();
  Table<String,Density,String> imageValues=HashBasedTable.create();
  for (  String candidate : candidates) {
    File f=new File(candidate);
    Qualifiers qualifiers=new Qualifiers(f);
    String filename=f.getName();
    Density density=qualifiers.density;
    String resDirectory=f.getParentFile().getParent();
    String key=String.format("%s/%s/%s",resDirectory,filename,qualifiers.others);
    imageValues.put(key,density,candidate);
  }
  for (  String key : imageValues.rowKeySet()) {
    Map<Density,String> options=imageValues.row(key);
    Set<Density> available=options.keySet();
    Set<Density> targets=targetDensities;
    if (available.contains(Density.NO_QUALIFIER) && !available.contains(Density.MDPI)) {
      targets=Sets.newHashSet(Iterables.transform(targetDensities,new Function<Density,Density>(){
        @Override public Density apply(        Density input){
          return (input == Density.MDPI) ? Density.NO_QUALIFIER : input;
        }
      }
));
    }
    Set<Density> toKeep=Sets.newHashSet(Sets.intersection(available,targets));
    Density largestTarget=Density.ORDERING.max(targets);
    if (!available.contains(largestTarget)) {
      Density fallback=null;
      if (canDownscale && !options.values().iterator().next().endsWith(".9.png")) {
        fallback=Density.ORDERING.max(available);
      }
 else {
        for (        Density candidate : Density.ORDERING.reverse().sortedCopy(available)) {
          if (fallback == null || Density.ORDERING.compare(candidate,largestTarget) > 0) {
            fallback=candidate;
          }
        }
      }
      toKeep.add(fallback);
    }
    for (    Density density : Sets.difference(available,toKeep)) {
      removals.add(new File(options.get(density)).getAbsoluteFile());
    }
  }
  return removals.build();
}
