{
  final String packagePrefix="  Package [" + packageName + "] (";
  final String otherPrefix="  Package [";
  boolean sawPackageLine=false;
  final Splitter splitter=Splitter.on('=').limit(2);
  String codePath=null;
  String resourcePath=null;
  String versionCode=null;
  for (  String line : Splitter.on("\r\n").split(lines)) {
    if (line.startsWith(packagePrefix)) {
      sawPackageLine=true;
      continue;
    }
    if (line.startsWith(otherPrefix)) {
      break;
    }
    if (!sawPackageLine) {
      continue;
    }
    List<String> parts=splitter.splitToList(line.trim());
    if (parts.size() != 2) {
      continue;
    }
switch (parts.get(0)) {
case "codePath":
      codePath=parts.get(1);
    break;
case "resourcePath":
  resourcePath=parts.get(1);
break;
case "versionCode":
versionCode=parts.get(1).split(" ",2)[0];
break;
default :
break;
}
}
if (!sawPackageLine) {
return Optional.absent();
}
Preconditions.checkNotNull(codePath,"Could not find codePath");
Preconditions.checkNotNull(resourcePath,"Could not find resourcePath");
Preconditions.checkNotNull(versionCode,"Could not find versionCode");
if (!codePath.equals(resourcePath)) {
throw new IllegalStateException("Code and resource path do not match");
}
return Optional.of(new PackageInfo(codePath,versionCode));
}
