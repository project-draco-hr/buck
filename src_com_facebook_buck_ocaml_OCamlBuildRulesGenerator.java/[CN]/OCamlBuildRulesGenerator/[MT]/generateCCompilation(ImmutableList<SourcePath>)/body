{
  ImmutableList.Builder<SourcePath> objects=ImmutableList.builder();
  ImmutableList.Builder<String> cCompileFlags=ImmutableList.builder();
  cCompileFlags.addAll(ocamlContext.getCCompileFlags());
  cCompileFlags.addAll(ocamlContext.getCommonCFlags());
  CxxPreprocessorInput cxxPreprocessorInput=ocamlContext.getCxxPreprocessorInput();
  for (  SourcePath cSrc : cInput) {
    String name=pathResolver.getAbsolutePath(cSrc).toFile().getName();
    BuildTarget target=createCCompileBuildTarget(params.getBuildTarget(),name);
    BuildRuleParams cCompileParams=params.copyWithChanges(target,Suppliers.ofInstance(ImmutableSortedSet.<BuildRule>naturalOrder().addAll(pathResolver.filterBuildRuleInputs(ImmutableList.<SourcePath>builder().add(cSrc).addAll(cxxPreprocessorInput.getIncludes().getNameToPathMap().values()).build())).addAll(BuildRules.toBuildRulesFor(params.getBuildTarget(),resolver,cxxPreprocessorInput.getRules())).addAll(params.getDeclaredDeps().get()).build()),params.getExtraDeps());
    Path outputPath=ocamlContext.getCOutput(pathResolver.getRelativePath(cSrc));
    OCamlCCompile compileRule=new OCamlCCompile(cCompileParams,pathResolver,new OCamlCCompileStep.Args(cCompiler.getEnvironment(pathResolver),cCompiler.getCommandPrefix(pathResolver),ocamlContext.getOcamlCompiler().get(),outputPath,cSrc,cCompileFlags.build(),ImmutableMap.copyOf(cxxPreprocessorInput.getIncludes().getNameToPathMap())));
    resolver.addToIndex(compileRule);
    objects.add(new BuildTargetSourcePath(compileRule.getBuildTarget()));
  }
  return objects.build();
}
