{
  ImmutableMap<Path,Path> replacementPaths;
  try {
    replacementPaths=preprocessorDelegate.getReplacementPaths();
  }
 catch (  AbstractCxxHeaders.ConflictingHeadersException e) {
    throw e.getHumanReadableExceptionForBuildTarget(getBuildTarget());
  }
  return ImmutableList.of(new MkdirStep(getProjectFilesystem(),output.getParent()),new CxxPreprocessAndCompileStep(getProjectFilesystem(),CxxPreprocessAndCompileStep.Operation.GENERATE_PCH,getPathToOutput(),getDepFilePath(),getResolver().getAbsolutePath(input),inputType,Optional.of(new CxxPreprocessAndCompileStep.ToolCommand(ImmutableList.<String>builder().addAll(preprocessorDelegate.getPreprocessor().getCommandPrefix(getResolver())).addAll(preprocessorDelegate.getPreprocessorPlatformPrefix()).addAll(preprocessorDelegate.getPreprocessorSuffix()).build(),preprocessorDelegate.getEnvironment(),preprocessorDelegate.getColorSupport())),Optional.<CxxPreprocessAndCompileStep.ToolCommand>absent(),replacementPaths,sanitizer,Optional.<Function<String,Iterable<String>>>absent()));
}
